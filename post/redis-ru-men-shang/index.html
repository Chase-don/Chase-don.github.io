<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Redis入门（上） | Loro</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://chase-don.github.io//favicon.ico?v=1620666848926">
<link rel="stylesheet" href="https://chase-don.github.io//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1. NoSql简介
1.1 有什么作用？
主要可用：（减少cpu和io压力，通过内存读取以及作为缓存数据库，减少io读操作）


1.2 什么是NoSql
NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，..." />
    <meta name="keywords" content="学习笔记" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://chase-don.github.io/">
        <img src="https://chase-don.github.io//images/avatar.png?v=1620666848926" class="site-logo">
        <h1 class="site-title">Loro</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Chase-don" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      表现不俗
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://chase-don.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Redis入门（上）</h2>
            <div class="post-date">2021-04-11</div>
            
            <div class="post-content" v-pre>
              <h2 id="1-nosql简介">1. NoSql简介</h2>
<h3 id="11-有什么作用">1.1 有什么作用？</h3>
<p>主要可用：<strong><mark>（减少cpu和io压力，通过内存读取以及作为缓存数据库，减少io读操作）</mark></strong></p>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210502183814449.png" alt="image-20210502183814449" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210502183823144.png" alt="image-20210502183823144" loading="lazy"></figure>
<h3 id="12-什么是nosql">1.2 什么是NoSql</h3>
<p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。</p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的<mark>key-value</mark>模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>
<p>不遵循SQL标准。</p>
</li>
<li>
<p>不支持ACID。  ---&gt;   <strong>这里只是不支持ACID四个特性，不等于不支持事务！</strong></p>
</li>
<li>
<p>远超于SQL的性能。</p>
</li>
</ul>
<h3 id="13-nosql的相关使用场景">1.3 Nosql的相关使用场景</h3>
<h4 id="131-nosql适用场景"><strong>1.3.1.</strong>  NoSQL适用场景</h4>
<ol>
<li>
<p><strong>对数据高并发的读写 （秒杀功能）</strong></p>
</li>
<li>
<p><strong>海量数据的读写</strong></p>
</li>
<li>
<p><strong>对数据高可扩展性的</strong></p>
</li>
</ol>
<h4 id="132-nosql不适用场景"><strong>1.3.2.</strong>  <strong>NoSQL</strong>不适用场景</h4>
<ol>
<li>
<p>需要事务支持</p>
</li>
<li>
<p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
</li>
<li>
<p>（<strong>用不着sql的和用了sql也不行的情况，请考虑用NoSql</strong>）</p>
</li>
</ol>
<h2 id="2-redis概述"><strong>2.</strong>  <strong>Redis</strong>概述</h2>
<p>Ø Redis是一个<strong>开源的key-value</strong>存储系统。</p>
<p>Ø 和Memcached（支持类型单一，只能支持字符串）类似，它支持存储的value类型相对更多，包括<strong>string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</strong></p>
<p>Ø 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且**<mark>这些操作都是原子性的</mark>**。</p>
<p>Ø 在此基础上，Redis支持各种不同方式的排序。</p>
<p>Ø 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>Ø 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>Ø 并且在此基础上实现了master-slave(主从)同步。</p>
<h3 id="21-redis的应用场景">2.1 Redis的应用场景</h3>
<h4 id="211-配合关系型数据库做高速缓存">2.1.1 <strong>配合关系型数据库做高速缓存</strong></h4>
<ul>
<li>
<p>高频次，热门访问的数据，降低数据库IO</p>
</li>
<li>
<p>分布式架构，做session共享</p>
</li>
</ul>
<h4 id="212-多样的数据结构存储持久化数据">2.1.2 <strong>多样的数据结构存储持久化数据</strong></h4>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210502185353584.png" alt="image-20210502185353584" loading="lazy"></figure>
<h2 id="3-redis安装略">3. Redis安装（略）</h2>
<h3 id="31-后台登录在usrlocalbin下执行">3.1 后台登录：（在/usr/local/bin下执行）</h3>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210502203013686.png" alt="image-20210502203013686" loading="lazy"></figure>
<p>通过宝塔下载redis，可以直接在<code>/www/server/redis</code>下执行前后台命令</p>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210502204522393.png" alt="image-20210502204522393" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/image-20210502204814673.png" alt="image-20210502204814673" loading="lazy"></figure>
<h3 id="32-测试性能redis-benchmark">3.2 测试性能（redis-benchmark）</h3>
<p>redis-benchmark是一个压力测试工具</p>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210502210716077.png" alt="image-20210502210716077" loading="lazy"></figure>
<p>做个测试：（100个并发连接  100000个请求）</p>
<pre><code class="language-bash">redis-benchmark -h localhost -p 6379 -c 100 -n 100000
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210502211115433.png" alt="image-20210502211115433" loading="lazy"></figure>
<blockquote>
<p>如何查看这些分析？</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210502211726337.png" alt="image-20210502211726337" loading="lazy"></figure>
<h2 id="4-redis基础知识">4. Redis基础知识</h2>
<h3 id="41-redis默认有16个数据库编号为0-15默认使用第0个用select来切换数据库">4.1 Redis<strong>默认有16个数据库，编号为0-15</strong>，默认使用第0个；用<code>select</code>来切换数据库</h3>
<figure data-type="image" tabindex="10"><img src="https://chase-don.github.io//post-images/image-20210502212709893.png" alt="image-20210502212709893" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://chase-don.github.io//post-images/image-20210502213149095.png" alt="image-20210502213149095" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://chase-don.github.io//post-images/image-20210502213304143.png" alt="image-20210502213304143" loading="lazy"></figure>
<pre><code class="language-bash"># 查看所有的key
127.0.0.1:6379[3]&gt; keys *
1) &quot;name&quot;
</code></pre>
<h3 id="42-清空数据库flushdb-和-flushall">4.2 清空数据库（<code>flushdb</code>  和 <code>flushall</code>）</h3>
<pre><code class="language-bash"># 清除当前数据库
127.0.0.1:6379[3]&gt; flushdb
OK

# 清空全部数据库
127.0.0.1:6379[3]&gt; flushall
OK
</code></pre>
<h3 id="43-redis与memcache的不同">4.3 Redis与Memcache的不同:</h3>
<ul>
<li>Redis支持多数据类型，Memcache支持单一数据类型（字符型）</li>
<li>redis支持持久化，memcache不支持</li>
<li><strong><mark>redis是单线程+多路IO复用，memcache是多线程+锁</mark></strong></li>
</ul>
<h2 id="5-五大常用数据类型类型指的都是value的类型">5. 五大常用数据类型（类型指的都是value的类型）</h2>
<h3 id="51-关于redis键key的基本命令">5.1 关于Redis键（key）的基本命令</h3>
<blockquote>
<p>**keys <em>： 查看当前库所有key  (匹配：keys <em>1)</em></em></p>
<p><strong>exists key： 判断某个key是否存在</strong></p>
<p><strong>type key：  查看你的key是什么类型</strong></p>
<p><strong>del key  ：  删除指定的key数据</strong></p>
<p><mark><strong>unlink key ： 根据value选择非阻塞删除</strong></mark>，（仅将keys从keyspace元数据中删除，真正的删除会在后续<strong>异步</strong>操作）。</p>
<p><mark><strong>expire key 10  ：10秒钟，为给定的key设置过期时间</strong></mark>，<strong><mark>过期后的键便不再存在</mark></strong></p>
<p><strong>ttl key ： 查看还有多少秒过期，-1表示永不过期，-2表示已过期</strong></p>
<figure data-type="image" tabindex="13"><img src="https://chase-don.github.io//post-images/image-20210502235550183.png" alt="image-20210502235550183" loading="lazy"></figure>
<p>select ：命令切换数据库</p>
<p>dbsize ：查看当前数据库的key的数量</p>
<p>flushdb ：清空当前库</p>
<p>flushall ：清空全部库</p>
</blockquote>
<h3 id="52-字符串string">5.2 字符串String</h3>
<h4 id="521-简介">5.2.1 简介</h4>
<ol>
<li>
<p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，<strong>一个key对应一个value</strong>。</p>
</li>
<li>
<p>String类型是**<mark>二进制安全的</mark><strong>。意味着Redis的string</strong>可以包含任何数据。比如jpg图片或者序列化的对象**。</p>
</li>
<li>
<p>String类型是Redis最基本的数据类型，一个Redis中**<mark>字符串value最多可以是512M</mark>**</p>
</li>
</ol>
<h4 id="522-常用命令">5.2.2 常用命令</h4>
<blockquote>
<p><strong>set  <key><value> ： 添加键值对，如果键已经存在，则进行覆盖</strong></p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  <key> ： 查询对应键值</p>
<p>append <key><value> ： 将给定的<value> 追加到原值的末尾，类似stringbuffer的append操作</p>
<p>strlen <key> ： 获得值的长度</p>
<p><strong>setnx <key><value> ： 只有在 key 不存在时  设置 key 的值</strong></p>
</blockquote>
<blockquote>
<p><strong>incr <key></strong></p>
<p>​		将 key 中储存的数字值增1，<strong><mark>存储的一定要是数字类型</mark></strong>，<strong>下面的k1就不是数字类型，所以没法进行操作</strong></p>
<p>​		只能对数字值操作，如果为空，新增值为1</p>
<figure data-type="image" tabindex="14"><img src="https://chase-don.github.io//post-images/image-20210503002632591.png" alt="image-20210503002632591" loading="lazy"></figure>
<p><strong>decr <key></strong></p>
<p>​		将 key 中储存的数字值减1</p>
<p>​		只能对数字值操作，如果为空，新增值为-1</p>
<p><strong>incrby / decrby <key>&lt;步长&gt;</strong> ： 将 key 中储存的数字值增减。自定义步长。</p>
<figure data-type="image" tabindex="15"><img src="https://chase-don.github.io//post-images/image-20210503002524836.png" alt="image-20210503002524836" loading="lazy"></figure>
</blockquote>
<p><strong>补充关于原子性：</strong></p>
<img src="file://D:/博客源文件/post-images/image-20210503002905082.png" alt="image-20210503002905082" style="zoom:150%;" />
<p>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。</p>
<p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
<p><mark><strong>Redis单命令的原子性主要得益于Redis的单线程</strong>。</mark></p>
<blockquote>
<p><strong>mset <key1><value1><key2><value2> .....</strong></p>
<p>​		作用：同时设置一个或多个 key-value对</p>
<p>mget <key1><key2><key3> .....</p>
<p>​		作用：同时获取一个或多个 value</p>
<p><strong><mark>msetnx <key1><value1><key2><value2> .....</mark></strong>   ----&gt;   <strong>是个原子性操作！</strong></p>
<p>​		作用：<strong>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</strong><mark><strong>原子性，有一个失败则都失败</strong></mark></p>
<figure data-type="image" tabindex="16"><img src="https://chase-don.github.io//post-images/image-20210503004706188.png" alt="image-20210503004706188" loading="lazy"></figure>
<p>getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;</p>
<p>​		作用：获得值的范围，类似java中的substring，<mark><strong>前包，后包</strong></mark></p>
<figure data-type="image" tabindex="17"><img src="https://chase-don.github.io//post-images/image-20210503004924760.png" alt="image-20210503004924760" loading="lazy"></figure>
<p>setrange <key>&lt;起始位置&gt;<value></p>
<p>​		作用：用 <value> <strong><mark>覆写</mark></strong><key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p>
<figure data-type="image" tabindex="18"><img src="https://chase-don.github.io//post-images/image-20210503005237818.png" alt="image-20210503005237818" loading="lazy"></figure>
<p><strong><mark>setex <key>&lt;过期时间&gt;<value></mark></strong></p>
<p>​		作用：设置键值的同时，设置过期时间，单位秒。</p>
<figure data-type="image" tabindex="19"><img src="https://chase-don.github.io//post-images/image-20210504012519929.png" alt="image-20210504012519929" loading="lazy"></figure>
<p>getset <key><value></p>
<p>​		作用：以新换旧，设置了新值同时获得旧值。</p>
<figure data-type="image" tabindex="20"><img src="https://chase-don.github.io//post-images/image-20210504012652550.png" alt="image-20210504012652550" loading="lazy"></figure>
</blockquote>
<h3 id="53-列表list">5.3 列表（List）</h3>
<h4 id="531-简介">5.3.1 简介</h4>
<p>特点：<mark><strong>单键多值</strong></mark></p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的<strong>底层实际是个双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<figure data-type="image" tabindex="21"><img src="https://chase-don.github.io//post-images/image-20210504013032198.png" alt="image-20210504013032198" loading="lazy"></figure>
<h4 id="532-常用命令">5.3.2 常用命令</h4>
<blockquote>
<p>**lpush/rpush <key><value1><value2><value3> .... **</p>
<p>​		作用：<strong>从左边/右边插入一个或多个值。</strong></p>
<p><strong>lpop/rpop <key></strong></p>
<p>​		作用：<strong>从左边/右边吐出一个值。值在键在，值光键亡。</strong></p>
<figure data-type="image" tabindex="22"><img src="https://chase-don.github.io//post-images/image-20210504014658580.png" alt="image-20210504014658580" loading="lazy"></figure>
<p><strong>rpoplpush <key1><key2></strong></p>
<p>​		作用：<strong>从<key1>列表右边吐出一个值，插到<key2>列表左边。</strong></p>
<figure data-type="image" tabindex="23"><img src="https://chase-don.github.io//post-images/image-20210504151612570.png" alt="image-20210504151612570" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>lrange <key><start><stop></strong></p>
<p>​		作用：<strong>按照索引下标获得元素(从左到右)</strong></p>
<p><strong><mark>lrange <key> 0 -1</mark></strong> 	 <strong><mark>0左边第一个，-1右边第一个，（0-1表示获取所有）</mark></strong></p>
<p><strong>lindex <key><index></strong></p>
<p>​		作用：<strong>按照索引下标获得元素(从左到右)</strong></p>
<p><strong>llen <key></strong></p>
<p>​		作用：<strong>获得列表长度</strong></p>
<figure data-type="image" tabindex="24"><img src="https://chase-don.github.io//post-images/image-20210504161346137.png" alt="image-20210504161346137" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>linsert <key> <mark>before/after</mark> <value><newvalue></strong></p>
<p>​		作用：<strong>在<value>的前面/后面插入<newvalue>插入值</strong></p>
<figure data-type="image" tabindex="25"><img src="https://chase-don.github.io//post-images/image-20210504162503408.png" alt="image-20210504162503408" loading="lazy"></figure>
<p><strong>lrem <key><n><value></strong></p>
<p>​		作用：<strong>从左边<mark>删除n个value</mark>(从左到右)</strong>,value是相同的值</p>
<p><strong>lset<key><index><value></strong></p>
<p>​		作用：<strong>将列表key下标为index的值替换成value</strong>，替换操作</p>
</blockquote>
<h4 id="533-数据结构">5.3.3 数据结构</h4>
<p>List的数据结构为**<mark>快速链表quickList</mark>**。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个**<mark>结构是ziplist</mark>**，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<figure data-type="image" tabindex="26"><img src="https://chase-don.github.io//post-images/image-20210504163342735.png" alt="image-20210504163342735" loading="lazy"></figure>
<p><strong>Redis将链表和ziplist结合起来组成了quicklist</strong>。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3 id="54-集合set">5.4 集合（Set）</h3>
<h4 id="541-简介">5.4.1 简介</h4>
<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的<strong>无序集合</strong>。它**<mark>底层其实是一个value为null的hash表</mark><strong>，所以添加，删除，查找的</strong>复杂度都是O(1)**。</p>
<h4 id="542-常用命令">5.4.2 常用命令</h4>
<blockquote>
<p><strong>sadd <key><value1><value2> .....</strong></p>
<p>​		作用：<strong>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</strong></p>
<p><strong>smembers <key></strong></p>
<p>​		作用：<strong>取出该集合的所有值。</strong></p>
<p><strong>sismember <key><value></strong></p>
<p>​		作用：<strong>判断集合<key>是否为含有该<value>值，有1，没有0</strong></p>
<p><strong>scard<key></strong></p>
<p>​		作用：<strong>返回该集合的元素个数。</strong></p>
<p><strong>srem <key><value1><value2> ....</strong></p>
<p>​		作用：<strong>删除集合中的某个元素。</strong></p>
<p><strong>spop <key></strong></p>
<p>​		作用：<strong>随机从该集合中吐出一个值。</strong></p>
<figure data-type="image" tabindex="27"><img src="https://chase-don.github.io//post-images/image-20210504165124570.png" alt="image-20210504165124570" loading="lazy"></figure>
<p><strong>srandmember <key><n></strong></p>
<p>​		作用：<strong>随机从该集合中取出n个值。不会从集合中删除 。</strong></p>
<figure data-type="image" tabindex="28"><img src="https://chase-don.github.io//post-images/image-20210504165438159.png" alt="image-20210504165438159" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>smove <source><destination>value</strong></p>
<p>​		作用：<strong>把集合中一个值从一个集合移动到另一个集合</strong></p>
<p><strong>sinter <key1><key2></strong></p>
<p>​		作用：<strong>返回两个集合的交集元素。</strong></p>
<p><strong>sunion <key1><key2></strong></p>
<p>​		作用：<strong>返回两个集合的并集元素。</strong></p>
<p><strong>sdiff <key1><key2></strong></p>
<p>​		作用：<strong>返回两个集合的<mark>差集元素</mark>(key1中的，不包含key2中的)</strong></p>
<figure data-type="image" tabindex="29"><img src="https://chase-don.github.io//post-images/image-20210504170330011.png" alt="image-20210504170330011" loading="lazy"></figure>
</blockquote>
<h3 id="55-哈希hash">5.5 哈希（Hash）</h3>
<h4 id="551-简介">5.5.1 简介</h4>
<p>Redis hash 是一个<strong>键值对集合</strong>。</p>
<p>Redis hash是<strong>一个<mark>string类型的field和value的映射表</mark>，hash特别<mark>适合用于存储对象</mark></strong>。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<figure data-type="image" tabindex="30"><img src="https://chase-don.github.io//post-images/image-20210504171115254.png" alt="image-20210504171115254" loading="lazy"></figure>
<h4 id="552-常用命令">5.5.2 常用命令</h4>
<blockquote>
<p><strong>hset <key><field><value></strong></p>
<p>​		作用：<strong>给<key>集合中的 <field>键赋值<value></strong></p>
<p><strong>hget <key1><field></strong></p>
<p>​		作用：<strong>从<key1>集合<field>取出 value</strong></p>
<p>**hmset <key1><field1><value1><field2><value2>... **</p>
<p>​		作用：<strong>批量设置hash的值</strong></p>
<p><strong>hexists<key1><field></strong></p>
<p>​		作用：<strong>查看哈希表 key 中，给定域 field 是否存在。</strong></p>
<p><strong>hkeys <key></strong></p>
<p>​		作用：<strong>列出该hash集合的所有field</strong></p>
<p><strong>hvals <key></strong></p>
<p>​		作用：<strong>列出该hash集合的所有value</strong></p>
<figure data-type="image" tabindex="31"><img src="https://chase-don.github.io//post-images/image-20210504174449971.png" alt="image-20210504174449971" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>hincrby <key><field><increment></strong></p>
<p>​		作用：<strong>为哈希表 key 中的域 field 的值加上增量 1  -1</strong></p>
<p><strong>hsetnx <key><field><value></strong></p>
<p>​		作用：<strong>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</strong></p>
<p><strong>hdel <key> <field> [<field>...]</strong></p>
<p>​		作用：<strong>将哈希表 key 中的域 field 删除，对应的value也一并删除.</strong></p>
<figure data-type="image" tabindex="32"><img src="https://chase-don.github.io//post-images/image-20210504180124190.png" alt="image-20210504180124190" loading="lazy"></figure>
</blockquote>
<h4 id="553-数据结构">5.5.3 数据结构</h4>
<p>Hash类型对应的数据结构是两种：<strong>ziplist（压缩列表），hashtable（哈希表）</strong>。当**<mark>field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</mark>**</p>
<h3 id="56-有序集合zset">5.6 有序集合（Zset）</h3>
<h4 id="561-简介">5.6.1 简介</h4>
<p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个==<strong>评分（score）</strong><mark>,这个评分（score）被用来按照</mark><strong>从最低分到最高分的方式排序</strong>==集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h4 id="562-常用命令">5.6.2 常用命令</h4>
<blockquote>
<p><strong>zadd <key> <score1> <value1> <score2> <value2>…</strong></p>
<p>​		作用：<strong>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</strong></p>
</blockquote>
<blockquote>
<p><strong>zincrby <key> <increment> <value></strong></p>
<p>​		作用：<strong>为元素的score加上增量</strong></p>
<p><strong>zrem <key><value></strong></p>
<p>​		作用：<strong>删除该集合下，指定值的元素</strong></p>
<p><strong>zcount <key><min><max></strong></p>
<p>​		作用：<strong>统计该集合，分数区间内的元素个数</strong></p>
<p><strong>zrank <key><value></strong></p>
<p>​		作用：<strong>返回该值在集合中的排名，从0开始（分数从小到大，要想倒排加一个<mark>rev</mark>）。</strong></p>
<figure data-type="image" tabindex="33"><img src="https://chase-don.github.io//post-images/image-20210504201553537.png" alt="image-20210504201553537" loading="lazy"></figure>
</blockquote>
<p><strong>案例：如何利用zset实现一个文章访问量的排行榜？</strong></p>
<figure data-type="image" tabindex="34"><img src="https://chase-don.github.io//post-images/image-20210504201757848.png" alt="image-20210504201757848" loading="lazy"></figure>
<h4 id="563-数据结构">5.6.3 数据结构</h4>
<p>**SortedSet(zset)**是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p><strong>zset底层使用了两个数据结构：</strong></p>
<p>（1）<strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）<strong>跳跃表</strong>，跳跃表的<mark>目的在于给元素value排序，根据score的范围获取元素列表</mark>。</p>
<h4 id="564-跳跃表跳表时间复杂度为ologn">5.6.4 跳跃表（跳表），时间复杂度为O(logN)</h4>
<p>1、简介</p>
<pre><code>	有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。**==Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。==**
</code></pre>
<p>2、实例</p>
<p>对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1）  有序链表</p>
<figure data-type="image" tabindex="35"><img src="https://chase-don.github.io//post-images/image-20210504204720518.png" alt="image-20210504204720518" loading="lazy"></figure>
<p>​	要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2）  跳跃表</p>
<figure data-type="image" tabindex="36"><img src="https://chase-don.github.io//post-images/image-20210504204729525.png" alt="image-20210504204729525" loading="lazy"></figure>
<p>从第2层开始，1节点比51节点小，向后比较。21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>
<h2 id="6-redis的发布和订阅">6. Redis的发布和订阅</h2>
<h3 id="61-什么是发布和订阅">6.1 什么是发布和订阅</h3>
<ul>
<li>
<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</li>
<li>
<p>Redis <strong>客户端可以订阅任意数量的频道</strong>。</p>
</li>
</ul>
<h3 id="62-redis的发布和订阅">6.2  <strong>Redis</strong>的发布和订阅</h3>
<p>1、客户端可以订阅频道如下图（客户端也收不到未订阅频道发送的消息）</p>
<img src="file://D:/博客源文件/post-images/image-20210504210530217.png" alt="image-20210504210530217" style="zoom:150%;" />
<p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<img src="file://D:/博客源文件/post-images/image-20210504210536308.png" alt="image-20210504210536308" style="zoom:150%;" />
<h3 id="63-发布订阅命令行实现">6.3 发布订阅命令行实现</h3>
<ol>
<li>
<p>打开一个客户端订阅channel1</p>
<p>subscribe channel1</p>
<figure data-type="image" tabindex="37"><img src="https://chase-don.github.io//post-images/image-20210504211232877.png" alt="image-20210504211232877" loading="lazy"></figure>
</li>
<li>
<p>打开另一个客户端，给channel1发布消息hello</p>
<figure data-type="image" tabindex="38"><img src="https://chase-don.github.io//post-images/image-20210504211431397.png" alt="image-20210504211431397" loading="lazy"></figure>
<p><strong><mark>返回的1是订阅者数量</mark></strong></p>
</li>
<li>
<p>打开第一个客户端可以看到发送的消息</p>
<figure data-type="image" tabindex="39"><img src="https://chase-don.github.io//post-images/image-20210504211517258.png" alt="image-20210504211517258" loading="lazy"></figure>
</li>
</ol>
<h3 id="64-原理">6.4 原理</h3>
<figure data-type="image" tabindex="40"><img src="https://chase-don.github.io//post-images/image-20210504214837935.png" alt="image-20210504214837935" loading="lazy"></figure>
<figure data-type="image" tabindex="41"><img src="https://chase-don.github.io//post-images/image-20210504214508100.png" alt="image-20210504214508100" loading="lazy"></figure>
<p><strong>使用场景：</strong></p>
<ol>
<li>实时消息系统</li>
<li>实时聊天（频道当做聊天室， 将信息回显给所有人即可）</li>
<li>订阅/关注系统</li>
</ol>
<h2 id="7-redis新数据类型">7. Redis新数据类型</h2>
<h3 id="71-bitmaps-位图场景详解可以做每日签到">7.1 Bitmaps 位图场景详解（可以做每日签到）</h3>
<h4 id="711-简介">7.1.1 简介</h4>
<p>现代计算机用二进制（位） 作为信息的基础单位，<strong>1个字节等于8位</strong>， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<figure data-type="image" tabindex="42"><img src="https://chase-don.github.io//post-images/image-20210508234244015.png" alt="image-20210508234244015" loading="lazy"></figure>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<p>（1）  Bitmaps**<mark>本身不是一种数据类型， 实际上它就是字符串（key-value）</mark>** ， 但是它<strong>可以对字符串的位进行操作</strong>。</p>
<p>（2）  Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<figure data-type="image" tabindex="43"><img src="https://chase-don.github.io//post-images/image-20210508234326611.png" alt="image-20210508234326611" loading="lazy"></figure>
<h4 id="712-常用命令">7.1.2 常用命令</h4>
<h5 id="1-setbit">1. setbit</h5>
<p>（1）格式</p>
<p><strong>setbit <key> <offset> <value></strong></p>
<p>​		作用：<strong>设置Bitmaps中某个偏移量的值（0或1）</strong>  ，<strong><mark>offset:偏移量从0开始</mark></strong></p>
<p>（2）实例</p>
<p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p>
<p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，<strong>userid=1， 6， 11， 15， 19的用户对网站进行了访问</strong>， 那么当前Bitmaps初始化结果如图</p>
<figure data-type="image" tabindex="44"><img src="https://chase-don.github.io//post-images/image-20210508235241850.png" alt="image-20210508235241850" loading="lazy"></figure>
<figure data-type="image" tabindex="45"><img src="https://chase-don.github.io//post-images/image-20210508235749900.png" alt="image-20210508235749900" loading="lazy"></figure>
<p><strong><mark>注意：</mark></strong></p>
<p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， <strong>通常的做法是每次做setbit操作时将用户id减去这个指定数字</strong>。</p>
<p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<h5 id="2-getbit">2. getbit</h5>
<p>（1）格式</p>
<p><strong>getbit <key> <offset></strong></p>
<p>​		作用：<strong>获取Bitmaps中某个偏移量的值； 获取键的第offset位的值（从0开始算）</strong></p>
<p>（2）实例</p>
<figure data-type="image" tabindex="46"><img src="https://chase-don.github.io//post-images/image-20210509000423533.png" alt="image-20210509000423533" loading="lazy"></figure>
<h5 id="3-bitcount">3. bitcount</h5>
<p>统计==<strong>字符串</strong>==被设置为1的bit数。</p>
<p>一般情况下，给定的整个字符串都会被进行计数；**通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。**start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p><strong><mark>start和end代表起始和结束字节数（注意是字节数！！！！！！！不是偏移量！！！八位一个字节！！！！）</mark></strong></p>
<figure data-type="image" tabindex="47"><img src="https://chase-don.github.io//post-images/image-20210509003219810.png" alt="image-20210509003219810" loading="lazy"></figure>
<h5 id="4-bitop">4. bitop</h5>
<p>(1)格式</p>
<p><strong>bitop and(or/not/xor) <destkey> [key…]</strong></p>
<p>​		作用：<strong>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</strong></p>
<p>(2)实例</p>
<p>2020-11-04 日访问网站的userid=1,2,5,9。</p>
<p>setbit unique:users:20201104 1 1</p>
<p>setbit unique:users:20201104 2 1</p>
<p>setbit unique:users:20201104 5 1</p>
<p>setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9。</p>
<p>setbit unique:users:20201103 0 1</p>
<p>setbit unique:users:20201103 1 1</p>
<p>setbit unique:users:20201103 4 1</p>
<p>setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量</p>
<pre><code class="language-bsah">bitop and unique:users:and:20201104_03 unique:users:20201103 unique:users:20201104
</code></pre>
<img src="file://D:/博客源文件/post-images/image-20210509003938585.png" alt="image-20210509003938585" style="zoom:150%;" />
<img src="file://D:/博客源文件/post-images/image-20210509003945828.png" alt="image-20210509003945828" style="zoom:150%;" />
<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<img src="file://D:/博客源文件/post-images/image-20210509004017666.png" alt="image-20210509004017666" style="zoom:150%;" />
<h3 id="72-geospatial-地理位置详解">7.2 Geospatial 地理位置详解</h3>
<h4 id="721-简介">7.2.1 简介</h4>
<p>​	Redis 3.2 中增加了对GEO类型的支持。<strong>GEO，Geographic，地理信息的缩写</strong>。该类型，就是**<mark>元素的2维坐标，在地图上就是经纬度</mark><strong>。redis基于该类型，提供了</strong>经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作**。</p>
<h4 id="722-常用命令6个">7.2.2 常用命令（6个）</h4>
<blockquote>
<p><strong>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member...]</strong></p>
<p>​		作用：<strong>添加地理位置（经度，纬度，名称）</strong>，已经添加的数据，是无法再次往里面添加的。</p>
<figure data-type="image" tabindex="48"><img src="https://chase-don.github.io//post-images/image-20210508212906638.png" alt="image-20210508212906638" loading="lazy"></figure>
<p><strong>geopos <key><member> [member...]</strong></p>
<p>​		作用：<strong>获得指定地区的坐标值</strong></p>
<figure data-type="image" tabindex="49"><img src="https://chase-don.github.io//post-images/image-20210508213737013.png" alt="image-20210508213737013" loading="lazy"></figure>
<p>**geodist<key><member1><member2> [m|km|ft|mi ] **</p>
<p>​		作用：<strong>获取两个位置之间的直线距离</strong></p>
<p>​		<strong>单位：</strong></p>
<p>​		<strong>m 表示单位为米==[默认值]==。</strong></p>
<p>​		<strong>km 表示单位为千米。</strong></p>
<p>​		<strong>mi 表示单位为英里。</strong></p>
<p>​		<strong>ft 表示单位为英尺。</strong></p>
<p>​		<strong>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</strong></p>
<figure data-type="image" tabindex="50"><img src="https://chase-don.github.io//post-images/image-20210508215454565.png" alt="image-20210508215454565" loading="lazy"></figure>
<p>**georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  **  （经度  纬度  半径  单位）</p>
<p>​		作用：<strong><mark>以给定的经纬度为中心，找出某一半径内的元素</mark></strong></p>
<figure data-type="image" tabindex="51"><img src="https://chase-don.github.io//post-images/image-20210508215903656.png" alt="image-20210508215903656" loading="lazy"></figure>
<figure data-type="image" tabindex="52"><img src="https://chase-don.github.io//post-images/image-20210508220838698.png" alt="image-20210508220838698" loading="lazy"></figure>
<p>**georadiusbymember <key> &lt; member&gt; radius m|km|ft|mi  **</p>
<p>​		作用：<strong><mark>以给定的成员（元素）为中心，找出某一半径内的元素</mark></strong></p>
<figure data-type="image" tabindex="53"><img src="https://chase-don.github.io//post-images/image-20210508221019884.png" alt="image-20210508221019884" loading="lazy"></figure>
<p><strong>geohash <key> &lt; member&gt;</strong></p>
<p>​		作用：<strong>返回一个或多个元素的Geohash表示</strong>   <strong><mark>（不常用）</mark></strong></p>
</blockquote>
<h3 id="73-hyperloglog-基数统计适用于查看访问量">7.3 <strong>HyperLogLog</strong> 基数统计(适用于查看访问量)</h3>
<blockquote>
<h4 id="什么是基数"><strong>什么是基数?</strong></h4>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
</blockquote>
<h4 id="731-简介">7.3.1 简介</h4>
<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像<strong>UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数</strong>等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>Redis推出了HyperLogLog用来做基数统计的算法，<strong>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</strong></p>
<p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而**<mark>不会储存输入元素本身</mark>**，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4 id="732-常用命令">7.3.2 常用命令</h4>
<blockquote>
<p>**pfadd <key>&lt; element&gt; [element ...]  **</p>
<p>​		作用：<strong>添加指定元素到 HyperLogLog 中</strong></p>
<p>**pfcount<key> [key ...] **</p>
<p>​		作用：<strong>计算key的近似基数，可以计算多个key，比如用key存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</strong></p>
<p>**pfmerge<destkey><sourcekey> [sourcekey ...] **</p>
<p>​		作用：<strong>将一个或多个key合并后的结果存储在另一个key中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</strong></p>
<figure data-type="image" tabindex="54"><img src="https://chase-don.github.io//post-images/image-20210509010754469.png" alt="image-20210509010754469" loading="lazy"></figure>
</blockquote>
<h2 id="8-jedis">8. Jedis</h2>
<h3 id="81-jedis测试">8.1 Jedis测试</h3>
<ol>
<li>
<p>创建测试程序</p>
<pre><code class="language-java">public class JedisDemo1 {
    public static void main(String[] args) {

        //创建Jedis对象
        Jedis jedis = new Jedis(&quot;121.40.180.27&quot;, 6379);

        //测试
        String value = jedis.ping();
        System.out.println(value);

    }
}
</code></pre>
</li>
<li>
<p>测试相关数据类型（5大数据类型）（略）</p>
</li>
</ol>
<h3 id="82-jedis实例完成一个手机验证码功能">8.2 Jedis实例（<strong>完成一个手机验证码功能</strong>）</h3>
<p>要求：</p>
<p>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效</p>
<p>2、输入验证码，点击验证，返回成功或失败</p>
<p>3、每个手机号每天只能输入3次</p>
<figure data-type="image" tabindex="55"><img src="https://chase-don.github.io//post-images/image-20210509161238058.png" alt="image-20210509161238058" loading="lazy"></figure>
<pre><code class="language-java">public class phoneCode {
    public static void main(String[] args) {
        //模拟验证码的发送
        verifyCode(&quot;18252027696&quot;);
//        getRedisCode(&quot;18252027696&quot; ,&quot;045104&quot;);
    }


    //1. 生成6位数字验证码
    public static String getCode() {
        Random random = new Random();
        String code = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) {
            int rand = random.nextInt(10);
            code += rand;
        }
        return code;
    }

    //2. 每个手机每天只能发送三次，验证码放到redis中codeKey
    public static void verifyCode(String phone) {
        //连接redis
        Jedis jedis = new Jedis(&quot;121.40.180.27&quot;, 6379);

        //拼接key
        //手机发送次数key
        String countKey = &quot;VerifyCode&quot; + phone + &quot;:count&quot;;
        //验证码key
        String codeKey = &quot;VerifyCode&quot; + phone + &quot;:code&quot;;

        //每个手机每天只能发送三次
        String count = jedis.get(countKey);
        if (count == null) {
            //没有发送次数，第一次发送
            //设置发送次数为1
            jedis.setex(countKey, 24 * 60 * 60, &quot;1&quot;);
        } else if (Integer.parseInt(count) &lt;= 2) {
            //发送次数+1
            jedis.incr(countKey);
        } else if (Integer.parseInt(count) &gt; 2) {
            //发送三次及以上，不能再进行发送了
            System.out.println(&quot;今天发送次数已经超过三次，不能再发送了&quot;);
            jedis.close();
        }

        //发送的验证码放到redis里面
        String vcode = getCode();
        jedis.setex(codeKey, 120, vcode);
        jedis.close();
    }


    //3. 验证码校验
    public static void getRedisCode(String phone, String code) {
        //从redis获取验证码
        Jedis jedis = new Jedis(&quot;121.40.180.27&quot;, 6379);
        //验证key
        String codeKey = &quot;VerifyCode&quot; + phone + &quot;:code&quot;;
        String redisCode = jedis.get(codeKey);
        //判断
        if (redisCode.equals(code)) {
            System.out.println(&quot;成功&quot;);
        } else {
            System.out.println(&quot;失败&quot;);
        }
        jedis.close();
    }
}
</code></pre>
<h2 id="9-redis事务和锁机制">9. Redis事务和锁机制</h2>
<h3 id="91-redis的事务定义">9.1 redis的事务定义</h3>
<p>Redis事务是**<mark>一个单独的隔离操作</mark>**：<strong>事务中的所有命令都会序列化、按顺序地执行</strong>。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的<strong>主要作用</strong>就是**<mark>串联多个命令防止别的命令插队</mark>**。</p>
<h3 id="92-multi-exec-discard">9.2 <strong>Multi</strong>、Exec、discard</h3>
<p>从<strong>输入Multi命令</strong>开始，输入的命令都会<strong>依次进入命令队列中</strong>，但不会执行；</p>
<p>直到<strong>输入Exec后</strong>，Redis会<strong>将之前的命令队列中的命令依次执行</strong>；</p>
<p><strong><mark>组队的过程中</mark><strong>可以</strong>通过discard来放弃组队</strong>。</p>
<figure data-type="image" tabindex="56"><img src="https://chase-don.github.io//post-images/image-20210509191159066.png" alt="image-20210509191159066" loading="lazy"></figure>
<figure data-type="image" tabindex="57"><img src="https://chase-don.github.io//post-images/image-20210509191843477.png" alt="image-20210509191843477" loading="lazy"></figure>
<figure data-type="image" tabindex="58"><img src="https://chase-don.github.io//post-images/image-20210509192048587.png" alt="image-20210509192048587" loading="lazy"></figure>
<h3 id="93-事务的错误处理两种情况">9.3 事务的错误处理（两种情况）</h3>
<h4 id="931-组队中某个命令出现了报告错误">9.3.1 组队中某个命令出现了报告错误</h4>
<figure data-type="image" tabindex="59"><img src="https://chase-don.github.io//post-images/image-20210509192359890.png" alt="image-20210509192359890" loading="lazy"></figure>
<p><strong><mark>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</mark></strong></p>
<figure data-type="image" tabindex="60"><img src="https://chase-don.github.io//post-images/image-20210509192811780.png" alt="image-20210509192811780" loading="lazy"></figure>
<h4 id="932-执行阶段某个命令报出了错误">9.3.2 执行阶段某个命令报出了错误</h4>
<figure data-type="image" tabindex="61"><img src="https://chase-don.github.io//post-images/image-20210509192435465.png" alt="image-20210509192435465" loading="lazy"></figure>
<p><strong><mark>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</mark></strong></p>
<figure data-type="image" tabindex="62"><img src="https://chase-don.github.io//post-images/image-20210509193440670.png" alt="image-20210509193440670" loading="lazy"></figure>
<h3 id="94-事务的冲突问题">9.4 事务的冲突问题</h3>
<h4 id="941-悲观锁">9.4.1 悲观锁</h4>
<img src="file://D:/博客源文件/post-images/image-20210509205136994.png" alt="image-20210509205136994" style="zoom:150%;" />
<p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<h4 id="942-乐观锁">9.4.2 乐观锁</h4>
 <img src="file://D:/博客源文件/post-images/image-20210509205308731.png" alt="image-20210509205308731" style="zoom:150%;" />
<p><strong>乐观锁(Optimistic Lock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<h4 id="943-乐观锁的使用watch-key">9.4.3 乐观锁的使用（watch <key>）</h4>
<blockquote>
<h4 id="在执行multi之前先执行watch-key1-key2可以监视一个或多个-key-如果在事务执行之前这个或这些-key-被其他命令所改动那么事务将被打断">在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果<mark>在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</mark>。</h4>
</blockquote>
<p>客户端1：</p>
<figure data-type="image" tabindex="63"><img src="https://chase-don.github.io//post-images/image-20210509221604378.png" alt="image-20210509221604378" loading="lazy"></figure>
<p>客户端2：</p>
<figure data-type="image" tabindex="64"><img src="https://chase-don.github.io//post-images/image-20210509222008089.png" alt="image-20210509222008089" loading="lazy"></figure>
<h3 id="95-redis事务的三大特性">9.5 <mark>redis事务的三大特性</mark></h3>
<ul>
<li>
<p><strong>单独的隔离操作</strong></p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li>
<p><strong>没有隔离级别的概念</strong></p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
</li>
<li>
<p><strong>不保证原子性</strong></p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
</li>
</ul>
<h2 id="10-redis事务案例-秒杀">10. Redis事务案例---秒杀</h2>
<img src="file://D:/博客源文件/post-images/image-20210509222449181.png" alt="image-20210509222449181" style="zoom:150%;" />
<p>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</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://chase-don.github.io/tag/d1Ec0O0Rz7/" class="tag">
                    学习笔记
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://chase-don.github.io/post/nginx-ru-men-xue-xi/">
                  <h3 class="post-title">
                    Nginx入门学习
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
