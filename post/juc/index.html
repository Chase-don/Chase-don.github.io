<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>JUC | Loro</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://chase-don.github.io//favicon.ico?v=1620666848926">
<link rel="stylesheet" href="https://chase-don.github.io//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="
1. 基本知识
1.1 线程的状态

1.2 关于死锁

1.3 Lock（锁）

2. 进程和线程

线程、进程是重点！！

2.1 进程：程序的一个执行过程
一个进程包含多个线程，至少包含一个！Java默认有两个线程：main，gc
..." />
    <meta name="keywords" content="JUC,学习笔记" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://chase-don.github.io/">
        <img src="https://chase-don.github.io//images/avatar.png?v=1620666848926" class="site-logo">
        <h1 class="site-title">Loro</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Chase-don" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      表现不俗
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://chase-don.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">JUC</h2>
            <div class="post-date">2021-03-01</div>
            
            <div class="post-content" v-pre>
              <!-- more -->
<h2 id="1-基本知识">1. 基本知识</h2>
<h3 id="11-线程的状态">1.1 线程的状态</h3>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210323173019251.png" alt="image-20210323173019251" loading="lazy"></figure>
<h3 id="12-关于死锁">1.2 关于死锁</h3>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210324222406709.png" alt="image-20210324222406709" loading="lazy"></figure>
<h3 id="13-lock锁">1.3 Lock（锁）</h3>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210324222826766.png" alt="image-20210324222826766" loading="lazy"></figure>
<h2 id="2-进程和线程">2. 进程和线程</h2>
<blockquote>
<p>线程、进程是重点！！</p>
</blockquote>
<h3 id="21-进程程序的一个执行过程">2.1 进程：程序的一个执行过程</h3>
<p>一个进程包含多个线程，至少包含一个！Java默认有两个线程：main，gc</p>
<h3 id="22-线程">2.2 线程</h3>
<p>开了一个线程Typora，写字，自动保存（线程负责的）</p>
<p>对于Java而言，创建线程的方法：Thread，Runnable，Callable</p>
<p><strong>Java真的可以开启线程吗？</strong>  ---&gt;  开不了：原因是start0调用的是本地方法，底层的Cpp，Java无法直接操作硬件</p>
<h3 id="23-并发和并行">2.3 并发和并行</h3>
<p>并发（多线程操作同一资源）</p>
<ul>
<li>CPU一核，模拟出来多条线程，快速交替</li>
</ul>
<p>并行（多个人一起走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行</li>
</ul>
<pre><code class="language-java">public class Test{
    public static void main(String[] args){
        //获取CPU核数
        //CPU密集型 ， IO密集型
        System.out.println(Runtime.getRuntime().availableProcessors());
    }
}
</code></pre>
<p>并发编程本质：<strong>充分利用CPU资源</strong></p>
<h3 id="24-线程的状态6种">2.4 线程的状态：（6种）</h3>
<ul>
<li>新生（NEW）</li>
<li>运行(RUNNABLE)</li>
<li>阻塞(BLOCKED)</li>
<li>等待(WAITING)</li>
<li>超时等待(TIMED_WAITING)</li>
<li>死亡(TERMINATED)</li>
</ul>
<h3 id="25-wait和sleep的区别常考">2.5 wait和sleep的区别（常考！！！！）</h3>
<ol>
<li><strong>来自不同的类：</strong>
<ul>
<li>wait来自Object类</li>
<li>sleep来自Thread类</li>
</ul>
</li>
<li><strong>关于锁的释放：</strong>
<ul>
<li>wait会释放锁</li>
<li>sleep不会释放锁（sleep抱着锁睡觉）</li>
</ul>
</li>
<li><strong>使用的范围是不同的：</strong>
<ul>
<li>wait：必须在同步代码块中</li>
<li>sleep：可以在任何地方使用(任何地方睡)</li>
</ul>
</li>
<li>是否需要捕获异常
<ul>
<li>wait不需要捕获异常</li>
<li>sleep必须要捕获异常</li>
</ul>
</li>
</ol>
<h2 id="3lock很重点">3.Lock（很重点）</h2>
<h3 id="31-synchronized">3.1 Synchronized</h3>
<pre><code class="language-java">//基本的卖票例子

/**
 * 真正的多线程开发，即公司的开发中： 降低耦合性
 * 线程就是 一个单独的资源类，没有任何附属的操作！
 * 1. 属性、方法
 */
public class SaleTicketDemo01 {
    public static void main(String[] args) {
        //并发：多个线程操作同一个资源类
        Ticket ticket = new Ticket();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 60; i++) {
                ticket.sale();
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 60; i++) {
                ticket.sale();
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 60; i++) {
                ticket.sale();
            }
        }, &quot;C&quot;).start();
    }
}


//资源类 OOP
class Ticket {
    //属性、方法
    private int number = 50;

    //卖票的方式
    //synchronized 本质：锁，排队
    public synchronized void sale() {
        if (number &gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot;卖出了&quot; + (number--) + &quot;票，剩余：&quot; + number);
        }
    }
}
</code></pre>
<h3 id="32-lock接口">3.2 Lock接口</h3>
<blockquote>
<p>Lock lock = new ...();</p>
<p><strong>lock.lock();   加锁</strong></p>
<p>try{}</p>
<p>finally{<strong>lock.unock();</strong>}  解锁</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210330020220846.png" alt="image-20210330020220846" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210330021027380.png" alt="image-20210330021027380" loading="lazy"></figure>
<p>公平锁：十分公平 ---&gt; 先来后到</p>
<p><strong>非公平锁：十分不公平 ---&gt; 可以插队（默认）</strong></p>
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SaleTicketDemo02 {
    public static void main(String[] args) {
        //并发：多个线程操作同一个资源类
        Ticket2 ticket = new Ticket2();

        new Thread(() -&gt; {for (int i = 0; i &lt; 60; i++) ticket.sale();}, &quot;A&quot;).start();
        new Thread(() -&gt; {for (int i = 0; i &lt; 60; i++) ticket.sale();}, &quot;B&quot;).start();
        new Thread(() -&gt; {for (int i = 0; i &lt; 60; i++) ticket.sale();}, &quot;C&quot;).start();

    }    
}

/**
 * Lock三部曲：
 * 1. new ReentrantLock();
 * 2. lock.lock(); // 加锁
 * 3. finally =&gt; lock.unlock(); //解锁
 */
//用Lock锁
class Ticket2 {
    //属性、方法
    private int number = 50;

    Lock lock = new ReentrantLock();

    //卖票的方式
    public void sale() {

        lock.lock();//加锁
        try {
            //业务代码
            if (number &gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot;卖出了&quot; + (number--) + &quot;票，剩余：&quot; + number);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h3 id="33-synchronized和lock的区别重点">3.3 Synchronized和Lock的区别(重点)</h3>
<ol>
<li>
<p>Synchronized是内置的java关键字，lock是一个java类（JUC）</p>
</li>
<li>
<p>Synchronized --&gt; 无法判断获取锁的状态</p>
<p>lock --&gt; 可以判断是否获取到了锁</p>
</li>
<li>
<p>Synchronized 会自动释放锁（a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁）</p>
<p>lock 必须要手动释放锁，<strong>如果不释放锁，会产生死锁！</strong></p>
</li>
<li>
<p>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，（<strong>lock.trylock()</strong>）如果尝试获取不到锁，线程可以不用一直等待就结束了</p>
</li>
<li>
<p>Synchronized：可重入锁，不可中断的，非公平的；</p>
<p>lock：可重入锁，可以判断锁，非公平（可以自己设置，默认非公平锁）</p>
</li>
<li>
<p>Synchronized：适合锁少量的代码同步问题</p>
<p>lock：适合锁大量的同步代码！</p>
</li>
</ol>
<h2 id="4-生产者和消费者问题">4. 生产者和消费者问题</h2>
<h3 id="41-sychronized版本">4.1 Sychronized版本</h3>
<pre><code class="language-java">/**
 * 线程之间的通信问题：生产者和消费者问题！   wait、notify
 *
 * 线程交替进行  A B  操作同一个变量  num = 0
 * A ---&gt; num+1
 * B ---&gt; num-1
 */
public class Test {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();
    }
}

// 判断等待 --&gt; 业务 --&gt; 通知
class Data {  //数字 资源类
    private int num = 0;

    // +1
    public synchronized void increment() throws InterruptedException {
        if (num != 0) {
            //等待
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我+1完毕了
        this.notifyAll();
    }

    // -1
    public synchronized void decrement() throws InterruptedException {
        if (num == 0) {
            //等待
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我-1完毕了
        this.notifyAll();
    }
}
</code></pre>
<blockquote>
<p>问题存在：例子是A,B两个线程，当存在四个或者八个线程的话，是否还安全？  -----&gt;   <strong>答案：不安全！！！</strong></p>
<p>解决办法：  <mark><strong>if改为while</strong></mark></p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/image-20210330034712720.png" alt="image-20210330034712720" loading="lazy"></figure>
<pre><code class="language-java">//防止虚假唤醒的代码
public class Test {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;C&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;D&quot;).start();
    }
}

// 判断等待 --&gt; 业务 --&gt; 通知
class Data {  //数字 资源类
    private int num = 0;

    // +1
    public synchronized void increment() throws InterruptedException {
        while (num != 0) {
            //等待
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我+1完毕了
        this.notifyAll();
    }

    // -1
    public synchronized void decrement() throws InterruptedException {
        while (num == 0) {
            //等待
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我-1完毕了
        this.notifyAll();
    }
}
</code></pre>
<h3 id="42-juc版本的生产者与消费问题lock">4.2 JUC版本的生产者与消费问题（Lock）</h3>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210330144331403.png" alt="image-20210330144331403" loading="lazy"></figure>
<p><mark><strong>通过Lock找到Condition，Condition可以理解成一个同步监视器</strong></mark></p>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210330144231750.png" alt="image-20210330144231750" loading="lazy"></figure>
<p>代码实现：(LOCK)</p>
<pre><code class="language-java">public class TestLock {
    public static void main(String[] args) {
        Data2 data = new Data2();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;C&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;D&quot;).start();

    }
}

// 判断等待 --&gt; 业务 --&gt; 通知
class Data2 {  //数字 资源类
    private int num = 0;

    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    // +1
    public void increment() throws InterruptedException {
        lock.lock();
        try {
            while (num != 0) {
                //等待
                condition.await(); //等待
            }
            num++;
            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
            //通知其他线程，我+1完毕了
            condition.signalAll(); //唤醒全部
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    // -1
    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            while (num == 0) {
                //等待
                condition.await();
            }
            num--;
            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
            //通知其他线程，我-1完毕了
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h4 id="421condition可以精准的通知和唤醒线程相比于wait和notify的优势">4.2.1<strong>Condition可以精准的通知和唤醒线程！</strong>（相比于wait和notify的优势）</h4>
<p>代码如下：</p>
<pre><code class="language-java">public class TestCondition {

    public static void main(String[] args) {

        Data3 data = new Data3();

        new Thread(() -&gt;{
            for (int i = 0; i &lt; 10; i++) {
                data.printA();
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt;{
            for (int i = 0; i &lt; 10; i++) {
                data.printB();
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt;{
            for (int i = 0; i &lt; 10; i++) {
                data.printC();
            }
        }, &quot;C&quot;).start();

    }
}

class Data3 { //资源类
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int num = 1; // 1A 2B 3C

    public void printA() {
        lock.lock();

        try {
            //业务，  判断 =&gt; 执行 =&gt; 通知
            while (num != 1) {
                //等待
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; AAAAA&quot;);
            //唤醒 --&gt; 唤醒指定的人(B)
            num = 2;
            condition2.signal();  //精准唤醒！
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB() {
        lock.lock();

        try {
            //业务，  判断 =&gt; 执行 =&gt; 通知
            while (num != 2) {
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; BBBBB&quot;);
            //唤醒
            num = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printC() {
        lock.lock();

        try {
            //业务，  判断 =&gt; 执行 =&gt; 通知
            while (num != 3) {
                //等待
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; CCCCC&quot;);
            //唤醒
            num = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h2 id="5-8锁现象就是关于锁的八个问题">5. 8锁现象(就是关于锁的八个问题)</h2>
<p>如何判断锁的是谁！永远的知道什么锁，以及锁到底锁的是谁</p>
<pre><code class="language-java">/**
 * 8锁，就是关于锁的8个问题
 * 1. 标准情况下，两个线程先打印 发短信还是打电话？   ---&gt; 发短信 再 打电话
 * 2. sendSms延迟四秒，两个线程先打印 发短信还是打电话？   ---&gt; 发短信 再 打电话
 */
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(()-&gt;{
            phone.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone.call();
        }, &quot;B&quot;).start();

    }
}


class Phone {
    // synchronized 锁的对象是方法的调用者！
    // 两个方法用的是同一个锁，谁先拿到谁执行！
    public synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 3. 增加了一个普通方法后，两个线程，是先发短信还是先hello   ----&gt;    先hello（普通方法） 再 发短信
 * 4. 增加一个对象，两个对象，两个同步方法， 发短信还是打电话？   ---&gt;   打电话  再  发短信
 */
public class Test2 {
    public static void main(String[] args) {
        //两个对象 ，即两个调用者，两把锁
        Phone2 phone1 = new Phone2();
        Phone2 phone2 = new Phone2();

        new Thread(()-&gt;{
            phone1.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone2.call();
        }, &quot;B&quot;).start();

    }
}


class Phone2 {
    // synchronized 锁的对象是方法的调用者！
    // 两个方法用的是同一个锁，谁先拿到谁执行！
    public synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }

    //这里没有锁，不是同步方法，不受锁的影响
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 5.增加两个静态的同步方法，只有一个对象，先打印哪个？
 * 6. 两个对象的话呢？ 增加两个静态的同步方法，只有一个对象，先打印哪个？
 */
public class Test3 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个，static：锁的是class
        Phone3 phone1 = new Phone3();
        Phone3 phone2 = new Phone3();

        new Thread(()-&gt;{
            phone1.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone2.call();
        }, &quot;B&quot;).start();

    }
}


//phone3 唯一一个 Class 对象！！
class Phone3 {
    // synchronized 锁的对象是方法的调用者！
    // static  静态方法
    // 类一加载就有了！ 锁的是 Class
    public static synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    public static synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 7. 一个静态的同步方法，一个普通的同步方法，一个对象。那么，先打印发短信还是打电话  （先打电话再发短信）
 * 8. 一个静态的同步方法，一个普通的同步方法，两个对象。同样的还是先电话后短信（一个是对象锁一个是类锁）
 */
public class Test4 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个，static：锁的是class
        Phone4 phone = new Phone4();


        new Thread(()-&gt;{
            phone.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone.call();
        }, &quot;B&quot;).start();

    }
}



class Phone4 {
    // 静态的同步方法 这里锁的是 Class类
    public static synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    //普通的同步方法  这里锁的是 对象，方法的调用者
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<blockquote>
<p>小结：</p>
<p>new ：this  具体一个对象，一个手机</p>
<p><strong>static：Class唯一一个模板</strong></p>
</blockquote>
<h2 id="6-集合类不安全">6. 集合类不安全</h2>
<h3 id="61-list不安全">6.1 List不安全</h3>
<blockquote>
<p>CopyOnWrite 写入时复制！   是属于COW：计算机程序设计领域的一种优化策略<br>
多个线程调用的时候，即list，读取的时候是固定的，但写入容易造成覆盖操作<br>
在写入的时候避免覆盖，造成数据问题<br>
读写分离<br>
<mark><strong>CopyOnWriteArrayList 比 Vector 好在哪？ 一个是lock锁一个是synchronized锁</strong></mark></p>
</blockquote>
<pre><code class="language-java">解决方案：
	1. List&lt;String&gt; list = new Vector&lt;&gt;();
	2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
	3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<pre><code class="language-java">//java.util.ConcurrentModificationException 并发修改异常
public class ListTest {
    public static void main(String[] args) {
        //并发下 ArrayList不安全！
        /**
         * 解决方案：
         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();
         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
         */
        // CopyOnWrite 写入时复制！   是属于COW：计算机程序设计领域的一种优化策略
        // 多个线程调用的时候，即list，读取的时候是固定的，但写入容易造成覆盖操作
        // 在写入的时候避免覆盖，造成数据问题
        // 读写分离
        // CopyOnWriteArray
        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();

        for (int i = 1; i &lt;= 10; i++) {
            new Thread(() -&gt; {
                list.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(Thread.currentThread().getName() + list);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<h3 id="62-set不安全">6.2 Set不安全</h3>
<pre><code class="language-java">package cn.edu.bupt.unsafeList;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * 同理可证：java.util.ConcurrentModificationException
 * 解决方法：
 * 1. Vector()
 * 2. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
 * 3. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();
 */
public class SetTest {
    public static void main(String[] args) {
//        Set&lt;String&gt; set = new HashSet&lt;&gt;();
//        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();

        for (int i = 1; i &lt;= 50; i++) {
            new Thread(() -&gt; {
                set.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(Thread.currentThread().getName() + set);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<blockquote>
<p>hashset底层是什么？</p>
<pre><code class="language-java">public HashSet() {
	map = new HashMap&lt;&gt;();
}

//add set本质就是map  key是不可重复的所以set的值就是key传入
public boolean add(E e) {
	return map.put(e, PRESENT)==null;
}
</code></pre>
</blockquote>
<h3 id="63-hashmap不安全">6.3 HashMap不安全</h3>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210331145154571.png" alt="image-20210331145154571" loading="lazy"></figure>
<pre><code class="language-java">public class MapTest {
    public static void main(String[] args) {
        //研究ConcurrentHashMap的原理
        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
        //  加载因子（0.75）  初始化容量（16）

        for (int i = 1; i &lt;= 30; i++) {
            new Thread(() -&gt; {
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<blockquote>
<p>研究ConcurrenrtHashMap的原理！（源码）</p>
</blockquote>
<h2 id="7-callable简单">7. Callable（简单）</h2>
<ol>
<li>可以有返回值</li>
<li>可以抛出异常</li>
<li>方法不同，用的是call()方法</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://chase-don.github.io//post-images/image-20210331151347117.png" alt="image-20210331151347117" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://chase-don.github.io//post-images/image-20210331152237333.png" alt="image-20210331152237333" loading="lazy"></figure>
<pre><code class="language-java">public class CallableTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //new Thread(new Runnable()).start();
        //new Thread(new FutureTask()).start();
        //new Thread(new FutureTask( Callable )).start();
        new Thread().start(); //怎么启动Callable

        MyThread myThread = new MyThread();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread);  //适配器

        new Thread(futureTask, &quot;A&quot;).start();
        new Thread(futureTask, &quot;B&quot;).start();  // 两个线程执行，结果还是一个call()。---&gt; 原因是结果会被缓存，效率高

        Integer integer = futureTask.get(); //这个get方法可能产生阻塞，把它放到最后面
        System.out.println(integer);
    }
}


class MyThread implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        System.out.println(&quot;call()&quot;);
        //return是一个耗时的操作！
        return 1024;
    }
}
</code></pre>
<blockquote>
<p>细节：</p>
<ol>
<li>有缓存</li>
<li>结果可能需要等待，会阻塞！</li>
</ol>
</blockquote>
<h2 id="8-常用的辅助类必会">8. 常用的辅助类（必会）</h2>
<h3 id="81-countdownlatch">8.1 CountDownLatch</h3>
<figure data-type="image" tabindex="12"><img src="https://chase-don.github.io//post-images/image-20210331154522891.png" alt="image-20210331154522891" loading="lazy"></figure>
<pre><code class="language-java">// 计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        //总数是6，必须要执行任务的时候，再使用！
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i &lt;= 6; i++) {
            new Thread(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot; go out&quot;);
                countDownLatch.countDown(); //-1
            }, String.valueOf(i)).start();
        }

        //等待计数器归零，然后再向下执行
        countDownLatch.await();

        System.out.println(&quot;close door&quot;);
    }
}
</code></pre>
<blockquote>
<p>原理</p>
<p><mark><strong>countDownLatch.countDown();</strong></mark>    //数量-1</p>
<p><mark><strong>countDownLatch.await();</strong></mark>   //等待计数器归零，然后再向下执行</p>
<p>每次有线程调用countDown则数量减一，假设计数器变为0，countDownLatch.await()就会被唤醒，继续执行！</p>
</blockquote>
<h3 id="82-cyclicbarrier可以理解为加法计数器等待await指定个数线程执行完毕再执行操作">8.2 CyclicBarrier（可以理解为加法计数器，等待(await)指定个数线程执行完毕再执行操作）</h3>
<figure data-type="image" tabindex="13"><img src="https://chase-don.github.io//post-images/image-20210331162217137.png" alt="image-20210331162217137" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 集齐七颗龙珠召唤神龙
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {

        //召唤龙珠的线程
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; {
            System.out.println(&quot;召唤神龙成功&quot;);
        });

        for (int i = 1; i &lt;= 7; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot;收集&quot; + temp + &quot;个龙珠&quot;);
                try {
                    cyclicBarrier.await(); //等待（通过等待计数）
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
</code></pre>
<h3 id="83-semaphore同一时间只能有指定数量个得到线程">8.3 Semaphore（同一时间只能有指定数量个得到线程）</h3>
<p>Semaphore：信号量</p>
<figure data-type="image" tabindex="14"><img src="https://chase-don.github.io//post-images/image-20210331170128059.png" alt="image-20210331170128059" loading="lazy"></figure>
<pre><code class="language-java">public class SemaphoreDemo {
    public static void main(String[] args) {
        //参数是可用资源数量（允许运行的线程数量）  限流的时候使用
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i &lt;= 6; i++) {
            new Thread(() -&gt; {
                // acquire() 得到
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();  // release() 释放
                }
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<p>原理：</p>
<ol>
<li><strong>semaphore.acquire();</strong>   获得，假设如果已经满了，等待，等待被释放为止。（<strong>acquire(获取)当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等待下去，直到有线程释放信号量，或超时。</strong>）</li>
<li><strong>semaphore.release();</strong>    释放，会将当前的信号量释放，然后唤醒等待的资源（<strong>release(释放)实际上会将信号量的值加1，然后唤醒等待的线程</strong>）</li>
</ol>
<p><mark><strong>作用： 多个共享资源互斥使用；并发限流，控制最大线程数！</strong></mark></p>
<p>如果把资源数从3变成1了，此时就等价于synchronized。</p>
<h2 id="9-读写锁readwritelock">9. 读写锁（ReadWriteLock）</h2>
<figure data-type="image" tabindex="15"><img src="https://chase-don.github.io//post-images/image-20210331175409717.png" alt="image-20210331175409717" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 独占锁（写锁）  一次只能被一个线程占有
 * 共享锁（读锁）  多个线程可以同时占有
 * ReadWriteLock
 * 读 - 读    可以共存
 * 读 - 写    不可共存
 * 写 - 写    不可共存
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
//        MyCache myCache = new MyCache();

        MyCacheLock myCache = new MyCacheLock();
        //写入
        for (int i = 1; i &lt;= 5; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                myCache.put(temp + &quot;&quot;, temp + &quot;&quot;);
            }, String.valueOf(i)).start();
        }

        //读取
        for (int i = 1; i &lt;= 5; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                myCache.get(temp + &quot;&quot;);
            }, String.valueOf(i)).start();
        }
    }

}


//自定义缓存
class MyCache{
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    //存，写入
    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;);
    }

    //取，读
    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName() + &quot;读取ok&quot;);
    }
}


//加锁缓存
class MyCacheLock{
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    //读写锁：更加细粒度的控制
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //存，写入的时候只希望同时只有一个线程写
    public void put(String key, Object value) {
        readWriteLock.writeLock().lock();

        try {
            System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    //取，读，所有人都可以读
    public void get(String key) {
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);
            Object o = map.get(key);
            System.out.println(Thread.currentThread().getName() + &quot;读取ok&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }
}
</code></pre>
<p><strong>注意：</strong></p>
<ol>
<li><mark><strong>独占锁（写锁）  一次只能被一个线程占有</strong></mark></li>
<li><mark><strong>共享锁（读锁）  多个线程可以同时占有</strong></mark></li>
<li>读 - 读    可以共存<br>
读 - 写    不可共存<br>
写 - 写    不可共存</li>
</ol>
<h2 id="10-阻塞队列">10. 阻塞队列</h2>
<figure data-type="image" tabindex="16"><img src="https://chase-don.github.io//post-images/image-20210331201713368.png" alt="image-20210331201713368" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://chase-don.github.io//post-images/image-20210331202007280.png" alt="image-20210331202007280" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://chase-don.github.io//post-images/image-20210331210803109.png" alt="image-20210331210803109" loading="lazy"></figure>
<p><strong>什么情况下我们会使用阻塞队列：多线程并发处理，线程池。</strong></p>
<h3 id="101-学会使用阻塞队列四组api">10.1 学会使用阻塞队列（四组API）</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不抛出异常，有返回值</th>
<th>阻塞 等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加</td>
<td>add()</td>
<td>offer()</td>
<td>put()</td>
<td>offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>查看队首</td>
<td>element()</td>
<td>peek()</td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">    /**
     * 抛出异常
     */
    public static void test1() {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(arrayBlockingQueue.add(&quot;a&quot;));
        System.out.println(arrayBlockingQueue.add(&quot;b&quot;));
        System.out.println(arrayBlockingQueue.add(&quot;c&quot;));
        //java.lang.IllegalStateException: Queue full
        //System.out.println(arrayBlockingQueue.add(&quot;d&quot;));

        System.out.println(&quot;===========&quot;);

        System.out.println(arrayBlockingQueue.remove());
        System.out.println(arrayBlockingQueue.remove());
        System.out.println(arrayBlockingQueue.remove());
        //java.util.NoSuchElementException  抛出异常
        //System.out.println(arrayBlockingQueue.remove());
    }
}
</code></pre>
<pre><code class="language-java">    /**
     * 有返回值，不抛出异常
     */
    public static void test2() {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));
        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));
        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));
        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;));  //打印出false，不抛出异常！

        System.out.println(&quot;===============&quot;);
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());  //null  有返回值没有异常！
    }
</code></pre>
<pre><code class="language-java">    /**
     * 等待，阻塞（一直等待）
     */
    public static void test3() throws InterruptedException {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        //一直阻塞
        arrayBlockingQueue.put(&quot;a&quot;);
        arrayBlockingQueue.put(&quot;b&quot;);
        arrayBlockingQueue.put(&quot;c&quot;);
        //arrayBlockingQueue.put(&quot;d&quot;);      //队列没有位置了，一直阻塞

        System.out.println(arrayBlockingQueue.take());
        System.out.println(arrayBlockingQueue.take());
        System.out.println(arrayBlockingQueue.take());
        //System.out.println(arrayBlockingQueue.take());   //没有这个元素，一直阻塞
    }
</code></pre>
<pre><code class="language-java">    /**
     * 等待，阻塞（等待超时）
     */
    public static void test4() throws InterruptedException {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        arrayBlockingQueue.offer(&quot;a&quot;);
        arrayBlockingQueue.offer(&quot;b&quot;);
        arrayBlockingQueue.offer(&quot;c&quot;);
        arrayBlockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS);  //等待两秒超过就退出

        System.out.println(&quot;====================&quot;);
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        arrayBlockingQueue.poll(2, TimeUnit.SECONDS);  //等待超过两秒退出
    }
</code></pre>
<h3 id="102-synchronizedqueue同步队列blockingqueue的实现类">10.2 SynchronizedQueue同步队列（BlockingQueue的实现类）</h3>
<p>没有容量：进去 一个元素，必须等待取出来之后，才能再往里面放一个元素！（可以抽象理解为capacity = 1的blockingqueue）</p>
<p>put/take</p>
<pre><code class="language-java">/**
 * 同步队列
 * 和其他的blockingqueue不一样， SynchronousQueue不存储元素
 * put了一个元素，必须从里面先take取出来，否则不能再put进去值
 */
public class SynchronizedQueueDemo {
    public static void main(String[] args) {
        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();

        new Thread(() -&gt; {
            try {
                System.out.println(Thread.currentThread().getName() + &quot; put 1&quot;);
                blockingQueue.put(&quot;1&quot;);
                System.out.println(Thread.currentThread().getName() + &quot; put 2&quot;);
                blockingQueue.put(&quot;2&quot;);
                System.out.println(Thread.currentThread().getName() + &quot; put 3&quot;);
                blockingQueue.put(&quot;3&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;T1&quot;).start();

        new Thread(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + blockingQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;T2&quot;).start();
    }
}
</code></pre>
<h2 id="11-线程池重点-三大方法-七大参数-四种拒绝策略">11. 线程池（重点！  三大方法、七大参数、四种拒绝策略）</h2>
<blockquote>
<p><strong>池化技术</strong></p>
<p>可以理解为：事先准备好一些资源，有人要用，就来我这里拿，用完了再还回来。</p>
</blockquote>
<p><strong>线程池的好处：</strong><mark>线程复用；可以控制最大并发数；管理线程</mark></p>
<ol>
<li>降低资源的消耗</li>
<li>提高响应的速度（创建和销毁十分浪费资源）</li>
<li>方便管理</li>
</ol>
<h3 id="111-三大方法">11.1 三大方法</h3>
<p>Executors.<strong>newSingleThreadExecutor()</strong>;   //单个线程<br>
Executors.<strong>newFixedThreadPool(5)</strong>;   //创建一个固定的线程池大小<br>
Executors.<strong>newCachedThreadPool()</strong>;   //可伸缩的，遇强则强，遇弱则弱</p>
<pre><code class="language-java">// Executors 工具类、三大方法
public class Demo01 {
    public static void main(String[] args) {
//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定的线程池大小
        ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的，遇强则强，遇弱则弱

        try {
            for (int i = 0; i &lt; 100; i++) {
                //使用了线程池以后，要使用线程池的方法来创建
                threadPool.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + &quot; ok&quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
</code></pre>
<h3 id="112-七大参数">11.2 七大参数</h3>
<blockquote>
<p><strong>int corePoolSize,  // 核心线程池大小</strong><br>
<strong>int maximumPoolSize,  //最大核心线程池大小</strong><br>
<strong>long keepAliveTime,  //超时了没有人调用就会释放</strong><br>
<strong>TimeUnit unit,  //超时单位</strong><br>
<strong>BlockingQueue<Runnable> workQueue,  //阻塞队列</strong><br>
<strong>ThreadFactory threadFactory,  //线程工厂，创建线程的，一般不用动</strong><br>
<strong>RejectedExecutionHandler handler  //拒绝策略</strong></p>
</blockquote>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}

public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

// 本质：ThreadPoolExcutor

public ThreadPoolExecutor(int corePoolSize,  // 核心线程池大小
                          int maximumPoolSize,  //最大核心线程池大小
                          long keepAliveTime,  //超时了没有人调用就会释放
                          TimeUnit unit,  //超时单位
                          BlockingQueue&lt;Runnable&gt; workQueue,  //阻塞队列
                          ThreadFactory threadFactory,  //线程工厂，创建线程的，一般不用动
                          RejectedExecutionHandler handler  //拒绝策略) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
        null :
    AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://chase-don.github.io//post-images/image-20210401115958236.png" alt="image-20210401115958236" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://chase-don.github.io//post-images/image-20210401120416736.png" alt="image-20210401120416736" loading="lazy"></figure>
<p>(上图很好理解！！线程池)</p>
<blockquote>
<p>手动创建线程池</p>
</blockquote>
<pre><code class="language-java">public class Demo02 {
    public static void main(String[] args) {
        //自定义线程池(ThreadPoolExecutor)
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue&lt;&gt;(3),
                Executors.defaultThreadFactory(),
//                new ThreadPoolExecutor.AbortPolicy() //银行满了，还有人进来，不处理这个人的线程，抛出异常
//                new ThreadPoolExecutor.CallerRunsPolicy() //哪儿来的回哪儿去（例如回到主线程）
//                new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉当前任务，不会抛出异常！
                new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，丢弃阻塞队列的队首元素，然后再调用execute方法尝试进入队列，不会对正在执行的线程有任何影响
        );

        try {
            //最大承载： Queue + max
            for (int i = 1; i &lt;= 9; i++) {
                //使用了线程池以后，要使用线程池的方法来创建
                threadPool.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + &quot; ok&quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
</code></pre>
<h3 id="113-四种拒绝策略">11.3 四种拒绝策略</h3>
<blockquote>
<figure data-type="image" tabindex="21"><img src="https://chase-don.github.io//post-images/image-20210401121651016.png" alt="image-20210401121651016" loading="lazy"></figure>
</blockquote>
<pre><code class="language-java">/*
* 四种拒绝策略：
* 1. new ThreadPoolExecutor.AbortPolicy() //银行满了，还有人进来，不处理这个人的线程，抛出异常
* 2. new ThreadPoolExecutor.CallerRunsPolicy() //哪儿来的回哪儿去（例如回到主线程）
* 3. new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢弃当前任务，不会抛出异常！
* 4.new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，丢弃阻塞队列的队首元素，然后再调用execute方法尝试进入	队列，不会对正在执行的线程有任何影响
*/
</code></pre>
<h3 id="114-小结和拓展">11.4 小结和拓展</h3>
<p><strong>最大线程到底该如何去设置？</strong></p>
<ol>
<li><strong>CPU密集型</strong>
<ul>
<li>电脑几核，就是几，可以保持CPU的效率最高！</li>
<li>用代码获取电脑的CPU核数：
<ul>
<li>Runtime.getRuntime().availableProcessors().sout;</li>
</ul>
</li>
</ul>
</li>
<li><strong>IO密集型</strong>：<strong>判断程序中十分耗IO的线程，只要大于这个线程数，就可以（一般设置两倍）</strong>
<ul>
<li>一个程序有15个大型任务，IO十分占用资源。至少有15个线程处理这些IO。</li>
</ul>
</li>
</ol>
<h2 id="12-四大函数式接口必须掌握">12. 四大函数式接口（必须掌握）</h2>
<p>同样需要掌握的还有：lambda表达式、链式编程、函数式接口、Stream流式计算</p>
<h3 id="121-什么是函数式接口">12.1 什么是函数式接口</h3>
<p>FunctionalInterface，只有一个方法的接口，简化编程模型，新版本的框架底层大量使用</p>
<figure data-type="image" tabindex="22"><img src="https://chase-don.github.io//post-images/image-20210401141133634.png" alt="image-20210401141133634" loading="lazy"></figure>
<h3 id="122-function函数式接口function-函数型接口有一个输入参数有一个输出">12.2 Function函数式接口（Function 函数型接口，有一个输入参数，有一个输出）</h3>
<figure data-type="image" tabindex="23"><img src="https://chase-don.github.io//post-images/image-20210401150718506.png" alt="image-20210401150718506" loading="lazy"></figure>
<p>代码测试：</p>
<pre><code class="language-java">/**
 * Function 函数型接口，有一个输入参数，有一个输出
 * 只要是函数型接口，都可以用 lambda表达式简化
 */
public class Demo01 {

    public static void main(String[] args) {
//        Function&lt;String, String&gt; function = new Function&lt;String, String&gt;(){
//            @Override
//            public String apply(String s) {
//                return s;
//            }
//        };

        Function&lt;String, String&gt; function = (s) -&gt; {return s;};

        System.out.println(function.apply(&quot;asfe&quot;));
    }
}
</code></pre>
<h3 id="123-断定型接口predicate断定型接口有一个输入参数返回值只能是布尔值">12.3 断定型接口（Predicate，断定型接口，有一个输入参数，返回值只能是布尔值！）</h3>
<figure data-type="image" tabindex="24"><img src="https://chase-don.github.io//post-images/image-20210401151158324.png" alt="image-20210401151158324" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 断定型接口，有一个输入参数，返回值只能是布尔值！
 */
public class PredicateDemo {
    public static void main(String[] args) {
//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {
//            @Override
//            public boolean test(String str) {
//                return str.isEmpty();
//            }
//        };
        Predicate&lt;String&gt; predicate = (str)-&gt;{return str.isEmpty();};

        System.out.println(predicate.test(&quot;qwww&quot;));
    }
}
</code></pre>
<h3 id="124-消费型接口consumer">12.4 消费型接口（Consumer）</h3>
<figure data-type="image" tabindex="25"><img src="https://chase-don.github.io//post-images/image-20210401152626255.png" alt="image-20210401152626255" loading="lazy"></figure>
<pre><code class="language-java">/**
 * Consumer: 消费型接口，只有输入，没有返回值
 */
public class ConsumerDemo {
    public static void main(String[] args) {
//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {
//            @Override
//            public void accept(String str) {
//                System.out.println(str);
//            }
//        };
        Consumer consumer = (str)-&gt;{System.out.println(str);};

        consumer.accept(&quot;dsdsds&quot;);
    }
}
</code></pre>
<h3 id="125-供给型接口supplier">12.5 供给型接口（supplier）</h3>
<figure data-type="image" tabindex="26"><img src="https://chase-don.github.io//post-images/image-20210401160732488.png" alt="image-20210401160732488" loading="lazy"></figure>
<pre><code class="language-java">/**
 * Supplier 供给型接口 没有参数(没有输入)，只有返回值
 */
public class SupplierDemo {
    public static void main(String[] args) {
//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() {
//            @Override
//            public Integer get() {
//                System.out.println(&quot;get()&quot;);
//                return 1024;
//            }
//        };

        Supplier&lt;Integer&gt; supplier = () -&gt; {return 1024;};

        System.out.println(supplier.get());
    }
}
</code></pre>
<h2 id="13-stream流式计算">13. Stream流式计算</h2>
<blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据：存储 + 计算</p>
<p>集合、Mysql本质就是存储东西的；</p>
<p>计算都应该交给流来做</p>
<figure data-type="image" tabindex="27"><img src="https://chase-don.github.io//post-images/image-20210401164831861.png" alt="image-20210401164831861" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 现有五个用户，筛选：
 * 1. ID 必须是偶数
 * 2. 年龄必须大于23岁
 * 3. 用户名转为大写字母
 * 4. 用户名字母倒着排序
 * 5. 只输出一个用户
 */
public class StreamTest {
    public static void main(String[] args) {
        User user1 = new User(1, &quot;a&quot;, 21);
        User user2 = new User(2, &quot;b&quot;, 22);
        User user3 = new User(3, &quot;c&quot;, 23);
        User user4 = new User(4, &quot;d&quot;, 24);
        User user5 = new User(6, &quot;e&quot;, 25);
        //集合就是存储
        List&lt;User&gt; list = Arrays.asList(user1, user2, user3, user4, user5);

        //计算交给流！
        //链式编程！
        list.stream().filter(user -&gt; {return user.getId() % 2 == 0;})
                .filter(user -&gt; {return user.getAge() &gt; 23;})
                .map(user -&gt; {return user.getName().toUpperCase();})
                .sorted((user11, user22) -&gt; {return user22.compareTo(user11);})
                .limit(1)
                .forEach(System.out::println);
    }
}
</code></pre>
<h2 id="14-forkjoin">14. Forkjoin</h2>
<h3 id="141-什么是forkjoin">14.1 什么是Forkjoin？</h3>
<p>Forkjoin在JDK1.7出现：并行执行任务；提高效率（<strong>在大数据量的场景下</strong>）    小数据量没必要使用ForkJoin</p>
<p>大数据：Map Reduce（把大任务拆分成小任务）</p>
<img src="file://D:/博客源文件/post-images/image-20210402190345607.png" alt="image-20210402190345607" style="zoom:50%;" />
<p><mark>**Forkjoin的特点：**工作窃取</mark></p>
<p>下图两个任务这里面维护的都是双端队列</p>
<img src="file://D:/博客源文件/post-images/image-20210402190712553.png" alt="image-20210402190712553" style="zoom:50%;" />
<h3 id="142-forkjoin的操作">14.2 Forkjoin的操作</h3>
<p>代码省略（知道这个思路就行）</p>
<h2 id="15-异步回调">15. 异步回调</h2>
<blockquote>
<p>Future设计的初衷：对将来的某个时间的结果进行建模</p>
</blockquote>
<img src="file://D:/博客源文件/post-images/image-20210402204330566.png" alt="image-20210402204330566" style="zoom: 80%;" />
<pre><code class="language-java">/**
 * 异步调用： CompletableFuture
 * 异步执行
 * 成功回调
 * 失败回调
 */
public class Demo01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //没有返回值的runAsync
//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {
//            try {
//                TimeUnit.SECONDS.sleep(2);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;Void&quot;);
//        });
//
//        System.out.println(&quot;1111&quot;);
//
//        completableFuture.get(); // 获取阻塞的执行结果


        //有返回值的 supplyAsync 异步回调
        //ajax =&gt; 有成功回调也有失败回调
        //回调失败返回的是错误信息
        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot;supplyAsync=&gt;Integer&quot;);
            int i = 10 / 0;
            return 1024;
        });

        System.out.println(completableFuture.whenComplete((t, u) -&gt; {
            System.out.println(&quot;t=&gt;&quot; + t);  // 正常的返回结果
            System.out.println(&quot;u=&gt;&quot; + u);  // 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
        }).exceptionally((e) -&gt; {
            System.out.println(e.getMessage());
            return 233;  //可以获取到错误的返回结果
        }).get());
    }
}
</code></pre>
<h2 id="16-jmm">16. JMM</h2>
<h3 id="161-什么是jmmjava内存模型">16.1 什么是JMM（Java内存模型）</h3>
<p>不存在的东西，是一个概念！约定！</p>
<h3 id="162-关于jmm的一些同步的约定">16.2 关于JMM的一些同步的约定</h3>
<ol>
<li>线程解锁前，必须**<mark>把共享变量立刻刷新回主存</mark>**！</li>
<li>线程加锁前，必须读取主存中的最新值到工作内存中！</li>
<li>加锁和解锁是同一把锁</li>
</ol>
<h3 id="163-线程分为工作内存和主内存-以及-8种操作">16.3 线程分为==<strong>工作内存和主内存</strong>==  以及 <mark>8种操作</mark></h3>
<figure data-type="image" tabindex="28"><img src="https://chase-don.github.io//post-images/image-20210402221907628.png" alt="image-20210402221907628" loading="lazy"></figure>
<p>java内存模型定义了8种操作来完成。<strong><mark>这8种操作每一种都是原子操作</mark></strong>。8种操作如下：</p>
<ul>
<li>lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；</li>
<li>read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；</li>
<li>load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；</li>
<li>use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；</li>
<li>assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；</li>
<li>store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；</li>
<li>write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。</li>
<li>unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；</li>
</ul>
<p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则:</p>
<p>（1）不允许read和load、store和write操作之一单独出现（即不允许一个变量从主存读取了但是工作内存不接受，或者从工作内存发起会写了但是主存不接受的情况），以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</p>
<p>（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
<p>（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
<p>（4）一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>（5）一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
<p>（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
<p>（7）如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p>
<p>（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</p>
<pre><code class="language-java">public class JMMDemo {

    private static int num = 0;

    public static void main(String[] args) { //main

        new Thread(() -&gt; { //线程1
            while (num == 0) {

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        num = 1;
        System.out.println(num);
    }
}
</code></pre>
<p>出现问题：程序不知道主内存的值已经被修改过了，需要线程A知道主内存中的值发生了变化</p>
<img src="file://D:/博客源文件/post-images/image-20210403000040445.png" alt="image-20210403000040445" style="zoom: 67%;" />
<h2 id="17volatile">17.Volatile</h2>
<blockquote>
<p>请你谈谈对Volatile的理解</p>
</blockquote>
<p>volatile是Java虚拟机提供的==<strong>轻量级的同步机制</strong>==：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<h3 id="171-保证可见性">17.1 保证可见性</h3>
<pre><code class="language-java">public class JMMDemo {
    //不加 volatile 程序就会死循环！
    //加 volatile 可以保证可见性
    private volatile static int num = 0;

    public static void main(String[] args) { //main

        new Thread(() -&gt; { //线程1 ,对主内存的变化不知道！
            while (num == 0) {

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        num = 1;
        System.out.println(num);
    }
}
</code></pre>
<h3 id="172-不保证原子性">17.2 不保证原子性</h3>
<p>原子性：不可分割（线程A在执行任务的时候，不能被打扰的，也不能被分割。<strong><mark>要么同时成功，要么同时失败</mark></strong>）</p>
<pre><code class="language-java">/**
 * 不保证原子性
 */
public class VolatileDemo {
    //加了volatile依旧不足20k，说明volatile不保证原子性
    private volatile static int num = 0;

    public static void add() {
        num++;
    }

    public static void main(String[] args) {
        //理论上num结果为20000
        for (int i = 1; i &lt;= 20; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount() &gt; 2) {
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName() + &quot; &quot; + num);
    }
}
</code></pre>
<p><strong><u>问题！！如果不加 lock 和 synchronized，怎么样保证原子性？</u></strong></p>
<img src="file://D:/博客源文件/post-images/image-20210403011352414.png" alt="image-20210403011352414" style="zoom: 67%;" />
<p><strong><mark>答案：使用原子类，解决原子性问题</mark></strong>（**这些类的底层都直接和操作系统挂钩，在内存中修改值！**Unsafe类是一个很特殊的存在）</p>
<pre><code class="language-java">public class VolatileDemo {
    //原子类的Integer
    private volatile static AtomicInteger num = new AtomicInteger();

    public static void add() {
//        num++; //不是一个原子性操作！
        num.getAndIncrement(); // AtomicInteger的 +1 方法，用的是CAS
    }

    public static void main(String[] args) {
        //理论上num结果为20000
        for (int i = 1; i &lt;= 20; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount() &gt; 2) {
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName() + &quot; &quot; + num);
    }
}
</code></pre>
<h3 id="173-禁止指令重排">17.3 禁止指令重排</h3>
<blockquote>
<p>什么是指令重排？</p>
</blockquote>
<p>写的程序，计算机并不是按照写的那样去执行的。</p>
<p><mark><strong>源代码 --&gt; 编译器优化的重排 --&gt; 指令并行也可能会重排 --&gt; 内存系统也会重排 --&gt; 执行</strong></mark></p>
<p><strong>处理器在进行指令重排的时候，会考虑：数据之间的依赖性！</strong></p>
<pre><code class="language-java">int x = 1; // 1
int y = 2; // 2
x = x + 5; // 3
y = x * x; // 4

我们所期望的是：1234  但是可能执行的时候会变成 2134 1324
问：可不可能是 4123？   不可能！
</code></pre>
<p>指令重排可能造成对结果的影响，举例如下：</p>
<p>a,b,x,y 这四个值默认都是0：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>x  = a</td>
<td>y = b</td>
</tr>
<tr>
<td>b = 1</td>
<td>a = 2</td>
</tr>
</tbody>
</table>
<p>正常的结果： x = 0; y = 0; 但是可能由于指令重排线程运行变成如下：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>x  = a</td>
<td>y = b</td>
</tr>
<tr>
<td>b = 1</td>
<td>a = 2</td>
</tr>
</tbody>
</table>
<p>指令重排导致结果为： x = 2; y = 1</p>
<p><strong>volatile可以避免指令重排：</strong></p>
<p>内存屏障-&gt;CPU指令。作用：</p>
<ol>
<li>保证特定的操作的执行顺序</li>
<li>可以保证某些变量的内存可见性(<strong>利用这些特性volatile实现了可见性</strong>)</li>
</ol>
<img src="file://D:/博客源文件/post-images/image-20210403175846842.png" alt="image-20210403175846842" style="zoom:67%;" />
<p>Volatile是可以保证可见性，不能保证原子性，由于内存屏障，可以保证避免指令重排的现象发生。</p>
<h2 id="18-单例模式">18. 单例模式</h2>
<p>饿汉式  懒汉式（DCL懒汉式，双重检测模式）</p>
<h2 id="19深入理解cas这块没太懂-多看面经">19.深入理解CAS（这块没太懂  多看面经）</h2>
<h3 id="191-什么是cas">19.1 什么是CAS</h3>
<pre><code class="language-java">/**
 * CAS是CPU的并发原语
 */
public class CASDemo {
    //CAS compareAndSwap：比较并交换！
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        //两个参数，前面是expect后面是update
        //public final boolean compareAndSet(int expect, int update)    返回值是个boolean
        //如果我期望的值达到了，那么就更新，否则就不更新。
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        atomicInteger.getAndIncrement();
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
</code></pre>
<h3 id="192-什么是unsafe类">19.2 什么是Unsafe类</h3>
<img src="file://D:/博客源文件/post-images/image-20210403184411704.png" alt="image-20210403184411704" style="zoom: 67%;" />
<img src="file://D:/博客源文件/post-images/image-20210403185330343.png" alt="image-20210403185330343" style="zoom:67%;" />
<figure data-type="image" tabindex="29"><img src="https://chase-don.github.io//post-images/image-20210403185634113.png" alt="image-20210403185634113" loading="lazy"></figure>
<h3 id="193-cas总结">19.3 CAS总结：</h3>
<p>CAS: <strong>比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作</strong>！如果不是就一直循环！（底层是do...while  自旋锁）</p>
<p>缺点：</p>
<ul>
<li>底层是自旋锁，循环会耗时</li>
<li>由于<strong>是底层的CPU操作，一次性只能保证一个共享变量的原子性</strong></li>
<li>会存在ABA问题</li>
</ul>
<h2 id="20-带版本号的原子引用atomicstampedreference解决aba问题">20. 带版本号的原子引用(<mark>AtomicStampedReference</mark>)解决ABA问题</h2>
<h3 id="201-什么是aba问题">20.1 什么是ABA问题？</h3>
<img src="file://D:/博客源文件/post-images/image-20210403191039765.png" alt="image-20210403191039765" style="zoom:67%;" />
<pre><code class="language-java">public class ABADemo {
    //CAS compareAndSwap：比较并交换！
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        //两个参数，前面是expect后面是update
        //public final boolean compareAndSet(int expect, int update)    返回值是个boolean
        //如果我期望的值达到了，那么就更新，否则就不更新。
        // ================== 捣乱的线程 ===================
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());

        // ================== 期望的线程 ===================
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
</code></pre>
<h3 id="202-什么是原子引用带版本号的原子操作">20.2 什么是原子引用？（带版本号的原子操作）</h3>
<img src="file://D:/博客源文件/post-images/image-20210403195955345.png" alt="image-20210403195955345" style="zoom: 67%;" />
<p><strong>Integer使用了对象缓存机制，默认范围是-128-127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间</strong></p>
<h2 id="21-各种锁的理解">21. 各种锁的理解</h2>
<h3 id="211-公平锁-非公平锁">21.1 公平锁、非公平锁</h3>
<p>公平锁：非常公平，不可以插队，必须先来后到</p>
<p>非公平锁：非常不公平，可以插队</p>
<pre><code class="language-java">public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<h3 id="212-可重入锁">21.2 可重入锁</h3>
<img src="file://D:/博客源文件/post-images/image-20210403203510847.png" alt="image-20210403203510847" style="zoom:50%;" />
<blockquote>
<p>Synchronized</p>
</blockquote>
<pre><code class="language-java">//synchronized
public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;A&quot;).start();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;B&quot;).start();
    }
}

class Phone{
    public synchronized void sms() {
        System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);
        call();  // 这里也有锁！！
    }

    public synchronized void call() {
        System.out.println(Thread.currentThread().getName() + &quot;call&quot;);
    }
}
</code></pre>
<blockquote>
<p>Lock</p>
</blockquote>
<pre><code class="language-java">//lock
public class Demo02 {
    public static void main(String[] args) {
        Phone2 phone = new Phone2();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;A&quot;).start();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;B&quot;).start();
    }
}

class Phone2{
    Lock lock = new ReentrantLock();
    public void sms() {
        lock.lock(); //lock锁必须配对，否则就会死在里面
        try {
            System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);
            call();  // 这里也有锁！！
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void call() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot;call&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h3 id="213-自旋锁spinlock">21.3 自旋锁(spinlock )</h3>
<figure data-type="image" tabindex="30"><img src="https://chase-don.github.io//post-images/image-20210403185634113.png" alt="image-20210403185634113" loading="lazy"></figure>
<p>自定义一个自旋锁：</p>
<pre><code class="language-java">/**
 * 自旋锁
 */
public class SpinlockDemo {

    //int   0
    //Thread   null
    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;Thread&gt;();

    //加锁
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;);

        //自旋锁
        while (!atomicReference.compareAndSet(null, thread)) {

        }
    }

    //解锁
    public void myUnLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnlock&quot;);
        atomicReference.compareAndSet(thread, null);
    }
}
</code></pre>
<pre><code class="language-java">public class TestSpinLock {
    public static void main(String[] args) throws InterruptedException {
        //底层使用的是自旋锁
        SpinlockDemo lock = new SpinlockDemo();

        new Thread(() -&gt; {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        }, &quot;t1&quot;).start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -&gt; {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        }, &quot;t2&quot;).start();

    }
}
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://chase-don.github.io//post-images/image-20210403221329691.png" alt="image-20210403221329691" loading="lazy"></figure>
<h3 id="214-死锁">21.4 死锁</h3>
<blockquote>
<p>什么是死锁</p>
</blockquote>
<figure data-type="image" tabindex="32"><img src="https://chase-don.github.io//post-images/image-20210403221427819.png" alt="image-20210403221427819" loading="lazy"></figure>
<pre><code class="language-java">public class DeadLockDemo {
    public static void main(String[] args) {
        MyThread myThread1 = new MyThread(&quot;a&quot;, &quot;b&quot;);
        MyThread myThread2 = new MyThread(&quot;b&quot;, &quot;a&quot;);

        new Thread(myThread1).start();
        new Thread(myThread2).start();
    }

}


class MyThread implements Runnable {

    private String lockA;  //对象A
    private String lockB;  //对象B

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get&quot; + lockB);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get&quot; + lockA);
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p><strong>如何解决死锁（排查）？</strong></p>
<ul>
<li>
<p>使用jps定位进程号</p>
<ul>
<li><strong><mark>指令为  jps-l</mark></strong></li>
</ul>
<figure data-type="image" tabindex="33"><img src="https://chase-don.github.io//post-images/image-20210403223955180.png" alt="image-20210403223955180" loading="lazy"></figure>
</li>
<li>
<p>使用**<mark>jstack+进程号</mark>**找到死锁信息（如上图的30140就是进程号）</p>
</li>
</ul>
<figure data-type="image" tabindex="34"><img src="https://chase-don.github.io//post-images/image-20210403224610440.png" alt="image-20210403224610440" loading="lazy"></figure>
<p>排查问题：日志+堆栈信息</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://chase-don.github.io/tag/m9VO_Rfsd/" class="tag">
                    JUC
                  </a>
                
                  <a href="https://chase-don.github.io/tag/d1Ec0O0Rz7/" class="tag">
                    学习笔记
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://chase-don.github.io/post/springmvc/">
                  <h3 class="post-title">
                    SpringMVC
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
