<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chase-don.github.io/</id>
    <title>Loro</title>
    <updated>2021-05-10T13:23:22.243Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chase-don.github.io/"/>
    <link rel="self" href="https://chase-don.github.io/atom.xml"/>
    <subtitle>表现不俗</subtitle>
    <logo>https://chase-don.github.io/images/avatar.png</logo>
    <icon>https://chase-don.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Loro</rights>
    <entry>
        <title type="html"><![CDATA[Spring 2021.1.25]]></title>
        <id>https://chase-don.github.io/post/spring-2021125/</id>
        <link href="https://chase-don.github.io/post/spring-2021125/">
        </link>
        <updated>2021-01-26T01:05:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-2021125">Spring 2021.1.25</h1>
<h2 id="1spring">1.Spring</h2>
<h3 id="11简介略">1.1简介（略）</h3>
<h3 id="12-优点">1.2 优点</h3>
<ul>
<li>Spring是一个开源的免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持</li>
</ul>
<p><strong>总结：Spring就是一个轻量级的控制反转(IOC)和面向切面编程(AOP)的框架</strong></p>
<h3 id="13-组成">1.3 组成</h3>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/1615489824192.png" alt="" loading="lazy"></figure>
<h2 id="2-ioc理论推导">2. IOC理论推导</h2>
<ol>
<li>UserDao接口</li>
<li>UserDaoImpl实现类</li>
<li>UserService业务接口</li>
<li>UserServiceImpl业务实现类</li>
</ol>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！</p>
<p>我们使用一个set接口实现</p>
<pre><code class="language-java">    private UserDao userDao;

    //利用set进行动态实现值的注入！
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

</code></pre>
<p>Test中：</p>
<pre><code class="language-java">public static void main(String[] args) {

    //用户实际调用的是业务层，DAO层不需要接触！
    UserServiceImpl userService = new UserServiceImpl();
    userService.setUserDao(new UserDaoOracleImpl());
    userService.getUser();
}
}
</code></pre>
<ul>
<li>之前，程序是主动创建对象，控制权在程序员手中</li>
<li>使用set注入后，程序不再具有主动性，而是变成<strong>被动接收对象</strong>，由用户根据需求来创建对象!</li>
</ul>
<p><strong>这种思想从本质上解决了问题，我们程序员不用再去管理对象的创建了！</strong></p>
<h3 id="ioc本质">IOC本质</h3>
<p>**控制反转IoC（Inversion of Control）是一种设计思想，DI（依赖注入）是实现IoC的一种方法。**也有人认为DI只是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方（用户），个人认为所谓的控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection, DI）</strong></p>
<h2 id="3-hellospring">3. HelloSpring</h2>
<p>pojo：</p>
<pre><code class="language-java">public class Hello {
    private String str;
    public String getStr() {
        return str;
    }
    public void setStr(String str) {
        this.str = str;
    }
    @Override
    public String toString() {
        return &quot;Hello{&quot; +
                &quot;str='&quot; + str + '\'' +
                '}';
    }
}
</code></pre>
<p>Spring配置文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--使用Spring来创建对象，在Spring中这些都称为Bean

    类型  变量名 = new 类型();
    Hello hello = new Hello();

    id = 变量名
    class = new 的对象
    property  相当于给对象中的属性设置一个值！
    ref: 引用Spring容器中创建好的对象
    value： 具体的值，简单类型
    --&gt;
    &lt;bean id=&quot;hello&quot; class=&quot;cn.edu.bupt.pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        //获取Spring的上下文对象(解析beans.xml文件，生成管理相应的Bean对象)
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以！
        //getBean： 参数即为spring配置文件中bean的id
        Hello hello = (Hello) context.getBean(&quot;hello&quot;);
        System.out.println(hello.toString());

    }
}
</code></pre>
<h3 id="思考问题">思考问题</h3>
<ul>
<li>
<p>Hello对象是谁创建的？</p>
<p>hello对象是由Spring创建的</p>
</li>
<li>
<p>Hello对象的属性是怎么设置的？</p>
<p>hello对象的属性是由Spring容器设置的</p>
</li>
</ul>
<p>这个过程就叫控制反转：</p>
<p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的</p>
<p>反转：程序本身不创建对象，而被动的接受对象</p>
<p>依赖注入（DI）：就是利用set方法来进行注入的</p>
<p>IOC是一种编程思想，由主动的编程编程被动的接收。即：对象由Spring来创建，管理，装配！</p>
<h2 id="4-ioc创建对象的方式">4. IoC创建对象的方式</h2>
<ol>
<li>
<p>使用无参构造创建对象，默认！</p>
</li>
<li>
<p>假设我们要使用有参构造创建对象</p>
<ol>
<li>
<p>下标赋值(index后面的数字是有参构造的第几个参数)</p>
<pre><code class="language-xml">&lt;!--第一种方式： 下标赋值--&gt;
&lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;chase&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>根据类型赋值</p>
<pre><code class="language-xml">&lt;!--第二种方式： 通过类型创建，不建议使用！！！  有两个类型相同的没有办法操作--&gt;
&lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;loro&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>参数名</p>
<pre><code class="language-xml">&lt;!--第三种方式： 直接通过参数名来设置--&gt;
&lt;!--如果有参构造传入的是自定义的类，则用ref引入自定义类，否则可以直接通过参数名来设置--&gt;
&lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;ds&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<p><strong>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</strong></p>
<h2 id="5-spring配置">5. Spring配置</h2>
<h3 id="51-别名">5.1 别名</h3>
<pre><code class="language-xml">&lt;!--别名，如果添加了别名，我们也可以使用别名获取到这个对象--&gt;
&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h3 id="52-bean的配置">5.2 Bean的配置</h3>
<pre><code class="language-xml">&lt;!--
	id: bean的唯一标识符，也就是相当于我们学的变量名
    class：bean对象所对应的全限定名（包名 + 类型）
    name：也是别名，而且name可以同时取多个别名
--&gt;
&lt;bean id=&quot;userT&quot; class=&quot;cn.edu.bupt.pojo.UserT&quot; name=&quot;u2,uuu,user2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;xm&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="53-import">5.3 import</h3>
<p>一般用于团队开发使用，它可以将多个配置文件，导入合并成一个</p>
<p>假设项目有多个人开发，多人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以用import将所有人的beans.xml合并为一个总的，使用的时候，直接使用总的就可以了</p>
<h2 id="6-依赖注入">6. 依赖注入</h2>
<h3 id="61-构造器注入">6.1 构造器注入</h3>
<p>前面已经讲过了</p>
<h3 id="62-set方式注入重点">6.2 Set方式注入【重点】</h3>
<ul>
<li>依赖注入：Set注入
<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p>【环境搭建】（spring-04-di）</p>
<ol>
<li>
<p>复杂类型</p>
<pre><code class="language-java">public class Address {
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;address='&quot; + address + '\'' +
                '}';
    }
}
</code></pre>
</li>
<li>
<p>真实测试对象</p>
<pre><code class="language-java">略
</code></pre>
</li>
<li>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;address&quot; class=&quot;cn.edu.bupt.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;yancheng&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;cn.edu.bupt.pojo.Student&quot;&gt;
        &lt;!--第一种，普通值注入，value--&gt;
        &lt;property name=&quot;name&quot; value=&quot;ds&quot;/&gt;
        &lt;!--第二种， Bean注入， ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;

        &lt;!--数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;西游记&lt;/value&gt;
                &lt;value&gt;三国演义&lt;/value&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;

        &lt;!--List--&gt;
        &lt;property name=&quot;hobbys&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;睡觉&lt;/value&gt;
                &lt;value&gt;写代码&lt;/value&gt;
                &lt;value&gt;看书&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;!--Map--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;111111&quot;/&gt;
                &lt;entry key=&quot;联系方式&quot; value=&quot;123123&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;

        &lt;!--Set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;BOB&lt;/value&gt;
                &lt;value&gt;COC&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;

&lt;!--        &amp;lt;!&amp;ndash;如果为空字符串&amp;ndash;&amp;gt;--&gt;
&lt;!--        &lt;property name=&quot;wife&quot; value=&quot;&quot;/&gt;--&gt;

        &lt;!--属性值设为null--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;

        &lt;!--Properties--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;driver&quot;&gt;jdbcmysql&lt;/prop&gt;
                &lt;prop key=&quot;url&quot;&gt;mysql&lt;/prop&gt;
                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;password&quot;&gt;111111&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>测试类</p>
<pre><code class="language-java">public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    Student student = (Student) context.getBean(&quot;student&quot;);
    System.out.println(student);


    /**
         * Student{name='ds',
         * address=Address{address='yancheng'},
         * books=[西游记, 三国演义, 红楼梦, 水浒传],
         * hobbys=[睡觉, 写代码, 看书],
         * card={身份证=111111, 联系方式=123123},
         * games=[LOL, BOB, COC], wife='null',
         * info={password=111111, url=mysql, driver=jdbcmysql, username=root}}
         */
}
</code></pre>
</li>
</ol>
<h3 id="63-拓展方式注入">6.3 拓展方式注入</h3>
<p><strong>我们可以使用p-namespace和c-namespace进行注入</strong></p>
<p>官方解释：https://docs.spring.io/spring-framework/docs/5.2.12.RELEASE/spring-framework-reference/core.html#beans-collection-elements</p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/1615489902287.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
</code></pre>
<p><strong>p-namespace:(property) ： 可以直接注入属性的值</strong></p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;someone@somewhere.com&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>c-namespace:(constructor) : 可以注入构造方法的值，更加容易方便</strong></p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;
    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;

    &lt;!-- traditional declaration with optional argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;
        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration with argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;
        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><em><strong>注意点：p-namespace和c-namespace不能直接使用，需要导入xml约束！</strong></em></p>
<h3 id="64-bean的作用域">6.4 Bean的作用域</h3>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/1615489929298.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>单例模式（Spring默认机制）</p>
<pre><code class="language-xml">scope = &quot;singleton&quot;
</code></pre>
</li>
<li>
<p>原型模式：每次从容器中get的时候，都会产生一个新对象！</p>
<pre><code class="language-xml">scope = &quot;prototype&quot;
</code></pre>
</li>
<li>
<p>其余的几个作用域只能在web开发中使用到！</p>
</li>
</ol>
<h2 id="7-bean的自动装配">7. Bean的自动装配</h2>
<ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种自动装配的方式：</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li><strong>隐式的自动装配bean【重要】</strong></li>
</ol>
<h3 id="71-测试">7.1 测试</h3>
<p>环境搭建：<strong>一个人有两个不同的宠物!(三个对象)</strong></p>
<h3 id="72-byname自动装配">7.2 ByName自动装配</h3>
<pre><code class="language-xml">&lt;!--
    byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid（这里区分大小写，例如setDog对应即dog，若是大写Dog，则查找不到）
    --&gt;
&lt;bean id=&quot;person&quot; class=&quot;cn.edu.bupt.pojo.Person&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;ds&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="73-bytype自动装配">7.3 ByType自动装配</h3>
<pre><code class="language-xml">&lt;bean class=&quot;cn.edu.bupt.pojo.Cat&quot;/&gt;
&lt;bean class=&quot;cn.edu.bupt.pojo.Dog&quot;/&gt; //id都可以省略

&lt;!--
    byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid（这里区分大小写，例如setDog对应即dog，若是大写Dog，则查找不到）
    byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean
    --&gt;
&lt;bean id=&quot;person&quot; class=&quot;cn.edu.bupt.pojo.Person&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;ds&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>小结：</p>
<ul>
<li>byName的时候，需要保证<strong>所有bean的<em>id</em>唯一</strong>，并且这个bean需要和自动注入的属性的set方法后面的值一致</li>
<li>byType的时候，需要保证<strong>所有bean的<em>class</em>唯一</strong>，并且这个bean需要和自动注入的属性的类型一致！</li>
</ul>
<h3 id="74-使用注解实现自动装配"><em>7.4 使用注解实现自动装配</em></h3>
<p>要使用注解须知：</p>
<ol>
<li>
<p>导入约束： context约束</p>
</li>
<li>
<p>配置注解的支持：<a href="context:annotation-config/">context:annotation-config/</a></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
</li>
</ol>
<h4 id="autowired"><strong>@Autowired</strong></h4>
<p>直接在属性上使用即可，也可以在set方法上使用！</p>
<p>使用Autowired 我们可以不用编写Set方法了，前提是这个自动装配的属性在IOC(Spring)容器中存在，<strong>默认按照bean的类型进行装配(byType),当找到多个相同类型时，会自动byName，如果byName也不行(byName的话首先依旧是先根据类名对应的小写寻找)，才会报错</strong></p>
<p>科普：</p>
<pre><code class="language-java">@Nullable       字段标记了这个注解，说明这个字段可以为null
</code></pre>
<pre><code class="language-java">//下面是@Autowired的源代码，注意他的默认是true
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
    boolean required() default true;
}
</code></pre>
<p><strong>如果显示定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</strong></p>
<pre><code class="language-java">@Autowired(required = false)
private Dog dog;
</code></pre>
<p><strong>又如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用注解【@Qualifier(value=&quot;xxx&quot;)】去 配置@Autowired的使用，指定一个唯一的bean对象注入！</strong></p>
<pre><code class="language-java">public class Person {
    @Autowired
    @Qualifier(value = &quot;dog111&quot;)
    private Dog dog;
    @Autowired
    @Qualifier(value = &quot;cat11&quot;)
    private Cat cat;
    private String name;	
}
</code></pre>
<h4 id="resource注解"><strong>@Resource注解</strong></h4>
<pre><code class="language-java">public class Person {
    @Resource
    private Dog dog;
    @Resource(name = &quot;cat1&quot;)
    private Cat cat;
    private String name;
}
</code></pre>
<p>@Resource情况比较特殊，经过测试得知：</p>
<ul>
<li>如果都只有一个类型只有一个，则无论beanid是什么都可以自动装配；(下图)</li>
<li>如果同一个类型有多个，则有beanid符合byname的条件，即可完成自动装配；(下图)</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/1615489973242.png" alt="" loading="lazy"></figure>
<ul>
<li>如果同一类型有多个，且没有beanid符合byname的要求，那么需要在注解上进行完善，即：@Resource(name = &quot;xxx&quot;)，指定一个唯一的bean对象进行注入(代码如上面那个代码块所示，图如下)</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/1615490011080.png" alt="" loading="lazy"></figure>
<p><strong>@Resource和@Autowired的区别：</strong></p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上</li>
<li>@Autowired 默认通过byType的方式实现，而且必须要求这个对象存在！如果允许不存在需要在注解后添加(required = false)</li>
<li>@Resource 默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错</li>
<li>执行顺序不同，已经提及到了  @Autowired —&gt;byType; @Resource —&gt;byName</li>
<li>具体可看下文：https://blog.csdn.net/ajax11111/article/details/50057297?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</li>
</ul>
<h2 id="8-使用注解开发">8. 使用注解开发</h2>
<p>在Spring4之后，要使用注解开发，必须要保证aop的包导入了</p>
<p><img src="https://chase-don.github.io//post-images/1615490039316.png" alt="" loading="lazy">🤣</p>
<p>使用注解需要啊导入context约束，增加注解的支持！</p>
<ol>
<li>
<p>bean</p>
</li>
<li>
<p>属性如何注入</p>
<pre><code class="language-java">//等价于 &lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;/&gt;
// Component 翻译就是组件
@Component
public class User {
    public String name;

    //相当于在xml配置文件里面写入property
    @Value(&quot;loro&quot;)
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
</li>
<li>
<p>衍生的注解</p>
<p>@Component 有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>
<p>dao   【@Repository】</p>
</li>
<li>
<p>service 【@Service】</p>
</li>
<li>
<p>controller 【@Controller】</p>
<p><strong>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean</strong></p>
</li>
</ul>
</li>
<li>
<p>自动装配</p>
<ul>
<li>
<p>@Autowired：自动装配  byType -&gt; byName<br>
如果Autowired不能唯一自动装配上属性，则需要通过 @Qualifier(value = &quot;xxx&quot;)</p>
</li>
<li>
<p>@Nullable   :  字段标记了这个注解则说明这个字段可以为null</p>
</li>
<li>
<p>@Resource：自动装配  byName -&gt; byType</p>
</li>
</ul>
</li>
<li>
<p>作用域</p>
<pre><code class="language-java">@Component
@Scope(&quot;singleton&quot;)
public class User {
    public String name;

    //相当于在xml配置文件里面写入property
    @Value(&quot;loro&quot;)
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
</li>
<li>
<p>小结</p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单方便</li>
<li>注解：不是自己的类使用不了，维护相对复杂</li>
</ul>
<p>xml与注解的最佳实践：</p>
<ul>
<li>
<p>xml用来管理bean；</p>
</li>
<li>
<p>注解只负责属性的注入</p>
</li>
<li>
<p>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要<strong>开启注解的支持</strong></p>
<pre><code class="language-xml">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
&lt;context:component-scan base-package=&quot;cn.edu.bupt&quot;/&gt;
&lt;context:annotation-config/&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="9-使用java的方式配置spring">9. 使用java的方式配置Spring</h2>
<p>我们现在要完全不适用Spring的xml配置了，全权交给java来做！</p>
<p><strong>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能！</strong></p>
<p>实体类</p>
<pre><code class="language-java">//这里这个注解的意思，就是说明这个类被spring接管了，注册到了容器中
@Component
public class User {
    private String name;

    public String getName() {
        return name;
    }

    @Value(&quot;loro&quot;)  //属性注入值
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>配置文件</p>
<pre><code class="language-java">package cn.edu.bupt.config;

import cn.edu.bupt.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//这个也会被Spring容器接管，注册到容器中，因为他本来就是一个@Component
// @Configuration代表这是一个配置类，就和我们之前看的beans.xml相同
@Configuration
@ComponentScan(&quot;cn.edu.bupt.pojo&quot;)
@Import(MyConfig2.class)
public class MyConfig {

    // 注册一个bean，就相当于我们之前写的一个bean标签
    // id = 这个方法的名字
    // class = 方法的返回值所属类
    @Bean
    public User getUser() {
        return new User();  //就是返回要注入到bean的对象
    }

}
</code></pre>
<p>测试类</p>
<pre><code class="language-java">import cn.edu.bupt.config.MyConfig;
import cn.edu.bupt.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        // 如果完全使用了配置类方式取去做，我们只能通过 AnnotationConfig 上下文来获取容器，通过配置类的class对象加载！
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User getUser = (User) context.getBean(&quot;getUser&quot;);
        System.out.println(getUser.getName());
    }
}
</code></pre>
<p><strong>这种纯java的配置方式，在springboot中随处可见！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM初探]]></title>
        <id>https://chase-don.github.io/post/jvm-chu-tan/</id>
        <link href="https://chase-don.github.io/post/jvm-chu-tan/">
        </link>
        <updated>2020-12-29T10:37:30.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>请你谈谈对JVM的理解   java-&gt; .class -&gt; jvm</li>
<li>java8虚拟机和之前的变化更新？</li>
<li>JVM常用调优参数有哪些</li>
<li>内存快照如何抓取，怎么分析Dump文件？</li>
<li>关于类加载器的认识？</li>
</ul>
<h2 id="1-jvm的位置">1. JVM的位置</h2>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/1616409703634.png" alt="" loading="lazy"></figure>
<h2 id="2-jvm的体系结构">2. JVM的体系结构</h2>
<p>整体框架图：<br>
<img src="https://chase-don.github.io//post-images/1616409803998.png" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/1616409849946.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/1616409885966.png" alt="" loading="lazy"></figure>
<h2 id="3-类加载器">3. 类加载器</h2>
<p>​	作用： 加载class文件</p>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/1616409910791.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>虚拟机自带的加载器</p>
</li>
<li>
<p>启动类(根)加载器</p>
</li>
<li>
<p>扩展类加载器</p>
</li>
<li>
<p>应用程序(系统类)加载器</p>
</li>
<li>
<p><strong>百度双亲委派机制</strong></p>
</li>
</ol>
<h2 id="4-native重点">4. Native（重点）</h2>
<pre><code class="language-java">public static void main(String[] args) {
    new Thread(() -&gt; {}, &quot;my thread name&quot;).start();
}

// native：凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库！
//会进入本地方法栈，本地方法栈调用本地方法接口(JNI, java native interface)
//JNI的作用：扩展java的使用，融合不同的编程语言为Java所用  最初：C,C++
//Java诞生的时候，C/C++横行，要立足就必须要有调用C/C++的程序
//它在内存区域中专门开辟了一块标记区域： Native Method Stack，登记Native方法
//在最终执行的时候，通过JNI加载本地方法库中的方法
private native void start0();
</code></pre>
<h2 id="5-方法区method-area">5. 方法区（Method Area）</h2>
<p>​	方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，<strong>所有定义的方法的信息都保存在该区域，此区域属于共享区间</strong></p>
<p>​	<mark><strong>静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是，实例变量存在堆内存中，和方法区无关</strong></mark>  （static、final、Class、常量池）</p>
<p>​		注意：jdk1.7以后，常量池逻辑上属于方法区，实际存放在堆中</p>
<h2 id="6-栈">6. 栈</h2>
<p>栈：栈内存，主管程序的运行，生命周期和线程同步；</p>
<p>线程结束，栈内存就释放，对于栈来说，<strong>不会存在垃圾回收问题</strong></p>
<p>一旦线程结束，栈就over！</p>
<p><mark><strong>栈：8种基本类型 + 对象引用 + 实例方法</strong></mark></p>
<p>栈运行原理：<strong>栈帧</strong><br>
<img src="https://chase-don.github.io//post-images/1616409937018.png" alt="" loading="lazy"></p>
<ul>
<li>栈 +堆+方法区：交互关系</li>
</ul>
<p>画出一个对象在内存中实例化的过程</p>
<h2 id="7-堆">7. 堆</h2>
<h3 id="71heap一个jvm只有一个堆内存堆内存的大小是可以调节的">7.1Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</h3>
<h3 id="72类加载器读取了类文件后一般会把什么东西放到堆中">7.2类加载器读取了类文件后，一般会把什么东西放到堆中？</h3>
<p><strong>类，方法，常量，变量等，保存我们所有引用类型的真实对象（实例）</strong></p>
<h3 id="73-堆内存中还要细分为三个区域">7.3 堆内存中还要细分为三个区域：</h3>
<ul>
<li>新生区（伊甸园区） Young/New</li>
<li>养老区  Old</li>
<li>永久区  Perm  (现在被元空间取代，自己查证一下)</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/1616409953115.png" alt="" loading="lazy"></figure>
<p>GC垃圾回收：<strong><mark>主要是在伊甸园区和养老区</mark></strong></p>
<p>假设内存满了，<strong>OOM(OutOfMemory)</strong>，堆内存不够！</p>
<p>在jdk1.8以后，永久存储区改了个名字 ---&gt;  <mark><strong>元空间</strong></mark></p>
<h4 id="731-新生区">7.3.1 新生区</h4>
<ul>
<li>一个类诞生和成长的地方，甚至死亡；能在新生区活下来就能进入养老区（老年区）</li>
<li>新生区分为两个区：伊甸园区和幸存者区（0,1）
<ul>
<li>所有的对象都是在 伊甸园区 new出来的</li>
<li>经过研究，99%的对象都是临时对象！</li>
<li><strong>过程：伊甸园区满了进行一次轻gc，没被回收的进入幸存者区；经过n次循环后，幸存区满了，整个新生区都爆满进行一次重gc，幸存下来的可以进入养老区，养老区满后会出现OOM</strong></li>
</ul>
</li>
</ul>
<h4 id="732-老年区略">7.3.2 老年区（略）</h4>
<h4 id="733-永久区">7.3.3 永久区</h4>
<p>这个区域常驻于内存中。用于存放JDK自身携带的Class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，**这个区域不存在垃圾回收！**关闭虚拟机就会释放这个区域的内存。</p>
<p>一个启动类，加载了大量的第三方jar包；Tomcat部署了太多的应用；大量动态生成的反射类，不断地被加载，直到内存满，就会出现OOM。</p>
<ul>
<li>jdk1.6之前： 永久代，常量池是在方法区；</li>
<li>jdk1.7：永久代，但是慢慢退化了，提出<strong>去永久代</strong>，常量池在堆中</li>
<li>jdk1.8后： 无永久代，<strong>常量池在元空间</strong><br>
<img src="https://chase-don.github.io//post-images/1616409973816.png" alt="" loading="lazy"><br>
元空间：逻辑上存在，物理上不存在（具体可见Demo02）</li>
</ul>
<p><mark><strong>出现OOM故障时的方法:</strong></mark></p>
<ol>
<li>
<p>尝试扩大堆内存看结果</p>
</li>
<li>
<p>分析内存，看一下哪个地方出了问题（专业工具）</p>
<p>​	a. 能够看到代码第几行出错：内存快照分析工具，<strong>eclipse（MAT）,现常用（Jprofiler）</strong><br>
​    b. Debug，一行行分析代码</p>
</li>
</ol>
<p><strong>MAT,Jprofiler作用：</strong></p>
<ul>
<li>分析Dump文件，快速定位内存泄漏；</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
<li>.....(百度)</li>
</ul>
<h2 id="8-gc-垃圾回收">8. GC: 垃圾回收</h2>
<ol>
<li>
<p><strong>垃圾回收的主要区域是：堆和方法区</strong></p>
</li>
<li>
<p>JVM在进行GC时，并不是对堆中（伊甸园区，幸存区[from,to]，老年区）这三个区域统一回收。大部分时 候，回收都是新生代！</p>
</li>
<li>
<p>GC两种类：轻GC（普通GC）和重GC（全局GC）</p>
</li>
</ol>
<p>GC相关题目：</p>
<ul>
<li>JVM的内存模型和分区？详细到每个区放什么？</li>
<li>堆里面的分区有哪些？ Eden，from，to，老年区。 说说他们的特点？</li>
<li>常用的GC算法有哪些？<mark><strong>标记清除法/标记整理(压缩)法/复制算法/引用计数法</strong></mark>      怎么用的？</li>
<li>轻GC 和 重GC 分别在什么时候发生？</li>
</ul>
<h3 id="81-引用计数法">8.1 引用计数法</h3>
<p>原理：此对象有一个引用，则+1；删除一个引用，则-1。只用收集计数为0的对象。<br>
缺点：无法处理循环引用的问题。如：对象A和B分别有字段b、a，令A.b=B和B.a=A，除此之外这2个对象再无任何引用，那实际上这2个对象已经不可能再被访问，但是引用计数算法却无法回收他们。</p>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/1616409987072.png" alt="" loading="lazy"></figure>
<h3 id="82-复制算法">8.2 复制算法</h3>
<p><img src="https://chase-don.github.io//post-images/1616410002661.png" alt="" loading="lazy"><br>
<img src="https://chase-don.github.io//post-images/1616410009388.png" alt="" loading="lazy"></p>
<ul>
<li>好处：没有内存的碎片</li>
<li>坏处：浪费了内存空间，幸存区有一般空间永远是空（To）</li>
</ul>
<p><mark><strong>复制算法最佳使用场景：对象存活度较低的 ---&gt; 新生区</strong></mark></p>
<h3 id="83-标记清除算法">8.3 标记清除算法</h3>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/1616410018504.png" alt="" loading="lazy"></figure>
<ul>
<li>优点：不需要额外的空间！</li>
<li>缺点：两次扫描严重浪费时间；会产生内存碎片</li>
</ul>
<h3 id="84-标记压缩法">8.4 标记压缩法</h3>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/1616410025234.png" alt="" loading="lazy"></figure>
<p><strong>优化方式： 先标记清除几次，再进行压缩</strong></p>
<h3 id="85-总结">8.5 总结</h3>
<p>内存效率： 复制算法 &gt; 标记清除算法 &gt; 标记压缩算法（时间复杂度）</p>
<p>内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法</p>
<p>内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法</p>
<p>思考：有没有最优算法？</p>
<p>答案：没有，没有最好的算法，只有最合适的   ---&gt;   <mark><strong>GC：分代收集算法</strong></mark></p>
<p><strong>分代收集算法：</strong></p>
<p><strong>年轻代：存活率低 ---&gt; 复制算法</strong></p>
<p><strong>老年代：区域大；存活率高 ---&gt; 标记清除 + 标记压缩混合实现（即清楚几次压缩一次）</strong></p>
<h2 id="9-jmmjava-memory-modeljava内存模型">9. JMM：Java Memory Model（Java内存模型）</h2>
<ol>
<li>
<p>什么是JMM?</p>
</li>
<li>
<p>它是用来干嘛的？</p>
<p>作用：缓存一致性协议，用于定义数据读写的规则</p>
</li>
<li>
<p>它该如何学习？</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://chase-don.github.io/post/hello-gridea/</id>
        <link href="https://chase-don.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>