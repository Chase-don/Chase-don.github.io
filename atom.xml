<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chase-don.github.io/</id>
    <title>Loro</title>
    <updated>2021-05-10T17:03:23.507Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chase-don.github.io/"/>
    <link rel="self" href="https://chase-don.github.io/atom.xml"/>
    <subtitle>表现不俗</subtitle>
    <logo>https://chase-don.github.io/images/avatar.png</logo>
    <icon>https://chase-don.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Loro</rights>
    <entry>
        <title type="html"><![CDATA[Redis入门（上）]]></title>
        <id>https://chase-don.github.io/post/redis-ru-men-shang/</id>
        <link href="https://chase-don.github.io/post/redis-ru-men-shang/">
        </link>
        <updated>2021-04-11T14:12:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-nosql简介">1. NoSql简介</h2>
<h3 id="11-有什么作用">1.1 有什么作用？</h3>
<p>主要可用：<strong><mark>（减少cpu和io压力，通过内存读取以及作为缓存数据库，减少io读操作）</mark></strong></p>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210502183814449.png" alt="image-20210502183814449" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210502183823144.png" alt="image-20210502183823144" loading="lazy"></figure>
<h3 id="12-什么是nosql">1.2 什么是NoSql</h3>
<p>NoSQL(NoSQL = <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。</p>
<p>NoSQL 不依赖业务逻辑方式存储，而以简单的<mark>key-value</mark>模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>
<p>不遵循SQL标准。</p>
</li>
<li>
<p>不支持ACID。  ---&gt;   <strong>这里只是不支持ACID四个特性，不等于不支持事务！</strong></p>
</li>
<li>
<p>远超于SQL的性能。</p>
</li>
</ul>
<h3 id="13-nosql的相关使用场景">1.3 Nosql的相关使用场景</h3>
<h4 id="131-nosql适用场景"><strong>1.3.1.</strong>  NoSQL适用场景</h4>
<ol>
<li>
<p><strong>对数据高并发的读写 （秒杀功能）</strong></p>
</li>
<li>
<p><strong>海量数据的读写</strong></p>
</li>
<li>
<p><strong>对数据高可扩展性的</strong></p>
</li>
</ol>
<h4 id="132-nosql不适用场景"><strong>1.3.2.</strong>  <strong>NoSQL</strong>不适用场景</h4>
<ol>
<li>
<p>需要事务支持</p>
</li>
<li>
<p>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
</li>
<li>
<p>（<strong>用不着sql的和用了sql也不行的情况，请考虑用NoSql</strong>）</p>
</li>
</ol>
<h2 id="2-redis概述"><strong>2.</strong>  <strong>Redis</strong>概述</h2>
<p>Ø Redis是一个<strong>开源的key-value</strong>存储系统。</p>
<p>Ø 和Memcached（支持类型单一，只能支持字符串）类似，它支持存储的value类型相对更多，包括<strong>string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</strong></p>
<p>Ø 这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且**<mark>这些操作都是原子性的</mark>**。</p>
<p>Ø 在此基础上，Redis支持各种不同方式的排序。</p>
<p>Ø 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p>Ø 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>Ø 并且在此基础上实现了master-slave(主从)同步。</p>
<h3 id="21-redis的应用场景">2.1 Redis的应用场景</h3>
<h4 id="211-配合关系型数据库做高速缓存">2.1.1 <strong>配合关系型数据库做高速缓存</strong></h4>
<ul>
<li>
<p>高频次，热门访问的数据，降低数据库IO</p>
</li>
<li>
<p>分布式架构，做session共享</p>
</li>
</ul>
<h4 id="212-多样的数据结构存储持久化数据">2.1.2 <strong>多样的数据结构存储持久化数据</strong></h4>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210502185353584.png" alt="image-20210502185353584" loading="lazy"></figure>
<h2 id="3-redis安装略">3. Redis安装（略）</h2>
<h3 id="31-后台登录在usrlocalbin下执行">3.1 后台登录：（在/usr/local/bin下执行）</h3>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210502203013686.png" alt="image-20210502203013686" loading="lazy"></figure>
<p>通过宝塔下载redis，可以直接在<code>/www/server/redis</code>下执行前后台命令</p>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210502204522393.png" alt="image-20210502204522393" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/image-20210502204814673.png" alt="image-20210502204814673" loading="lazy"></figure>
<h3 id="32-测试性能redis-benchmark">3.2 测试性能（redis-benchmark）</h3>
<p>redis-benchmark是一个压力测试工具</p>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210502210716077.png" alt="image-20210502210716077" loading="lazy"></figure>
<p>做个测试：（100个并发连接  100000个请求）</p>
<pre><code class="language-bash">redis-benchmark -h localhost -p 6379 -c 100 -n 100000
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210502211115433.png" alt="image-20210502211115433" loading="lazy"></figure>
<blockquote>
<p>如何查看这些分析？</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210502211726337.png" alt="image-20210502211726337" loading="lazy"></figure>
<h2 id="4-redis基础知识">4. Redis基础知识</h2>
<h3 id="41-redis默认有16个数据库编号为0-15默认使用第0个用select来切换数据库">4.1 Redis<strong>默认有16个数据库，编号为0-15</strong>，默认使用第0个；用<code>select</code>来切换数据库</h3>
<figure data-type="image" tabindex="10"><img src="https://chase-don.github.io//post-images/image-20210502212709893.png" alt="image-20210502212709893" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://chase-don.github.io//post-images/image-20210502213149095.png" alt="image-20210502213149095" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://chase-don.github.io//post-images/image-20210502213304143.png" alt="image-20210502213304143" loading="lazy"></figure>
<pre><code class="language-bash"># 查看所有的key
127.0.0.1:6379[3]&gt; keys *
1) &quot;name&quot;
</code></pre>
<h3 id="42-清空数据库flushdb-和-flushall">4.2 清空数据库（<code>flushdb</code>  和 <code>flushall</code>）</h3>
<pre><code class="language-bash"># 清除当前数据库
127.0.0.1:6379[3]&gt; flushdb
OK

# 清空全部数据库
127.0.0.1:6379[3]&gt; flushall
OK
</code></pre>
<h3 id="43-redis与memcache的不同">4.3 Redis与Memcache的不同:</h3>
<ul>
<li>Redis支持多数据类型，Memcache支持单一数据类型（字符型）</li>
<li>redis支持持久化，memcache不支持</li>
<li><strong><mark>redis是单线程+多路IO复用，memcache是多线程+锁</mark></strong></li>
</ul>
<h2 id="5-五大常用数据类型类型指的都是value的类型">5. 五大常用数据类型（类型指的都是value的类型）</h2>
<h3 id="51-关于redis键key的基本命令">5.1 关于Redis键（key）的基本命令</h3>
<blockquote>
<p>**keys <em>： 查看当前库所有key  (匹配：keys <em>1)</em></em></p>
<p><strong>exists key： 判断某个key是否存在</strong></p>
<p><strong>type key：  查看你的key是什么类型</strong></p>
<p><strong>del key  ：  删除指定的key数据</strong></p>
<p><mark><strong>unlink key ： 根据value选择非阻塞删除</strong></mark>，（仅将keys从keyspace元数据中删除，真正的删除会在后续<strong>异步</strong>操作）。</p>
<p><mark><strong>expire key 10  ：10秒钟，为给定的key设置过期时间</strong></mark>，<strong><mark>过期后的键便不再存在</mark></strong></p>
<p><strong>ttl key ： 查看还有多少秒过期，-1表示永不过期，-2表示已过期</strong></p>
<figure data-type="image" tabindex="13"><img src="https://chase-don.github.io//post-images/image-20210502235550183.png" alt="image-20210502235550183" loading="lazy"></figure>
<p>select ：命令切换数据库</p>
<p>dbsize ：查看当前数据库的key的数量</p>
<p>flushdb ：清空当前库</p>
<p>flushall ：清空全部库</p>
</blockquote>
<h3 id="52-字符串string">5.2 字符串String</h3>
<h4 id="521-简介">5.2.1 简介</h4>
<ol>
<li>
<p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，<strong>一个key对应一个value</strong>。</p>
</li>
<li>
<p>String类型是**<mark>二进制安全的</mark><strong>。意味着Redis的string</strong>可以包含任何数据。比如jpg图片或者序列化的对象**。</p>
</li>
<li>
<p>String类型是Redis最基本的数据类型，一个Redis中**<mark>字符串value最多可以是512M</mark>**</p>
</li>
</ol>
<h4 id="522-常用命令">5.2.2 常用命令</h4>
<blockquote>
<p><strong>set  <key><value> ： 添加键值对，如果键已经存在，则进行覆盖</strong></p>
<p>*NX：当数据库中key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get  <key> ： 查询对应键值</p>
<p>append <key><value> ： 将给定的<value> 追加到原值的末尾，类似stringbuffer的append操作</p>
<p>strlen <key> ： 获得值的长度</p>
<p><strong>setnx <key><value> ： 只有在 key 不存在时  设置 key 的值</strong></p>
</blockquote>
<blockquote>
<p><strong>incr <key></strong></p>
<p>​		将 key 中储存的数字值增1，<strong><mark>存储的一定要是数字类型</mark></strong>，<strong>下面的k1就不是数字类型，所以没法进行操作</strong></p>
<p>​		只能对数字值操作，如果为空，新增值为1</p>
<figure data-type="image" tabindex="14"><img src="https://chase-don.github.io//post-images/image-20210503002632591.png" alt="image-20210503002632591" loading="lazy"></figure>
<p><strong>decr <key></strong></p>
<p>​		将 key 中储存的数字值减1</p>
<p>​		只能对数字值操作，如果为空，新增值为-1</p>
<p><strong>incrby / decrby <key>&lt;步长&gt;</strong> ： 将 key 中储存的数字值增减。自定义步长。</p>
<figure data-type="image" tabindex="15"><img src="https://chase-don.github.io//post-images/image-20210503002524836.png" alt="image-20210503002524836" loading="lazy"></figure>
</blockquote>
<p><strong>补充关于原子性：</strong></p>
<img src="file://D:/博客源文件/post-images/image-20210503002905082.png" alt="image-20210503002905082" style="zoom:150%;" />
<p>所谓<strong>原子</strong>操作是指不会被线程调度机制打断的操作；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>
<p>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中断只能发生于指令之间。</p>
<p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
<p><mark><strong>Redis单命令的原子性主要得益于Redis的单线程</strong>。</mark></p>
<blockquote>
<p><strong>mset <key1><value1><key2><value2> .....</strong></p>
<p>​		作用：同时设置一个或多个 key-value对</p>
<p>mget <key1><key2><key3> .....</p>
<p>​		作用：同时获取一个或多个 value</p>
<p><strong><mark>msetnx <key1><value1><key2><value2> .....</mark></strong>   ----&gt;   <strong>是个原子性操作！</strong></p>
<p>​		作用：<strong>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</strong><mark><strong>原子性，有一个失败则都失败</strong></mark></p>
<figure data-type="image" tabindex="16"><img src="https://chase-don.github.io//post-images/image-20210503004706188.png" alt="image-20210503004706188" loading="lazy"></figure>
<p>getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;</p>
<p>​		作用：获得值的范围，类似java中的substring，<mark><strong>前包，后包</strong></mark></p>
<figure data-type="image" tabindex="17"><img src="https://chase-don.github.io//post-images/image-20210503004924760.png" alt="image-20210503004924760" loading="lazy"></figure>
<p>setrange <key>&lt;起始位置&gt;<value></p>
<p>​		作用：用 <value> <strong><mark>覆写</mark></strong><key>所储存的字符串值，从&lt;起始位置&gt;开始(<strong>索引从0开始</strong>)。</p>
<figure data-type="image" tabindex="18"><img src="https://chase-don.github.io//post-images/image-20210503005237818.png" alt="image-20210503005237818" loading="lazy"></figure>
<p><strong><mark>setex <key>&lt;过期时间&gt;<value></mark></strong></p>
<p>​		作用：设置键值的同时，设置过期时间，单位秒。</p>
<figure data-type="image" tabindex="19"><img src="https://chase-don.github.io//post-images/image-20210504012519929.png" alt="image-20210504012519929" loading="lazy"></figure>
<p>getset <key><value></p>
<p>​		作用：以新换旧，设置了新值同时获得旧值。</p>
<figure data-type="image" tabindex="20"><img src="https://chase-don.github.io//post-images/image-20210504012652550.png" alt="image-20210504012652550" loading="lazy"></figure>
</blockquote>
<h3 id="53-列表list">5.3 列表（List）</h3>
<h4 id="531-简介">5.3.1 简介</h4>
<p>特点：<mark><strong>单键多值</strong></mark></p>
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的<strong>底层实际是个双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<figure data-type="image" tabindex="21"><img src="https://chase-don.github.io//post-images/image-20210504013032198.png" alt="image-20210504013032198" loading="lazy"></figure>
<h4 id="532-常用命令">5.3.2 常用命令</h4>
<blockquote>
<p>**lpush/rpush <key><value1><value2><value3> .... **</p>
<p>​		作用：<strong>从左边/右边插入一个或多个值。</strong></p>
<p><strong>lpop/rpop <key></strong></p>
<p>​		作用：<strong>从左边/右边吐出一个值。值在键在，值光键亡。</strong></p>
<figure data-type="image" tabindex="22"><img src="https://chase-don.github.io//post-images/image-20210504014658580.png" alt="image-20210504014658580" loading="lazy"></figure>
<p><strong>rpoplpush <key1><key2></strong></p>
<p>​		作用：<strong>从<key1>列表右边吐出一个值，插到<key2>列表左边。</strong></p>
<figure data-type="image" tabindex="23"><img src="https://chase-don.github.io//post-images/image-20210504151612570.png" alt="image-20210504151612570" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>lrange <key><start><stop></strong></p>
<p>​		作用：<strong>按照索引下标获得元素(从左到右)</strong></p>
<p><strong><mark>lrange <key> 0 -1</mark></strong> 	 <strong><mark>0左边第一个，-1右边第一个，（0-1表示获取所有）</mark></strong></p>
<p><strong>lindex <key><index></strong></p>
<p>​		作用：<strong>按照索引下标获得元素(从左到右)</strong></p>
<p><strong>llen <key></strong></p>
<p>​		作用：<strong>获得列表长度</strong></p>
<figure data-type="image" tabindex="24"><img src="https://chase-don.github.io//post-images/image-20210504161346137.png" alt="image-20210504161346137" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>linsert <key> <mark>before/after</mark> <value><newvalue></strong></p>
<p>​		作用：<strong>在<value>的前面/后面插入<newvalue>插入值</strong></p>
<figure data-type="image" tabindex="25"><img src="https://chase-don.github.io//post-images/image-20210504162503408.png" alt="image-20210504162503408" loading="lazy"></figure>
<p><strong>lrem <key><n><value></strong></p>
<p>​		作用：<strong>从左边<mark>删除n个value</mark>(从左到右)</strong>,value是相同的值</p>
<p><strong>lset<key><index><value></strong></p>
<p>​		作用：<strong>将列表key下标为index的值替换成value</strong>，替换操作</p>
</blockquote>
<h4 id="533-数据结构">5.3.3 数据结构</h4>
<p>List的数据结构为**<mark>快速链表quickList</mark>**。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个**<mark>结构是ziplist</mark>**，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p>
<figure data-type="image" tabindex="26"><img src="https://chase-don.github.io//post-images/image-20210504163342735.png" alt="image-20210504163342735" loading="lazy"></figure>
<p><strong>Redis将链表和ziplist结合起来组成了quicklist</strong>。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h3 id="54-集合set">5.4 集合（Set）</h3>
<h4 id="541-简介">5.4.1 简介</h4>
<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>
<p>Redis的Set是string类型的<strong>无序集合</strong>。它**<mark>底层其实是一个value为null的hash表</mark><strong>，所以添加，删除，查找的</strong>复杂度都是O(1)**。</p>
<h4 id="542-常用命令">5.4.2 常用命令</h4>
<blockquote>
<p><strong>sadd <key><value1><value2> .....</strong></p>
<p>​		作用：<strong>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</strong></p>
<p><strong>smembers <key></strong></p>
<p>​		作用：<strong>取出该集合的所有值。</strong></p>
<p><strong>sismember <key><value></strong></p>
<p>​		作用：<strong>判断集合<key>是否为含有该<value>值，有1，没有0</strong></p>
<p><strong>scard<key></strong></p>
<p>​		作用：<strong>返回该集合的元素个数。</strong></p>
<p><strong>srem <key><value1><value2> ....</strong></p>
<p>​		作用：<strong>删除集合中的某个元素。</strong></p>
<p><strong>spop <key></strong></p>
<p>​		作用：<strong>随机从该集合中吐出一个值。</strong></p>
<figure data-type="image" tabindex="27"><img src="https://chase-don.github.io//post-images/image-20210504165124570.png" alt="image-20210504165124570" loading="lazy"></figure>
<p><strong>srandmember <key><n></strong></p>
<p>​		作用：<strong>随机从该集合中取出n个值。不会从集合中删除 。</strong></p>
<figure data-type="image" tabindex="28"><img src="https://chase-don.github.io//post-images/image-20210504165438159.png" alt="image-20210504165438159" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>smove <source><destination>value</strong></p>
<p>​		作用：<strong>把集合中一个值从一个集合移动到另一个集合</strong></p>
<p><strong>sinter <key1><key2></strong></p>
<p>​		作用：<strong>返回两个集合的交集元素。</strong></p>
<p><strong>sunion <key1><key2></strong></p>
<p>​		作用：<strong>返回两个集合的并集元素。</strong></p>
<p><strong>sdiff <key1><key2></strong></p>
<p>​		作用：<strong>返回两个集合的<mark>差集元素</mark>(key1中的，不包含key2中的)</strong></p>
<figure data-type="image" tabindex="29"><img src="https://chase-don.github.io//post-images/image-20210504170330011.png" alt="image-20210504170330011" loading="lazy"></figure>
</blockquote>
<h3 id="55-哈希hash">5.5 哈希（Hash）</h3>
<h4 id="551-简介">5.5.1 简介</h4>
<p>Redis hash 是一个<strong>键值对集合</strong>。</p>
<p>Redis hash是<strong>一个<mark>string类型的field和value的映射表</mark>，hash特别<mark>适合用于存储对象</mark></strong>。</p>
<p>类似Java里面的Map&lt;String,Object&gt;</p>
<p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p>
<p>主要有以下2种存储方式：</p>
<figure data-type="image" tabindex="30"><img src="https://chase-don.github.io//post-images/image-20210504171115254.png" alt="image-20210504171115254" loading="lazy"></figure>
<h4 id="552-常用命令">5.5.2 常用命令</h4>
<blockquote>
<p><strong>hset <key><field><value></strong></p>
<p>​		作用：<strong>给<key>集合中的 <field>键赋值<value></strong></p>
<p><strong>hget <key1><field></strong></p>
<p>​		作用：<strong>从<key1>集合<field>取出 value</strong></p>
<p>**hmset <key1><field1><value1><field2><value2>... **</p>
<p>​		作用：<strong>批量设置hash的值</strong></p>
<p><strong>hexists<key1><field></strong></p>
<p>​		作用：<strong>查看哈希表 key 中，给定域 field 是否存在。</strong></p>
<p><strong>hkeys <key></strong></p>
<p>​		作用：<strong>列出该hash集合的所有field</strong></p>
<p><strong>hvals <key></strong></p>
<p>​		作用：<strong>列出该hash集合的所有value</strong></p>
<figure data-type="image" tabindex="31"><img src="https://chase-don.github.io//post-images/image-20210504174449971.png" alt="image-20210504174449971" loading="lazy"></figure>
</blockquote>
<blockquote>
<p><strong>hincrby <key><field><increment></strong></p>
<p>​		作用：<strong>为哈希表 key 中的域 field 的值加上增量 1  -1</strong></p>
<p><strong>hsetnx <key><field><value></strong></p>
<p>​		作用：<strong>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</strong></p>
<p><strong>hdel <key> <field> [<field>...]</strong></p>
<p>​		作用：<strong>将哈希表 key 中的域 field 删除，对应的value也一并删除.</strong></p>
<figure data-type="image" tabindex="32"><img src="https://chase-don.github.io//post-images/image-20210504180124190.png" alt="image-20210504180124190" loading="lazy"></figure>
</blockquote>
<h4 id="553-数据结构">5.5.3 数据结构</h4>
<p>Hash类型对应的数据结构是两种：<strong>ziplist（压缩列表），hashtable（哈希表）</strong>。当**<mark>field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</mark>**</p>
<h3 id="56-有序集合zset">5.6 有序集合（Zset）</h3>
<h4 id="561-简介">5.6.1 简介</h4>
<p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个==<strong>评分（score）</strong><mark>,这个评分（score）被用来按照</mark><strong>从最低分到最高分的方式排序</strong>==集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p>
<p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p>
<h4 id="562-常用命令">5.6.2 常用命令</h4>
<blockquote>
<p><strong>zadd <key> <score1> <value1> <score2> <value2>…</strong></p>
<p>​		作用：<strong>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</strong></p>
</blockquote>
<blockquote>
<p><strong>zincrby <key> <increment> <value></strong></p>
<p>​		作用：<strong>为元素的score加上增量</strong></p>
<p><strong>zrem <key><value></strong></p>
<p>​		作用：<strong>删除该集合下，指定值的元素</strong></p>
<p><strong>zcount <key><min><max></strong></p>
<p>​		作用：<strong>统计该集合，分数区间内的元素个数</strong></p>
<p><strong>zrank <key><value></strong></p>
<p>​		作用：<strong>返回该值在集合中的排名，从0开始（分数从小到大，要想倒排加一个<mark>rev</mark>）。</strong></p>
<figure data-type="image" tabindex="33"><img src="https://chase-don.github.io//post-images/image-20210504201553537.png" alt="image-20210504201553537" loading="lazy"></figure>
</blockquote>
<p><strong>案例：如何利用zset实现一个文章访问量的排行榜？</strong></p>
<figure data-type="image" tabindex="34"><img src="https://chase-don.github.io//post-images/image-20210504201757848.png" alt="image-20210504201757848" loading="lazy"></figure>
<h4 id="563-数据结构">5.6.3 数据结构</h4>
<p>**SortedSet(zset)**是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p>
<p><strong>zset底层使用了两个数据结构：</strong></p>
<p>（1）<strong>hash</strong>，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p>
<p>（2）<strong>跳跃表</strong>，跳跃表的<mark>目的在于给元素value排序，根据score的范围获取元素列表</mark>。</p>
<h4 id="564-跳跃表跳表时间复杂度为ologn">5.6.4 跳跃表（跳表），时间复杂度为O(logN)</h4>
<p>1、简介</p>
<pre><code>	有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。**==Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。==**
</code></pre>
<p>2、实例</p>
<p>对比有序链表和跳跃表，从链表中查询出51</p>
<p>（1）  有序链表</p>
<figure data-type="image" tabindex="35"><img src="https://chase-don.github.io//post-images/image-20210504204720518.png" alt="image-20210504204720518" loading="lazy"></figure>
<p>​	要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p>
<p>（2）  跳跃表</p>
<figure data-type="image" tabindex="36"><img src="https://chase-don.github.io//post-images/image-20210504204729525.png" alt="image-20210504204729525" loading="lazy"></figure>
<p>从第2层开始，1节点比51节点小，向后比较。21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层；</p>
<p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下；</p>
<p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>
<h2 id="6-redis的发布和订阅">6. Redis的发布和订阅</h2>
<h3 id="61-什么是发布和订阅">6.1 什么是发布和订阅</h3>
<ul>
<li>
<p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</li>
<li>
<p>Redis <strong>客户端可以订阅任意数量的频道</strong>。</p>
</li>
</ul>
<h3 id="62-redis的发布和订阅">6.2  <strong>Redis</strong>的发布和订阅</h3>
<p>1、客户端可以订阅频道如下图（客户端也收不到未订阅频道发送的消息）</p>
<img src="file://D:/博客源文件/post-images/image-20210504210530217.png" alt="image-20210504210530217" style="zoom:150%;" />
<p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<img src="file://D:/博客源文件/post-images/image-20210504210536308.png" alt="image-20210504210536308" style="zoom:150%;" />
<h3 id="63-发布订阅命令行实现">6.3 发布订阅命令行实现</h3>
<ol>
<li>
<p>打开一个客户端订阅channel1</p>
<p>subscribe channel1</p>
<figure data-type="image" tabindex="37"><img src="https://chase-don.github.io//post-images/image-20210504211232877.png" alt="image-20210504211232877" loading="lazy"></figure>
</li>
<li>
<p>打开另一个客户端，给channel1发布消息hello</p>
<figure data-type="image" tabindex="38"><img src="https://chase-don.github.io//post-images/image-20210504211431397.png" alt="image-20210504211431397" loading="lazy"></figure>
<p><strong><mark>返回的1是订阅者数量</mark></strong></p>
</li>
<li>
<p>打开第一个客户端可以看到发送的消息</p>
<figure data-type="image" tabindex="39"><img src="https://chase-don.github.io//post-images/image-20210504211517258.png" alt="image-20210504211517258" loading="lazy"></figure>
</li>
</ol>
<h3 id="64-原理">6.4 原理</h3>
<figure data-type="image" tabindex="40"><img src="https://chase-don.github.io//post-images/image-20210504214837935.png" alt="image-20210504214837935" loading="lazy"></figure>
<figure data-type="image" tabindex="41"><img src="https://chase-don.github.io//post-images/image-20210504214508100.png" alt="image-20210504214508100" loading="lazy"></figure>
<p><strong>使用场景：</strong></p>
<ol>
<li>实时消息系统</li>
<li>实时聊天（频道当做聊天室， 将信息回显给所有人即可）</li>
<li>订阅/关注系统</li>
</ol>
<h2 id="7-redis新数据类型">7. Redis新数据类型</h2>
<h3 id="71-bitmaps-位图场景详解可以做每日签到">7.1 Bitmaps 位图场景详解（可以做每日签到）</h3>
<h4 id="711-简介">7.1.1 简介</h4>
<p>现代计算机用二进制（位） 作为信息的基础单位，<strong>1个字节等于8位</strong>， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p>
<figure data-type="image" tabindex="42"><img src="https://chase-don.github.io//post-images/image-20210508234244015.png" alt="image-20210508234244015" loading="lazy"></figure>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<p>（1）  Bitmaps**<mark>本身不是一种数据类型， 实际上它就是字符串（key-value）</mark>** ， 但是它<strong>可以对字符串的位进行操作</strong>。</p>
<p>（2）  Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<figure data-type="image" tabindex="43"><img src="https://chase-don.github.io//post-images/image-20210508234326611.png" alt="image-20210508234326611" loading="lazy"></figure>
<h4 id="712-常用命令">7.1.2 常用命令</h4>
<h5 id="1-setbit">1. setbit</h5>
<p>（1）格式</p>
<p><strong>setbit <key> <offset> <value></strong></p>
<p>​		作用：<strong>设置Bitmaps中某个偏移量的值（0或1）</strong>  ，<strong><mark>offset:偏移量从0开始</mark></strong></p>
<p>（2）实例</p>
<p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p>
<p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，<strong>userid=1， 6， 11， 15， 19的用户对网站进行了访问</strong>， 那么当前Bitmaps初始化结果如图</p>
<figure data-type="image" tabindex="44"><img src="https://chase-don.github.io//post-images/image-20210508235241850.png" alt="image-20210508235241850" loading="lazy"></figure>
<figure data-type="image" tabindex="45"><img src="https://chase-don.github.io//post-images/image-20210508235749900.png" alt="image-20210508235749900" loading="lazy"></figure>
<p><strong><mark>注意：</mark></strong></p>
<p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， <strong>通常的做法是每次做setbit操作时将用户id减去这个指定数字</strong>。</p>
<p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<h5 id="2-getbit">2. getbit</h5>
<p>（1）格式</p>
<p><strong>getbit <key> <offset></strong></p>
<p>​		作用：<strong>获取Bitmaps中某个偏移量的值； 获取键的第offset位的值（从0开始算）</strong></p>
<p>（2）实例</p>
<figure data-type="image" tabindex="46"><img src="https://chase-don.github.io//post-images/image-20210509000423533.png" alt="image-20210509000423533" loading="lazy"></figure>
<h5 id="3-bitcount">3. bitcount</h5>
<p>统计==<strong>字符串</strong>==被设置为1的bit数。</p>
<p>一般情况下，给定的整个字符串都会被进行计数；**通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。**start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p>
<p><strong><mark>start和end代表起始和结束字节数（注意是字节数！！！！！！！不是偏移量！！！八位一个字节！！！！）</mark></strong></p>
<figure data-type="image" tabindex="47"><img src="https://chase-don.github.io//post-images/image-20210509003219810.png" alt="image-20210509003219810" loading="lazy"></figure>
<h5 id="4-bitop">4. bitop</h5>
<p>(1)格式</p>
<p><strong>bitop and(or/not/xor) <destkey> [key…]</strong></p>
<p>​		作用：<strong>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</strong></p>
<p>(2)实例</p>
<p>2020-11-04 日访问网站的userid=1,2,5,9。</p>
<p>setbit unique:users:20201104 1 1</p>
<p>setbit unique:users:20201104 2 1</p>
<p>setbit unique:users:20201104 5 1</p>
<p>setbit unique:users:20201104 9 1</p>
<p>2020-11-03 日访问网站的userid=0,1,4,9。</p>
<p>setbit unique:users:20201103 0 1</p>
<p>setbit unique:users:20201103 1 1</p>
<p>setbit unique:users:20201103 4 1</p>
<p>setbit unique:users:20201103 9 1</p>
<p>计算出两天都访问过网站的用户数量</p>
<pre><code class="language-bsah">bitop and unique:users:and:20201104_03 unique:users:20201103 unique:users:20201104
</code></pre>
<img src="file://D:/博客源文件/post-images/image-20210509003938585.png" alt="image-20210509003938585" style="zoom:150%;" />
<img src="file://D:/博客源文件/post-images/image-20210509003945828.png" alt="image-20210509003945828" style="zoom:150%;" />
<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p>
<img src="file://D:/博客源文件/post-images/image-20210509004017666.png" alt="image-20210509004017666" style="zoom:150%;" />
<h3 id="72-geospatial-地理位置详解">7.2 Geospatial 地理位置详解</h3>
<h4 id="721-简介">7.2.1 简介</h4>
<p>​	Redis 3.2 中增加了对GEO类型的支持。<strong>GEO，Geographic，地理信息的缩写</strong>。该类型，就是**<mark>元素的2维坐标，在地图上就是经纬度</mark><strong>。redis基于该类型，提供了</strong>经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作**。</p>
<h4 id="722-常用命令6个">7.2.2 常用命令（6个）</h4>
<blockquote>
<p><strong>geoadd<key>&lt; longitude&gt;<latitude><member> [longitude latitude member...]</strong></p>
<p>​		作用：<strong>添加地理位置（经度，纬度，名称）</strong>，已经添加的数据，是无法再次往里面添加的。</p>
<figure data-type="image" tabindex="48"><img src="https://chase-don.github.io//post-images/image-20210508212906638.png" alt="image-20210508212906638" loading="lazy"></figure>
<p><strong>geopos <key><member> [member...]</strong></p>
<p>​		作用：<strong>获得指定地区的坐标值</strong></p>
<figure data-type="image" tabindex="49"><img src="https://chase-don.github.io//post-images/image-20210508213737013.png" alt="image-20210508213737013" loading="lazy"></figure>
<p>**geodist<key><member1><member2> [m|km|ft|mi ] **</p>
<p>​		作用：<strong>获取两个位置之间的直线距离</strong></p>
<p>​		<strong>单位：</strong></p>
<p>​		<strong>m 表示单位为米==[默认值]==。</strong></p>
<p>​		<strong>km 表示单位为千米。</strong></p>
<p>​		<strong>mi 表示单位为英里。</strong></p>
<p>​		<strong>ft 表示单位为英尺。</strong></p>
<p>​		<strong>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</strong></p>
<figure data-type="image" tabindex="50"><img src="https://chase-don.github.io//post-images/image-20210508215454565.png" alt="image-20210508215454565" loading="lazy"></figure>
<p>**georadius<key>&lt; longitude&gt;<latitude>radius m|km|ft|mi  **  （经度  纬度  半径  单位）</p>
<p>​		作用：<strong><mark>以给定的经纬度为中心，找出某一半径内的元素</mark></strong></p>
<figure data-type="image" tabindex="51"><img src="https://chase-don.github.io//post-images/image-20210508215903656.png" alt="image-20210508215903656" loading="lazy"></figure>
<figure data-type="image" tabindex="52"><img src="https://chase-don.github.io//post-images/image-20210508220838698.png" alt="image-20210508220838698" loading="lazy"></figure>
<p>**georadiusbymember <key> &lt; member&gt; radius m|km|ft|mi  **</p>
<p>​		作用：<strong><mark>以给定的成员（元素）为中心，找出某一半径内的元素</mark></strong></p>
<figure data-type="image" tabindex="53"><img src="https://chase-don.github.io//post-images/image-20210508221019884.png" alt="image-20210508221019884" loading="lazy"></figure>
<p><strong>geohash <key> &lt; member&gt;</strong></p>
<p>​		作用：<strong>返回一个或多个元素的Geohash表示</strong>   <strong><mark>（不常用）</mark></strong></p>
</blockquote>
<h3 id="73-hyperloglog-基数统计适用于查看访问量">7.3 <strong>HyperLogLog</strong> 基数统计(适用于查看访问量)</h3>
<blockquote>
<h4 id="什么是基数"><strong>什么是基数?</strong></h4>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
</blockquote>
<h4 id="731-简介">7.3.1 简介</h4>
<p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像<strong>UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数</strong>等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p>
<p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p>
<p>Redis推出了HyperLogLog用来做基数统计的算法，<strong>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</strong></p>
<p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而**<mark>不会储存输入元素本身</mark>**，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<h4 id="732-常用命令">7.3.2 常用命令</h4>
<blockquote>
<p>**pfadd <key>&lt; element&gt; [element ...]  **</p>
<p>​		作用：<strong>添加指定元素到 HyperLogLog 中</strong></p>
<p>**pfcount<key> [key ...] **</p>
<p>​		作用：<strong>计算key的近似基数，可以计算多个key，比如用key存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</strong></p>
<p>**pfmerge<destkey><sourcekey> [sourcekey ...] **</p>
<p>​		作用：<strong>将一个或多个key合并后的结果存储在另一个key中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</strong></p>
<figure data-type="image" tabindex="54"><img src="https://chase-don.github.io//post-images/image-20210509010754469.png" alt="image-20210509010754469" loading="lazy"></figure>
</blockquote>
<h2 id="8-jedis">8. Jedis</h2>
<h3 id="81-jedis测试">8.1 Jedis测试</h3>
<ol>
<li>
<p>创建测试程序</p>
<pre><code class="language-java">public class JedisDemo1 {
    public static void main(String[] args) {

        //创建Jedis对象
        Jedis jedis = new Jedis(&quot;121.40.180.27&quot;, 6379);

        //测试
        String value = jedis.ping();
        System.out.println(value);

    }
}
</code></pre>
</li>
<li>
<p>测试相关数据类型（5大数据类型）（略）</p>
</li>
</ol>
<h3 id="82-jedis实例完成一个手机验证码功能">8.2 Jedis实例（<strong>完成一个手机验证码功能</strong>）</h3>
<p>要求：</p>
<p>1、输入手机号，点击发送后随机生成6位数字码，2分钟有效</p>
<p>2、输入验证码，点击验证，返回成功或失败</p>
<p>3、每个手机号每天只能输入3次</p>
<figure data-type="image" tabindex="55"><img src="https://chase-don.github.io//post-images/image-20210509161238058.png" alt="image-20210509161238058" loading="lazy"></figure>
<pre><code class="language-java">public class phoneCode {
    public static void main(String[] args) {
        //模拟验证码的发送
        verifyCode(&quot;18252027696&quot;);
//        getRedisCode(&quot;18252027696&quot; ,&quot;045104&quot;);
    }


    //1. 生成6位数字验证码
    public static String getCode() {
        Random random = new Random();
        String code = &quot;&quot;;
        for (int i = 0; i &lt; 6; i++) {
            int rand = random.nextInt(10);
            code += rand;
        }
        return code;
    }

    //2. 每个手机每天只能发送三次，验证码放到redis中codeKey
    public static void verifyCode(String phone) {
        //连接redis
        Jedis jedis = new Jedis(&quot;121.40.180.27&quot;, 6379);

        //拼接key
        //手机发送次数key
        String countKey = &quot;VerifyCode&quot; + phone + &quot;:count&quot;;
        //验证码key
        String codeKey = &quot;VerifyCode&quot; + phone + &quot;:code&quot;;

        //每个手机每天只能发送三次
        String count = jedis.get(countKey);
        if (count == null) {
            //没有发送次数，第一次发送
            //设置发送次数为1
            jedis.setex(countKey, 24 * 60 * 60, &quot;1&quot;);
        } else if (Integer.parseInt(count) &lt;= 2) {
            //发送次数+1
            jedis.incr(countKey);
        } else if (Integer.parseInt(count) &gt; 2) {
            //发送三次及以上，不能再进行发送了
            System.out.println(&quot;今天发送次数已经超过三次，不能再发送了&quot;);
            jedis.close();
        }

        //发送的验证码放到redis里面
        String vcode = getCode();
        jedis.setex(codeKey, 120, vcode);
        jedis.close();
    }


    //3. 验证码校验
    public static void getRedisCode(String phone, String code) {
        //从redis获取验证码
        Jedis jedis = new Jedis(&quot;121.40.180.27&quot;, 6379);
        //验证key
        String codeKey = &quot;VerifyCode&quot; + phone + &quot;:code&quot;;
        String redisCode = jedis.get(codeKey);
        //判断
        if (redisCode.equals(code)) {
            System.out.println(&quot;成功&quot;);
        } else {
            System.out.println(&quot;失败&quot;);
        }
        jedis.close();
    }
}
</code></pre>
<h2 id="9-redis事务和锁机制">9. Redis事务和锁机制</h2>
<h3 id="91-redis的事务定义">9.1 redis的事务定义</h3>
<p>Redis事务是**<mark>一个单独的隔离操作</mark>**：<strong>事务中的所有命令都会序列化、按顺序地执行</strong>。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的<strong>主要作用</strong>就是**<mark>串联多个命令防止别的命令插队</mark>**。</p>
<h3 id="92-multi-exec-discard">9.2 <strong>Multi</strong>、Exec、discard</h3>
<p>从<strong>输入Multi命令</strong>开始，输入的命令都会<strong>依次进入命令队列中</strong>，但不会执行；</p>
<p>直到<strong>输入Exec后</strong>，Redis会<strong>将之前的命令队列中的命令依次执行</strong>；</p>
<p><strong><mark>组队的过程中</mark><strong>可以</strong>通过discard来放弃组队</strong>。</p>
<figure data-type="image" tabindex="56"><img src="https://chase-don.github.io//post-images/image-20210509191159066.png" alt="image-20210509191159066" loading="lazy"></figure>
<figure data-type="image" tabindex="57"><img src="https://chase-don.github.io//post-images/image-20210509191843477.png" alt="image-20210509191843477" loading="lazy"></figure>
<figure data-type="image" tabindex="58"><img src="https://chase-don.github.io//post-images/image-20210509192048587.png" alt="image-20210509192048587" loading="lazy"></figure>
<h3 id="93-事务的错误处理两种情况">9.3 事务的错误处理（两种情况）</h3>
<h4 id="931-组队中某个命令出现了报告错误">9.3.1 组队中某个命令出现了报告错误</h4>
<figure data-type="image" tabindex="59"><img src="https://chase-don.github.io//post-images/image-20210509192359890.png" alt="image-20210509192359890" loading="lazy"></figure>
<p><strong><mark>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</mark></strong></p>
<figure data-type="image" tabindex="60"><img src="https://chase-don.github.io//post-images/image-20210509192811780.png" alt="image-20210509192811780" loading="lazy"></figure>
<h4 id="932-执行阶段某个命令报出了错误">9.3.2 执行阶段某个命令报出了错误</h4>
<figure data-type="image" tabindex="61"><img src="https://chase-don.github.io//post-images/image-20210509192435465.png" alt="image-20210509192435465" loading="lazy"></figure>
<p><strong><mark>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</mark></strong></p>
<figure data-type="image" tabindex="62"><img src="https://chase-don.github.io//post-images/image-20210509193440670.png" alt="image-20210509193440670" loading="lazy"></figure>
<h3 id="94-事务的冲突问题">9.4 事务的冲突问题</h3>
<h4 id="941-悲观锁">9.4.1 悲观锁</h4>
<img src="file://D:/博客源文件/post-images/image-20210509205136994.png" alt="image-20210509205136994" style="zoom:150%;" />
<p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<h4 id="942-乐观锁">9.4.2 乐观锁</h4>
 <img src="file://D:/博客源文件/post-images/image-20210509205308731.png" alt="image-20210509205308731" style="zoom:150%;" />
<p><strong>乐观锁(Optimistic Lock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p>
<h4 id="943-乐观锁的使用watch-key">9.4.3 乐观锁的使用（watch <key>）</h4>
<blockquote>
<h4 id="在执行multi之前先执行watch-key1-key2可以监视一个或多个-key-如果在事务执行之前这个或这些-key-被其他命令所改动那么事务将被打断">在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果<mark>在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断</mark>。</h4>
</blockquote>
<p>客户端1：</p>
<figure data-type="image" tabindex="63"><img src="https://chase-don.github.io//post-images/image-20210509221604378.png" alt="image-20210509221604378" loading="lazy"></figure>
<p>客户端2：</p>
<figure data-type="image" tabindex="64"><img src="https://chase-don.github.io//post-images/image-20210509222008089.png" alt="image-20210509222008089" loading="lazy"></figure>
<h3 id="95-redis事务的三大特性">9.5 <mark>redis事务的三大特性</mark></h3>
<ul>
<li>
<p><strong>单独的隔离操作</strong></p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li>
<p><strong>没有隔离级别的概念</strong></p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</p>
</li>
<li>
<p><strong>不保证原子性</strong></p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>
</li>
</ul>
<h2 id="10-redis事务案例-秒杀">10. Redis事务案例---秒杀</h2>
<img src="file://D:/博客源文件/post-images/image-20210509222449181.png" alt="image-20210509222449181" style="zoom:150%;" />
<p>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</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx入门学习]]></title>
        <id>https://chase-don.github.io/post/nginx-ru-men-xue-xi/</id>
        <link href="https://chase-don.github.io/post/nginx-ru-men-xue-xi/">
        </link>
        <updated>2021-03-04T03:32:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-nginx简介">1. nginx简介</h2>
<h3 id="11-什么是-nginx">1.1 什么是 nginx</h3>
<p>Nginx 是<strong>高性能的 HTTP 和反向代理的服务器</strong>，占用内存少，<strong>处理高并发能力</strong>是十分强大的，能经受高负<br>
载的考验,有报告表明能支持高达 50,000 个并发连接数。</p>
<p>（高性能的http和反向代理的服务器，能够处理高并发，并发能力强）</p>
<h3 id="12-正向代理">1.2 正向代理</h3>
<p>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。</p>
<p>正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。</p>
<ul>
<li>在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问</li>
</ul>
<img src="file://D:/博客源文件/post-images/image-20210429165758184.png" alt="image-20210429165758184" style="zoom:67%;" />
<h3 id="13-反向代理">1.3 反向代理</h3>
<p>反向代理，其实客户端对代理是无感知的，因为<strong>客户端不需要任何配置就可以访问</strong>，我们只需要将请求发送到反向代理服务器， 由反向代理服务器去选择目标服务器获取数据后， 在返回给客户端， 此时反向代理服务器和目标服务器对外就是一个服务器， 暴露的是代理服务器地址，隐藏了真实服务器 IP 地址</p>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210429171022707.png" alt="image-20210429171022707" loading="lazy"></figure>
<h3 id="14-负载均衡">1.4 负载均衡</h3>
<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一， 并发请求相对较少的情况下是比较适合的， 成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。</p>
<p>单个服务器解决不了，我们<strong>增加服务器的数量，然后将请求分发到各个服务器上</strong>，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上， 将负载分发到不同的服务器， 也就是我们所说的 <strong><mark>负载均衡</mark></strong></p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210429172519757.png" alt="image-20210429172519757" loading="lazy"></figure>
<h3 id="15-动静分离">1.5 动静分离</h3>
<p>为了加快网站的解析速度， 可以<strong>把动态页面和静态页面由不同的服务器来解析</strong>， 加快解析速度。降低原来单个服务器的压力。</p>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210429234826407.png" alt="image-20210429234826407" loading="lazy"></figure>
<h2 id="2-nginx安装">2. nginx安装</h2>
<p>安装在了<code>/www/server/nginx/sbin</code></p>
<p><strong>启动并查看进程：</strong></p>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210430005808050.png" alt="image-20210430005808050" loading="lazy"></figure>
<h2 id="3-nginx操作的常用命令">3. Nginx操作的常用命令</h2>
<ol>
<li>
<p><strong>使用nginx操作命令前提条件：必须进入nginx的目录  ---&gt;  <code>/www/server/nginx/sbin</code></strong></p>
</li>
<li>
<p>查看版本号</p>
<p>​	<mark><strong>./nginx -v</strong></mark></p>
</li>
<li>
<p>启动nginx</p>
<p>​	<strong><mark>./nginx</mark></strong></p>
</li>
<li>
<p>关闭nginx</p>
<p>​	<mark><strong>./nginx -s stop</strong></mark></p>
</li>
<li>
<p>重新加载nginx</p>
<p>​	./nginx -s reload</p>
</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210430012726573.png" alt="image-20210430012726573" loading="lazy"></figure>
<h2 id="4-nginx配置文件">4. Nginx配置文件</h2>
<pre><code class="language-nginx">user  www www;
worker_processes 1;
error_log  /www/wwwlogs/nginx_error.log  crit;
pid        /www/server/nginx/logs/nginx.pid;
worker_rlimit_nofile 51200;

events
    {
        use epoll;
        worker_connections 51200;
        multi_accept on;
    }

http
    {
        include       mime.types;
		#include luawaf.conf;

		include proxy.conf;

        default_type  application/octet-stream;

        server_names_hash_bucket_size 512;
        client_header_buffer_size 32k;
        large_client_header_buffers 4 32k;
        client_max_body_size 50m;

        sendfile   on;
        tcp_nopush on;

        keepalive_timeout 60;

        tcp_nodelay on;

        fastcgi_connect_timeout 300;
        fastcgi_send_timeout 300;
        fastcgi_read_timeout 300;
        fastcgi_buffer_size 64k;
        fastcgi_buffers 4 64k;
        fastcgi_busy_buffers_size 128k;
        fastcgi_temp_file_write_size 256k;
		fastcgi_intercept_errors on;

        gzip on;
        gzip_min_length  1k;
        gzip_buffers     4 16k;
        gzip_http_version 1.1;
        gzip_comp_level 2;
        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;
        gzip_vary on;
        gzip_proxied   expired no-cache no-store private auth;
        gzip_disable   &quot;MSIE [1-6]\.&quot;;

        limit_conn_zone $binary_remote_addr zone=perip:10m;
		limit_conn_zone $server_name zone=perserver:10m;

        server_tokens off;
        access_log off;

    server
        {
            listen 888;
            server_name phpmyadmin;
            index index.html index.htm index.php;
            root  /www/server/phpmyadmin;
    
            #error_page   404   /404.html;
            include enable-php.conf;
    
            location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$
            {
                expires      30d;
            }
    
            location ~ .*\.(js|css)?$
            {
                expires      12h;
            }
    
            location ~ /\.
            {
                deny all;
            }
    
            access_log  /www/wwwlogs/access.log;
        }
    include /www/server/panel/vhost/nginx/*.conf;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JUC]]></title>
        <id>https://chase-don.github.io/post/juc/</id>
        <link href="https://chase-don.github.io/post/juc/">
        </link>
        <updated>2021-02-28T16:10:49.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="1-基本知识">1. 基本知识</h2>
<h3 id="11-线程的状态">1.1 线程的状态</h3>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210323173019251.png" alt="image-20210323173019251" loading="lazy"></figure>
<h3 id="12-关于死锁">1.2 关于死锁</h3>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210324222406709.png" alt="image-20210324222406709" loading="lazy"></figure>
<h3 id="13-lock锁">1.3 Lock（锁）</h3>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210324222826766.png" alt="image-20210324222826766" loading="lazy"></figure>
<h2 id="2-进程和线程">2. 进程和线程</h2>
<blockquote>
<p>线程、进程是重点！！</p>
</blockquote>
<h3 id="21-进程程序的一个执行过程">2.1 进程：程序的一个执行过程</h3>
<p>一个进程包含多个线程，至少包含一个！Java默认有两个线程：main，gc</p>
<h3 id="22-线程">2.2 线程</h3>
<p>开了一个线程Typora，写字，自动保存（线程负责的）</p>
<p>对于Java而言，创建线程的方法：Thread，Runnable，Callable</p>
<p><strong>Java真的可以开启线程吗？</strong>  ---&gt;  开不了：原因是start0调用的是本地方法，底层的Cpp，Java无法直接操作硬件</p>
<h3 id="23-并发和并行">2.3 并发和并行</h3>
<p>并发（多线程操作同一资源）</p>
<ul>
<li>CPU一核，模拟出来多条线程，快速交替</li>
</ul>
<p>并行（多个人一起走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行</li>
</ul>
<pre><code class="language-java">public class Test{
    public static void main(String[] args){
        //获取CPU核数
        //CPU密集型 ， IO密集型
        System.out.println(Runtime.getRuntime().availableProcessors());
    }
}
</code></pre>
<p>并发编程本质：<strong>充分利用CPU资源</strong></p>
<h3 id="24-线程的状态6种">2.4 线程的状态：（6种）</h3>
<ul>
<li>新生（NEW）</li>
<li>运行(RUNNABLE)</li>
<li>阻塞(BLOCKED)</li>
<li>等待(WAITING)</li>
<li>超时等待(TIMED_WAITING)</li>
<li>死亡(TERMINATED)</li>
</ul>
<h3 id="25-wait和sleep的区别常考">2.5 wait和sleep的区别（常考！！！！）</h3>
<ol>
<li><strong>来自不同的类：</strong>
<ul>
<li>wait来自Object类</li>
<li>sleep来自Thread类</li>
</ul>
</li>
<li><strong>关于锁的释放：</strong>
<ul>
<li>wait会释放锁</li>
<li>sleep不会释放锁（sleep抱着锁睡觉）</li>
</ul>
</li>
<li><strong>使用的范围是不同的：</strong>
<ul>
<li>wait：必须在同步代码块中</li>
<li>sleep：可以在任何地方使用(任何地方睡)</li>
</ul>
</li>
<li>是否需要捕获异常
<ul>
<li>wait不需要捕获异常</li>
<li>sleep必须要捕获异常</li>
</ul>
</li>
</ol>
<h2 id="3lock很重点">3.Lock（很重点）</h2>
<h3 id="31-synchronized">3.1 Synchronized</h3>
<pre><code class="language-java">//基本的卖票例子

/**
 * 真正的多线程开发，即公司的开发中： 降低耦合性
 * 线程就是 一个单独的资源类，没有任何附属的操作！
 * 1. 属性、方法
 */
public class SaleTicketDemo01 {
    public static void main(String[] args) {
        //并发：多个线程操作同一个资源类
        Ticket ticket = new Ticket();

        new Thread(() -&gt; {
            for (int i = 0; i &lt; 60; i++) {
                ticket.sale();
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 60; i++) {
                ticket.sale();
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt; {
            for (int i = 0; i &lt; 60; i++) {
                ticket.sale();
            }
        }, &quot;C&quot;).start();
    }
}


//资源类 OOP
class Ticket {
    //属性、方法
    private int number = 50;

    //卖票的方式
    //synchronized 本质：锁，排队
    public synchronized void sale() {
        if (number &gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot;卖出了&quot; + (number--) + &quot;票，剩余：&quot; + number);
        }
    }
}
</code></pre>
<h3 id="32-lock接口">3.2 Lock接口</h3>
<blockquote>
<p>Lock lock = new ...();</p>
<p><strong>lock.lock();   加锁</strong></p>
<p>try{}</p>
<p>finally{<strong>lock.unock();</strong>}  解锁</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210330020220846.png" alt="image-20210330020220846" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210330021027380.png" alt="image-20210330021027380" loading="lazy"></figure>
<p>公平锁：十分公平 ---&gt; 先来后到</p>
<p><strong>非公平锁：十分不公平 ---&gt; 可以插队（默认）</strong></p>
<pre><code class="language-java">import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class SaleTicketDemo02 {
    public static void main(String[] args) {
        //并发：多个线程操作同一个资源类
        Ticket2 ticket = new Ticket2();

        new Thread(() -&gt; {for (int i = 0; i &lt; 60; i++) ticket.sale();}, &quot;A&quot;).start();
        new Thread(() -&gt; {for (int i = 0; i &lt; 60; i++) ticket.sale();}, &quot;B&quot;).start();
        new Thread(() -&gt; {for (int i = 0; i &lt; 60; i++) ticket.sale();}, &quot;C&quot;).start();

    }    
}

/**
 * Lock三部曲：
 * 1. new ReentrantLock();
 * 2. lock.lock(); // 加锁
 * 3. finally =&gt; lock.unlock(); //解锁
 */
//用Lock锁
class Ticket2 {
    //属性、方法
    private int number = 50;

    Lock lock = new ReentrantLock();

    //卖票的方式
    public void sale() {

        lock.lock();//加锁
        try {
            //业务代码
            if (number &gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot;卖出了&quot; + (number--) + &quot;票，剩余：&quot; + number);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h3 id="33-synchronized和lock的区别重点">3.3 Synchronized和Lock的区别(重点)</h3>
<ol>
<li>
<p>Synchronized是内置的java关键字，lock是一个java类（JUC）</p>
</li>
<li>
<p>Synchronized --&gt; 无法判断获取锁的状态</p>
<p>lock --&gt; 可以判断是否获取到了锁</p>
</li>
<li>
<p>Synchronized 会自动释放锁（a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁）</p>
<p>lock 必须要手动释放锁，<strong>如果不释放锁，会产生死锁！</strong></p>
</li>
<li>
<p>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，（<strong>lock.trylock()</strong>）如果尝试获取不到锁，线程可以不用一直等待就结束了</p>
</li>
<li>
<p>Synchronized：可重入锁，不可中断的，非公平的；</p>
<p>lock：可重入锁，可以判断锁，非公平（可以自己设置，默认非公平锁）</p>
</li>
<li>
<p>Synchronized：适合锁少量的代码同步问题</p>
<p>lock：适合锁大量的同步代码！</p>
</li>
</ol>
<h2 id="4-生产者和消费者问题">4. 生产者和消费者问题</h2>
<h3 id="41-sychronized版本">4.1 Sychronized版本</h3>
<pre><code class="language-java">/**
 * 线程之间的通信问题：生产者和消费者问题！   wait、notify
 *
 * 线程交替进行  A B  操作同一个变量  num = 0
 * A ---&gt; num+1
 * B ---&gt; num-1
 */
public class Test {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();
    }
}

// 判断等待 --&gt; 业务 --&gt; 通知
class Data {  //数字 资源类
    private int num = 0;

    // +1
    public synchronized void increment() throws InterruptedException {
        if (num != 0) {
            //等待
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我+1完毕了
        this.notifyAll();
    }

    // -1
    public synchronized void decrement() throws InterruptedException {
        if (num == 0) {
            //等待
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我-1完毕了
        this.notifyAll();
    }
}
</code></pre>
<blockquote>
<p>问题存在：例子是A,B两个线程，当存在四个或者八个线程的话，是否还安全？  -----&gt;   <strong>答案：不安全！！！</strong></p>
<p>解决办法：  <mark><strong>if改为while</strong></mark></p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/image-20210330034712720.png" alt="image-20210330034712720" loading="lazy"></figure>
<pre><code class="language-java">//防止虚假唤醒的代码
public class Test {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;C&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;D&quot;).start();
    }
}

// 判断等待 --&gt; 业务 --&gt; 通知
class Data {  //数字 资源类
    private int num = 0;

    // +1
    public synchronized void increment() throws InterruptedException {
        while (num != 0) {
            //等待
            this.wait();
        }
        num++;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我+1完毕了
        this.notifyAll();
    }

    // -1
    public synchronized void decrement() throws InterruptedException {
        while (num == 0) {
            //等待
            this.wait();
        }
        num--;
        System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
        //通知其他线程，我-1完毕了
        this.notifyAll();
    }
}
</code></pre>
<h3 id="42-juc版本的生产者与消费问题lock">4.2 JUC版本的生产者与消费问题（Lock）</h3>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210330144331403.png" alt="image-20210330144331403" loading="lazy"></figure>
<p><mark><strong>通过Lock找到Condition，Condition可以理解成一个同步监视器</strong></mark></p>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210330144231750.png" alt="image-20210330144231750" loading="lazy"></figure>
<p>代码实现：(LOCK)</p>
<pre><code class="language-java">public class TestLock {
    public static void main(String[] args) {
        Data2 data = new Data2();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;A&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;B&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;C&quot;).start();

        new Thread(()-&gt;{
            for (int i = 0; i &lt; 10; i++) {
                try {
                    data.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;D&quot;).start();

    }
}

// 判断等待 --&gt; 业务 --&gt; 通知
class Data2 {  //数字 资源类
    private int num = 0;

    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    // +1
    public void increment() throws InterruptedException {
        lock.lock();
        try {
            while (num != 0) {
                //等待
                condition.await(); //等待
            }
            num++;
            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
            //通知其他线程，我+1完毕了
            condition.signalAll(); //唤醒全部
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    // -1
    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            while (num == 0) {
                //等待
                condition.await();
            }
            num--;
            System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + num);
            //通知其他线程，我-1完毕了
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h4 id="421condition可以精准的通知和唤醒线程相比于wait和notify的优势">4.2.1<strong>Condition可以精准的通知和唤醒线程！</strong>（相比于wait和notify的优势）</h4>
<p>代码如下：</p>
<pre><code class="language-java">public class TestCondition {

    public static void main(String[] args) {

        Data3 data = new Data3();

        new Thread(() -&gt;{
            for (int i = 0; i &lt; 10; i++) {
                data.printA();
            }
        }, &quot;A&quot;).start();
        new Thread(() -&gt;{
            for (int i = 0; i &lt; 10; i++) {
                data.printB();
            }
        }, &quot;B&quot;).start();
        new Thread(() -&gt;{
            for (int i = 0; i &lt; 10; i++) {
                data.printC();
            }
        }, &quot;C&quot;).start();

    }
}

class Data3 { //资源类
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int num = 1; // 1A 2B 3C

    public void printA() {
        lock.lock();

        try {
            //业务，  判断 =&gt; 执行 =&gt; 通知
            while (num != 1) {
                //等待
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; AAAAA&quot;);
            //唤醒 --&gt; 唤醒指定的人(B)
            num = 2;
            condition2.signal();  //精准唤醒！
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printB() {
        lock.lock();

        try {
            //业务，  判断 =&gt; 执行 =&gt; 通知
            while (num != 2) {
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; BBBBB&quot;);
            //唤醒
            num = 3;
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void printC() {
        lock.lock();

        try {
            //业务，  判断 =&gt; 执行 =&gt; 通知
            while (num != 3) {
                //等待
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + &quot;=&gt; CCCCC&quot;);
            //唤醒
            num = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h2 id="5-8锁现象就是关于锁的八个问题">5. 8锁现象(就是关于锁的八个问题)</h2>
<p>如何判断锁的是谁！永远的知道什么锁，以及锁到底锁的是谁</p>
<pre><code class="language-java">/**
 * 8锁，就是关于锁的8个问题
 * 1. 标准情况下，两个线程先打印 发短信还是打电话？   ---&gt; 发短信 再 打电话
 * 2. sendSms延迟四秒，两个线程先打印 发短信还是打电话？   ---&gt; 发短信 再 打电话
 */
public class Test1 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(()-&gt;{
            phone.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone.call();
        }, &quot;B&quot;).start();

    }
}


class Phone {
    // synchronized 锁的对象是方法的调用者！
    // 两个方法用的是同一个锁，谁先拿到谁执行！
    public synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 3. 增加了一个普通方法后，两个线程，是先发短信还是先hello   ----&gt;    先hello（普通方法） 再 发短信
 * 4. 增加一个对象，两个对象，两个同步方法， 发短信还是打电话？   ---&gt;   打电话  再  发短信
 */
public class Test2 {
    public static void main(String[] args) {
        //两个对象 ，即两个调用者，两把锁
        Phone2 phone1 = new Phone2();
        Phone2 phone2 = new Phone2();

        new Thread(()-&gt;{
            phone1.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone2.call();
        }, &quot;B&quot;).start();

    }
}


class Phone2 {
    // synchronized 锁的对象是方法的调用者！
    // 两个方法用的是同一个锁，谁先拿到谁执行！
    public synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }

    //这里没有锁，不是同步方法，不受锁的影响
    public void hello() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 5.增加两个静态的同步方法，只有一个对象，先打印哪个？
 * 6. 两个对象的话呢？ 增加两个静态的同步方法，只有一个对象，先打印哪个？
 */
public class Test3 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个，static：锁的是class
        Phone3 phone1 = new Phone3();
        Phone3 phone2 = new Phone3();

        new Thread(()-&gt;{
            phone1.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone2.call();
        }, &quot;B&quot;).start();

    }
}


//phone3 唯一一个 Class 对象！！
class Phone3 {
    // synchronized 锁的对象是方法的调用者！
    // static  静态方法
    // 类一加载就有了！ 锁的是 Class
    public static synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    public static synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<pre><code class="language-java">/**
 * 7. 一个静态的同步方法，一个普通的同步方法，一个对象。那么，先打印发短信还是打电话  （先打电话再发短信）
 * 8. 一个静态的同步方法，一个普通的同步方法，两个对象。同样的还是先电话后短信（一个是对象锁一个是类锁）
 */
public class Test4 {
    public static void main(String[] args) {
        //两个对象的Class类模板只有一个，static：锁的是class
        Phone4 phone = new Phone4();


        new Thread(()-&gt;{
            phone.sendSms();
        }, &quot;A&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()-&gt;{
            phone.call();
        }, &quot;B&quot;).start();

    }
}



class Phone4 {
    // 静态的同步方法 这里锁的是 Class类
    public static synchronized void sendSms() {
        try {
            TimeUnit.SECONDS.sleep(4);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;发短信&quot;);
    }

    //普通的同步方法  这里锁的是 对象，方法的调用者
    public synchronized void call() {
        System.out.println(&quot;打电话&quot;);
    }
}
</code></pre>
<blockquote>
<p>小结：</p>
<p>new ：this  具体一个对象，一个手机</p>
<p><strong>static：Class唯一一个模板</strong></p>
</blockquote>
<h2 id="6-集合类不安全">6. 集合类不安全</h2>
<h3 id="61-list不安全">6.1 List不安全</h3>
<blockquote>
<p>CopyOnWrite 写入时复制！   是属于COW：计算机程序设计领域的一种优化策略<br>
多个线程调用的时候，即list，读取的时候是固定的，但写入容易造成覆盖操作<br>
在写入的时候避免覆盖，造成数据问题<br>
读写分离<br>
<mark><strong>CopyOnWriteArrayList 比 Vector 好在哪？ 一个是lock锁一个是synchronized锁</strong></mark></p>
</blockquote>
<pre><code class="language-java">解决方案：
	1. List&lt;String&gt; list = new Vector&lt;&gt;();
	2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
	3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
</code></pre>
<pre><code class="language-java">//java.util.ConcurrentModificationException 并发修改异常
public class ListTest {
    public static void main(String[] args) {
        //并发下 ArrayList不安全！
        /**
         * 解决方案：
         * 1. List&lt;String&gt; list = new Vector&lt;&gt;();
         * 2. List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
         * 3. List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
         */
        // CopyOnWrite 写入时复制！   是属于COW：计算机程序设计领域的一种优化策略
        // 多个线程调用的时候，即list，读取的时候是固定的，但写入容易造成覆盖操作
        // 在写入的时候避免覆盖，造成数据问题
        // 读写分离
        // CopyOnWriteArray
        List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();

        for (int i = 1; i &lt;= 10; i++) {
            new Thread(() -&gt; {
                list.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(Thread.currentThread().getName() + list);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<h3 id="62-set不安全">6.2 Set不安全</h3>
<pre><code class="language-java">package cn.edu.bupt.unsafeList;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * 同理可证：java.util.ConcurrentModificationException
 * 解决方法：
 * 1. Vector()
 * 2. Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
 * 3. Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();
 */
public class SetTest {
    public static void main(String[] args) {
//        Set&lt;String&gt; set = new HashSet&lt;&gt;();
//        Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
        Set&lt;String&gt; set = new CopyOnWriteArraySet&lt;&gt;();

        for (int i = 1; i &lt;= 50; i++) {
            new Thread(() -&gt; {
                set.add(UUID.randomUUID().toString().substring(0, 5));
                System.out.println(Thread.currentThread().getName() + set);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<blockquote>
<p>hashset底层是什么？</p>
<pre><code class="language-java">public HashSet() {
	map = new HashMap&lt;&gt;();
}

//add set本质就是map  key是不可重复的所以set的值就是key传入
public boolean add(E e) {
	return map.put(e, PRESENT)==null;
}
</code></pre>
</blockquote>
<h3 id="63-hashmap不安全">6.3 HashMap不安全</h3>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210331145154571.png" alt="image-20210331145154571" loading="lazy"></figure>
<pre><code class="language-java">public class MapTest {
    public static void main(String[] args) {
        //研究ConcurrentHashMap的原理
        Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
        //  加载因子（0.75）  初始化容量（16）

        for (int i = 1; i &lt;= 30; i++) {
            new Thread(() -&gt; {
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 5));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<blockquote>
<p>研究ConcurrenrtHashMap的原理！（源码）</p>
</blockquote>
<h2 id="7-callable简单">7. Callable（简单）</h2>
<ol>
<li>可以有返回值</li>
<li>可以抛出异常</li>
<li>方法不同，用的是call()方法</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://chase-don.github.io//post-images/image-20210331151347117.png" alt="image-20210331151347117" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://chase-don.github.io//post-images/image-20210331152237333.png" alt="image-20210331152237333" loading="lazy"></figure>
<pre><code class="language-java">public class CallableTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //new Thread(new Runnable()).start();
        //new Thread(new FutureTask()).start();
        //new Thread(new FutureTask( Callable )).start();
        new Thread().start(); //怎么启动Callable

        MyThread myThread = new MyThread();
        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(myThread);  //适配器

        new Thread(futureTask, &quot;A&quot;).start();
        new Thread(futureTask, &quot;B&quot;).start();  // 两个线程执行，结果还是一个call()。---&gt; 原因是结果会被缓存，效率高

        Integer integer = futureTask.get(); //这个get方法可能产生阻塞，把它放到最后面
        System.out.println(integer);
    }
}


class MyThread implements Callable&lt;Integer&gt; {

    @Override
    public Integer call() throws Exception {
        System.out.println(&quot;call()&quot;);
        //return是一个耗时的操作！
        return 1024;
    }
}
</code></pre>
<blockquote>
<p>细节：</p>
<ol>
<li>有缓存</li>
<li>结果可能需要等待，会阻塞！</li>
</ol>
</blockquote>
<h2 id="8-常用的辅助类必会">8. 常用的辅助类（必会）</h2>
<h3 id="81-countdownlatch">8.1 CountDownLatch</h3>
<figure data-type="image" tabindex="12"><img src="https://chase-don.github.io//post-images/image-20210331154522891.png" alt="image-20210331154522891" loading="lazy"></figure>
<pre><code class="language-java">// 计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        //总数是6，必须要执行任务的时候，再使用！
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i &lt;= 6; i++) {
            new Thread(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot; go out&quot;);
                countDownLatch.countDown(); //-1
            }, String.valueOf(i)).start();
        }

        //等待计数器归零，然后再向下执行
        countDownLatch.await();

        System.out.println(&quot;close door&quot;);
    }
}
</code></pre>
<blockquote>
<p>原理</p>
<p><mark><strong>countDownLatch.countDown();</strong></mark>    //数量-1</p>
<p><mark><strong>countDownLatch.await();</strong></mark>   //等待计数器归零，然后再向下执行</p>
<p>每次有线程调用countDown则数量减一，假设计数器变为0，countDownLatch.await()就会被唤醒，继续执行！</p>
</blockquote>
<h3 id="82-cyclicbarrier可以理解为加法计数器等待await指定个数线程执行完毕再执行操作">8.2 CyclicBarrier（可以理解为加法计数器，等待(await)指定个数线程执行完毕再执行操作）</h3>
<figure data-type="image" tabindex="13"><img src="https://chase-don.github.io//post-images/image-20210331162217137.png" alt="image-20210331162217137" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 集齐七颗龙珠召唤神龙
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {

        //召唤龙珠的线程
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; {
            System.out.println(&quot;召唤神龙成功&quot;);
        });

        for (int i = 1; i &lt;= 7; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                System.out.println(Thread.currentThread().getName() + &quot;收集&quot; + temp + &quot;个龙珠&quot;);
                try {
                    cyclicBarrier.await(); //等待（通过等待计数）
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
</code></pre>
<h3 id="83-semaphore同一时间只能有指定数量个得到线程">8.3 Semaphore（同一时间只能有指定数量个得到线程）</h3>
<p>Semaphore：信号量</p>
<figure data-type="image" tabindex="14"><img src="https://chase-don.github.io//post-images/image-20210331170128059.png" alt="image-20210331170128059" loading="lazy"></figure>
<pre><code class="language-java">public class SemaphoreDemo {
    public static void main(String[] args) {
        //参数是可用资源数量（允许运行的线程数量）  限流的时候使用
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i &lt;= 6; i++) {
            new Thread(() -&gt; {
                // acquire() 得到
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + &quot;抢到车位&quot;);
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName() + &quot;离开车位&quot;);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();  // release() 释放
                }
            }, String.valueOf(i)).start();
        }
    }
}
</code></pre>
<p>原理：</p>
<ol>
<li><strong>semaphore.acquire();</strong>   获得，假设如果已经满了，等待，等待被释放为止。（<strong>acquire(获取)当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等待下去，直到有线程释放信号量，或超时。</strong>）</li>
<li><strong>semaphore.release();</strong>    释放，会将当前的信号量释放，然后唤醒等待的资源（<strong>release(释放)实际上会将信号量的值加1，然后唤醒等待的线程</strong>）</li>
</ol>
<p><mark><strong>作用： 多个共享资源互斥使用；并发限流，控制最大线程数！</strong></mark></p>
<p>如果把资源数从3变成1了，此时就等价于synchronized。</p>
<h2 id="9-读写锁readwritelock">9. 读写锁（ReadWriteLock）</h2>
<figure data-type="image" tabindex="15"><img src="https://chase-don.github.io//post-images/image-20210331175409717.png" alt="image-20210331175409717" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 独占锁（写锁）  一次只能被一个线程占有
 * 共享锁（读锁）  多个线程可以同时占有
 * ReadWriteLock
 * 读 - 读    可以共存
 * 读 - 写    不可共存
 * 写 - 写    不可共存
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
//        MyCache myCache = new MyCache();

        MyCacheLock myCache = new MyCacheLock();
        //写入
        for (int i = 1; i &lt;= 5; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                myCache.put(temp + &quot;&quot;, temp + &quot;&quot;);
            }, String.valueOf(i)).start();
        }

        //读取
        for (int i = 1; i &lt;= 5; i++) {
            final int temp = i;
            new Thread(() -&gt; {
                myCache.get(temp + &quot;&quot;);
            }, String.valueOf(i)).start();
        }
    }

}


//自定义缓存
class MyCache{
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    //存，写入
    public void put(String key, Object value) {
        System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;);
    }

    //取，读
    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);
        Object o = map.get(key);
        System.out.println(Thread.currentThread().getName() + &quot;读取ok&quot;);
    }
}


//加锁缓存
class MyCacheLock{
    private volatile Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    //读写锁：更加细粒度的控制
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //存，写入的时候只希望同时只有一个线程写
    public void put(String key, Object value) {
        readWriteLock.writeLock().lock();

        try {
            System.out.println(Thread.currentThread().getName() + &quot;写入&quot; + key);
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + &quot;写入ok&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }

    //取，读，所有人都可以读
    public void get(String key) {
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot;读取&quot; + key);
            Object o = map.get(key);
            System.out.println(Thread.currentThread().getName() + &quot;读取ok&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readWriteLock.readLock().unlock();
        }
    }
}
</code></pre>
<p><strong>注意：</strong></p>
<ol>
<li><mark><strong>独占锁（写锁）  一次只能被一个线程占有</strong></mark></li>
<li><mark><strong>共享锁（读锁）  多个线程可以同时占有</strong></mark></li>
<li>读 - 读    可以共存<br>
读 - 写    不可共存<br>
写 - 写    不可共存</li>
</ol>
<h2 id="10-阻塞队列">10. 阻塞队列</h2>
<figure data-type="image" tabindex="16"><img src="https://chase-don.github.io//post-images/image-20210331201713368.png" alt="image-20210331201713368" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://chase-don.github.io//post-images/image-20210331202007280.png" alt="image-20210331202007280" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://chase-don.github.io//post-images/image-20210331210803109.png" alt="image-20210331210803109" loading="lazy"></figure>
<p><strong>什么情况下我们会使用阻塞队列：多线程并发处理，线程池。</strong></p>
<h3 id="101-学会使用阻塞队列四组api">10.1 学会使用阻塞队列（四组API）</h3>
<table>
<thead>
<tr>
<th>方式</th>
<th>抛出异常</th>
<th>不抛出异常，有返回值</th>
<th>阻塞 等待</th>
<th>超时等待</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加</td>
<td>add()</td>
<td>offer()</td>
<td>put()</td>
<td>offer(E e, long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(long timeout, TimeUnit unit)</td>
</tr>
<tr>
<td>查看队首</td>
<td>element()</td>
<td>peek()</td>
<td>/</td>
<td>/</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">    /**
     * 抛出异常
     */
    public static void test1() {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(arrayBlockingQueue.add(&quot;a&quot;));
        System.out.println(arrayBlockingQueue.add(&quot;b&quot;));
        System.out.println(arrayBlockingQueue.add(&quot;c&quot;));
        //java.lang.IllegalStateException: Queue full
        //System.out.println(arrayBlockingQueue.add(&quot;d&quot;));

        System.out.println(&quot;===========&quot;);

        System.out.println(arrayBlockingQueue.remove());
        System.out.println(arrayBlockingQueue.remove());
        System.out.println(arrayBlockingQueue.remove());
        //java.util.NoSuchElementException  抛出异常
        //System.out.println(arrayBlockingQueue.remove());
    }
}
</code></pre>
<pre><code class="language-java">    /**
     * 有返回值，不抛出异常
     */
    public static void test2() {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));
        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));
        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));
        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;));  //打印出false，不抛出异常！

        System.out.println(&quot;===============&quot;);
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());  //null  有返回值没有异常！
    }
</code></pre>
<pre><code class="language-java">    /**
     * 等待，阻塞（一直等待）
     */
    public static void test3() throws InterruptedException {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        //一直阻塞
        arrayBlockingQueue.put(&quot;a&quot;);
        arrayBlockingQueue.put(&quot;b&quot;);
        arrayBlockingQueue.put(&quot;c&quot;);
        //arrayBlockingQueue.put(&quot;d&quot;);      //队列没有位置了，一直阻塞

        System.out.println(arrayBlockingQueue.take());
        System.out.println(arrayBlockingQueue.take());
        System.out.println(arrayBlockingQueue.take());
        //System.out.println(arrayBlockingQueue.take());   //没有这个元素，一直阻塞
    }
</code></pre>
<pre><code class="language-java">    /**
     * 等待，阻塞（等待超时）
     */
    public static void test4() throws InterruptedException {
        //参数是阻塞队列的大小
        ArrayBlockingQueue arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(3);

        arrayBlockingQueue.offer(&quot;a&quot;);
        arrayBlockingQueue.offer(&quot;b&quot;);
        arrayBlockingQueue.offer(&quot;c&quot;);
        arrayBlockingQueue.offer(&quot;d&quot;, 2, TimeUnit.SECONDS);  //等待两秒超过就退出

        System.out.println(&quot;====================&quot;);
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        System.out.println(arrayBlockingQueue.poll());
        arrayBlockingQueue.poll(2, TimeUnit.SECONDS);  //等待超过两秒退出
    }
</code></pre>
<h3 id="102-synchronizedqueue同步队列blockingqueue的实现类">10.2 SynchronizedQueue同步队列（BlockingQueue的实现类）</h3>
<p>没有容量：进去 一个元素，必须等待取出来之后，才能再往里面放一个元素！（可以抽象理解为capacity = 1的blockingqueue）</p>
<p>put/take</p>
<pre><code class="language-java">/**
 * 同步队列
 * 和其他的blockingqueue不一样， SynchronousQueue不存储元素
 * put了一个元素，必须从里面先take取出来，否则不能再put进去值
 */
public class SynchronizedQueueDemo {
    public static void main(String[] args) {
        BlockingQueue&lt;String&gt; blockingQueue = new SynchronousQueue&lt;&gt;();

        new Thread(() -&gt; {
            try {
                System.out.println(Thread.currentThread().getName() + &quot; put 1&quot;);
                blockingQueue.put(&quot;1&quot;);
                System.out.println(Thread.currentThread().getName() + &quot; put 2&quot;);
                blockingQueue.put(&quot;2&quot;);
                System.out.println(Thread.currentThread().getName() + &quot; put 3&quot;);
                blockingQueue.put(&quot;3&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;T1&quot;).start();

        new Thread(() -&gt; {
            try {
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + blockingQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + &quot;=&gt;&quot; + blockingQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, &quot;T2&quot;).start();
    }
}
</code></pre>
<h2 id="11-线程池重点-三大方法-七大参数-四种拒绝策略">11. 线程池（重点！  三大方法、七大参数、四种拒绝策略）</h2>
<blockquote>
<p><strong>池化技术</strong></p>
<p>可以理解为：事先准备好一些资源，有人要用，就来我这里拿，用完了再还回来。</p>
</blockquote>
<p><strong>线程池的好处：</strong><mark>线程复用；可以控制最大并发数；管理线程</mark></p>
<ol>
<li>降低资源的消耗</li>
<li>提高响应的速度（创建和销毁十分浪费资源）</li>
<li>方便管理</li>
</ol>
<h3 id="111-三大方法">11.1 三大方法</h3>
<p>Executors.<strong>newSingleThreadExecutor()</strong>;   //单个线程<br>
Executors.<strong>newFixedThreadPool(5)</strong>;   //创建一个固定的线程池大小<br>
Executors.<strong>newCachedThreadPool()</strong>;   //可伸缩的，遇强则强，遇弱则弱</p>
<pre><code class="language-java">// Executors 工具类、三大方法
public class Demo01 {
    public static void main(String[] args) {
//        ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程
//        ExecutorService threadPool = Executors.newFixedThreadPool(5);//创建一个固定的线程池大小
        ExecutorService threadPool = Executors.newCachedThreadPool();//可伸缩的，遇强则强，遇弱则弱

        try {
            for (int i = 0; i &lt; 100; i++) {
                //使用了线程池以后，要使用线程池的方法来创建
                threadPool.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + &quot; ok&quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
</code></pre>
<h3 id="112-七大参数">11.2 七大参数</h3>
<blockquote>
<p><strong>int corePoolSize,  // 核心线程池大小</strong><br>
<strong>int maximumPoolSize,  //最大核心线程池大小</strong><br>
<strong>long keepAliveTime,  //超时了没有人调用就会释放</strong><br>
<strong>TimeUnit unit,  //超时单位</strong><br>
<strong>BlockingQueue<Runnable> workQueue,  //阻塞队列</strong><br>
<strong>ThreadFactory threadFactory,  //线程工厂，创建线程的，一般不用动</strong><br>
<strong>RejectedExecutionHandler handler  //拒绝策略</strong></p>
</blockquote>
<pre><code class="language-java">public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
}

public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

// 本质：ThreadPoolExcutor

public ThreadPoolExecutor(int corePoolSize,  // 核心线程池大小
                          int maximumPoolSize,  //最大核心线程池大小
                          long keepAliveTime,  //超时了没有人调用就会释放
                          TimeUnit unit,  //超时单位
                          BlockingQueue&lt;Runnable&gt; workQueue,  //阻塞队列
                          ThreadFactory threadFactory,  //线程工厂，创建线程的，一般不用动
                          RejectedExecutionHandler handler  //拒绝策略) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
        null :
    AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://chase-don.github.io//post-images/image-20210401115958236.png" alt="image-20210401115958236" loading="lazy"></figure>
<figure data-type="image" tabindex="20"><img src="https://chase-don.github.io//post-images/image-20210401120416736.png" alt="image-20210401120416736" loading="lazy"></figure>
<p>(上图很好理解！！线程池)</p>
<blockquote>
<p>手动创建线程池</p>
</blockquote>
<pre><code class="language-java">public class Demo02 {
    public static void main(String[] args) {
        //自定义线程池(ThreadPoolExecutor)
        ExecutorService threadPool = new ThreadPoolExecutor(
                2,
                5,
                3,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue&lt;&gt;(3),
                Executors.defaultThreadFactory(),
//                new ThreadPoolExecutor.AbortPolicy() //银行满了，还有人进来，不处理这个人的线程，抛出异常
//                new ThreadPoolExecutor.CallerRunsPolicy() //哪儿来的回哪儿去（例如回到主线程）
//                new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉当前任务，不会抛出异常！
                new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，丢弃阻塞队列的队首元素，然后再调用execute方法尝试进入队列，不会对正在执行的线程有任何影响
        );

        try {
            //最大承载： Queue + max
            for (int i = 1; i &lt;= 9; i++) {
                //使用了线程池以后，要使用线程池的方法来创建
                threadPool.execute(() -&gt; {
                    System.out.println(Thread.currentThread().getName() + &quot; ok&quot;);
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }
    }
}
</code></pre>
<h3 id="113-四种拒绝策略">11.3 四种拒绝策略</h3>
<blockquote>
<figure data-type="image" tabindex="21"><img src="https://chase-don.github.io//post-images/image-20210401121651016.png" alt="image-20210401121651016" loading="lazy"></figure>
</blockquote>
<pre><code class="language-java">/*
* 四种拒绝策略：
* 1. new ThreadPoolExecutor.AbortPolicy() //银行满了，还有人进来，不处理这个人的线程，抛出异常
* 2. new ThreadPoolExecutor.CallerRunsPolicy() //哪儿来的回哪儿去（例如回到主线程）
* 3. new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢弃当前任务，不会抛出异常！
* 4.new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，丢弃阻塞队列的队首元素，然后再调用execute方法尝试进入	队列，不会对正在执行的线程有任何影响
*/
</code></pre>
<h3 id="114-小结和拓展">11.4 小结和拓展</h3>
<p><strong>最大线程到底该如何去设置？</strong></p>
<ol>
<li><strong>CPU密集型</strong>
<ul>
<li>电脑几核，就是几，可以保持CPU的效率最高！</li>
<li>用代码获取电脑的CPU核数：
<ul>
<li>Runtime.getRuntime().availableProcessors().sout;</li>
</ul>
</li>
</ul>
</li>
<li><strong>IO密集型</strong>：<strong>判断程序中十分耗IO的线程，只要大于这个线程数，就可以（一般设置两倍）</strong>
<ul>
<li>一个程序有15个大型任务，IO十分占用资源。至少有15个线程处理这些IO。</li>
</ul>
</li>
</ol>
<h2 id="12-四大函数式接口必须掌握">12. 四大函数式接口（必须掌握）</h2>
<p>同样需要掌握的还有：lambda表达式、链式编程、函数式接口、Stream流式计算</p>
<h3 id="121-什么是函数式接口">12.1 什么是函数式接口</h3>
<p>FunctionalInterface，只有一个方法的接口，简化编程模型，新版本的框架底层大量使用</p>
<figure data-type="image" tabindex="22"><img src="https://chase-don.github.io//post-images/image-20210401141133634.png" alt="image-20210401141133634" loading="lazy"></figure>
<h3 id="122-function函数式接口function-函数型接口有一个输入参数有一个输出">12.2 Function函数式接口（Function 函数型接口，有一个输入参数，有一个输出）</h3>
<figure data-type="image" tabindex="23"><img src="https://chase-don.github.io//post-images/image-20210401150718506.png" alt="image-20210401150718506" loading="lazy"></figure>
<p>代码测试：</p>
<pre><code class="language-java">/**
 * Function 函数型接口，有一个输入参数，有一个输出
 * 只要是函数型接口，都可以用 lambda表达式简化
 */
public class Demo01 {

    public static void main(String[] args) {
//        Function&lt;String, String&gt; function = new Function&lt;String, String&gt;(){
//            @Override
//            public String apply(String s) {
//                return s;
//            }
//        };

        Function&lt;String, String&gt; function = (s) -&gt; {return s;};

        System.out.println(function.apply(&quot;asfe&quot;));
    }
}
</code></pre>
<h3 id="123-断定型接口predicate断定型接口有一个输入参数返回值只能是布尔值">12.3 断定型接口（Predicate，断定型接口，有一个输入参数，返回值只能是布尔值！）</h3>
<figure data-type="image" tabindex="24"><img src="https://chase-don.github.io//post-images/image-20210401151158324.png" alt="image-20210401151158324" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 断定型接口，有一个输入参数，返回值只能是布尔值！
 */
public class PredicateDemo {
    public static void main(String[] args) {
//        Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {
//            @Override
//            public boolean test(String str) {
//                return str.isEmpty();
//            }
//        };
        Predicate&lt;String&gt; predicate = (str)-&gt;{return str.isEmpty();};

        System.out.println(predicate.test(&quot;qwww&quot;));
    }
}
</code></pre>
<h3 id="124-消费型接口consumer">12.4 消费型接口（Consumer）</h3>
<figure data-type="image" tabindex="25"><img src="https://chase-don.github.io//post-images/image-20210401152626255.png" alt="image-20210401152626255" loading="lazy"></figure>
<pre><code class="language-java">/**
 * Consumer: 消费型接口，只有输入，没有返回值
 */
public class ConsumerDemo {
    public static void main(String[] args) {
//        Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() {
//            @Override
//            public void accept(String str) {
//                System.out.println(str);
//            }
//        };
        Consumer consumer = (str)-&gt;{System.out.println(str);};

        consumer.accept(&quot;dsdsds&quot;);
    }
}
</code></pre>
<h3 id="125-供给型接口supplier">12.5 供给型接口（supplier）</h3>
<figure data-type="image" tabindex="26"><img src="https://chase-don.github.io//post-images/image-20210401160732488.png" alt="image-20210401160732488" loading="lazy"></figure>
<pre><code class="language-java">/**
 * Supplier 供给型接口 没有参数(没有输入)，只有返回值
 */
public class SupplierDemo {
    public static void main(String[] args) {
//        Supplier&lt;Integer&gt; supplier = new Supplier&lt;Integer&gt;() {
//            @Override
//            public Integer get() {
//                System.out.println(&quot;get()&quot;);
//                return 1024;
//            }
//        };

        Supplier&lt;Integer&gt; supplier = () -&gt; {return 1024;};

        System.out.println(supplier.get());
    }
}
</code></pre>
<h2 id="13-stream流式计算">13. Stream流式计算</h2>
<blockquote>
<p>什么是Stream流式计算</p>
</blockquote>
<p>大数据：存储 + 计算</p>
<p>集合、Mysql本质就是存储东西的；</p>
<p>计算都应该交给流来做</p>
<figure data-type="image" tabindex="27"><img src="https://chase-don.github.io//post-images/image-20210401164831861.png" alt="image-20210401164831861" loading="lazy"></figure>
<pre><code class="language-java">/**
 * 现有五个用户，筛选：
 * 1. ID 必须是偶数
 * 2. 年龄必须大于23岁
 * 3. 用户名转为大写字母
 * 4. 用户名字母倒着排序
 * 5. 只输出一个用户
 */
public class StreamTest {
    public static void main(String[] args) {
        User user1 = new User(1, &quot;a&quot;, 21);
        User user2 = new User(2, &quot;b&quot;, 22);
        User user3 = new User(3, &quot;c&quot;, 23);
        User user4 = new User(4, &quot;d&quot;, 24);
        User user5 = new User(6, &quot;e&quot;, 25);
        //集合就是存储
        List&lt;User&gt; list = Arrays.asList(user1, user2, user3, user4, user5);

        //计算交给流！
        //链式编程！
        list.stream().filter(user -&gt; {return user.getId() % 2 == 0;})
                .filter(user -&gt; {return user.getAge() &gt; 23;})
                .map(user -&gt; {return user.getName().toUpperCase();})
                .sorted((user11, user22) -&gt; {return user22.compareTo(user11);})
                .limit(1)
                .forEach(System.out::println);
    }
}
</code></pre>
<h2 id="14-forkjoin">14. Forkjoin</h2>
<h3 id="141-什么是forkjoin">14.1 什么是Forkjoin？</h3>
<p>Forkjoin在JDK1.7出现：并行执行任务；提高效率（<strong>在大数据量的场景下</strong>）    小数据量没必要使用ForkJoin</p>
<p>大数据：Map Reduce（把大任务拆分成小任务）</p>
<img src="file://D:/博客源文件/post-images/image-20210402190345607.png" alt="image-20210402190345607" style="zoom:50%;" />
<p><mark>**Forkjoin的特点：**工作窃取</mark></p>
<p>下图两个任务这里面维护的都是双端队列</p>
<img src="file://D:/博客源文件/post-images/image-20210402190712553.png" alt="image-20210402190712553" style="zoom:50%;" />
<h3 id="142-forkjoin的操作">14.2 Forkjoin的操作</h3>
<p>代码省略（知道这个思路就行）</p>
<h2 id="15-异步回调">15. 异步回调</h2>
<blockquote>
<p>Future设计的初衷：对将来的某个时间的结果进行建模</p>
</blockquote>
<img src="file://D:/博客源文件/post-images/image-20210402204330566.png" alt="image-20210402204330566" style="zoom: 80%;" />
<pre><code class="language-java">/**
 * 异步调用： CompletableFuture
 * 异步执行
 * 成功回调
 * 失败回调
 */
public class Demo01 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //没有返回值的runAsync
//        CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; {
//            try {
//                TimeUnit.SECONDS.sleep(2);
//            } catch (InterruptedException e) {
//                e.printStackTrace();
//            }
//            System.out.println(Thread.currentThread().getName() + &quot;runAsync=&gt;Void&quot;);
//        });
//
//        System.out.println(&quot;1111&quot;);
//
//        completableFuture.get(); // 获取阻塞的执行结果


        //有返回值的 supplyAsync 异步回调
        //ajax =&gt; 有成功回调也有失败回调
        //回调失败返回的是错误信息
        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {
            System.out.println(Thread.currentThread().getName() + &quot;supplyAsync=&gt;Integer&quot;);
            int i = 10 / 0;
            return 1024;
        });

        System.out.println(completableFuture.whenComplete((t, u) -&gt; {
            System.out.println(&quot;t=&gt;&quot; + t);  // 正常的返回结果
            System.out.println(&quot;u=&gt;&quot; + u);  // 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero
        }).exceptionally((e) -&gt; {
            System.out.println(e.getMessage());
            return 233;  //可以获取到错误的返回结果
        }).get());
    }
}
</code></pre>
<h2 id="16-jmm">16. JMM</h2>
<h3 id="161-什么是jmmjava内存模型">16.1 什么是JMM（Java内存模型）</h3>
<p>不存在的东西，是一个概念！约定！</p>
<h3 id="162-关于jmm的一些同步的约定">16.2 关于JMM的一些同步的约定</h3>
<ol>
<li>线程解锁前，必须**<mark>把共享变量立刻刷新回主存</mark>**！</li>
<li>线程加锁前，必须读取主存中的最新值到工作内存中！</li>
<li>加锁和解锁是同一把锁</li>
</ol>
<h3 id="163-线程分为工作内存和主内存-以及-8种操作">16.3 线程分为==<strong>工作内存和主内存</strong>==  以及 <mark>8种操作</mark></h3>
<figure data-type="image" tabindex="28"><img src="https://chase-don.github.io//post-images/image-20210402221907628.png" alt="image-20210402221907628" loading="lazy"></figure>
<p>java内存模型定义了8种操作来完成。<strong><mark>这8种操作每一种都是原子操作</mark></strong>。8种操作如下：</p>
<ul>
<li>lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；</li>
<li>read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；</li>
<li>load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；</li>
<li>use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；</li>
<li>assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；</li>
<li>store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；</li>
<li>write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。</li>
<li>unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；</li>
</ul>
<p>Java内存模型还规定了执行上述8种基本操作时必须满足如下规则:</p>
<p>（1）不允许read和load、store和write操作之一单独出现（即不允许一个变量从主存读取了但是工作内存不接受，或者从工作内存发起会写了但是主存不接受的情况），以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，read与load之间、store与write之间是可插入其他指令的。</p>
<p>（2）不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p>
<p>（3）不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p>
<p>（4）一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</p>
<p>（5）一个变量在同一个时刻只允许一条线程对其执行lock操作，但lock操作可以被同一个条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p>
<p>（6）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</p>
<p>（7）如果一个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p>
<p>（8）对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。</p>
<pre><code class="language-java">public class JMMDemo {

    private static int num = 0;

    public static void main(String[] args) { //main

        new Thread(() -&gt; { //线程1
            while (num == 0) {

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        num = 1;
        System.out.println(num);
    }
}
</code></pre>
<p>出现问题：程序不知道主内存的值已经被修改过了，需要线程A知道主内存中的值发生了变化</p>
<img src="file://D:/博客源文件/post-images/image-20210403000040445.png" alt="image-20210403000040445" style="zoom: 67%;" />
<h2 id="17volatile">17.Volatile</h2>
<blockquote>
<p>请你谈谈对Volatile的理解</p>
</blockquote>
<p>volatile是Java虚拟机提供的==<strong>轻量级的同步机制</strong>==：</p>
<ul>
<li>保证可见性</li>
<li>不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<h3 id="171-保证可见性">17.1 保证可见性</h3>
<pre><code class="language-java">public class JMMDemo {
    //不加 volatile 程序就会死循环！
    //加 volatile 可以保证可见性
    private volatile static int num = 0;

    public static void main(String[] args) { //main

        new Thread(() -&gt; { //线程1 ,对主内存的变化不知道！
            while (num == 0) {

            }
        }).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        num = 1;
        System.out.println(num);
    }
}
</code></pre>
<h3 id="172-不保证原子性">17.2 不保证原子性</h3>
<p>原子性：不可分割（线程A在执行任务的时候，不能被打扰的，也不能被分割。<strong><mark>要么同时成功，要么同时失败</mark></strong>）</p>
<pre><code class="language-java">/**
 * 不保证原子性
 */
public class VolatileDemo {
    //加了volatile依旧不足20k，说明volatile不保证原子性
    private volatile static int num = 0;

    public static void add() {
        num++;
    }

    public static void main(String[] args) {
        //理论上num结果为20000
        for (int i = 1; i &lt;= 20; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount() &gt; 2) {
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName() + &quot; &quot; + num);
    }
}
</code></pre>
<p><strong><u>问题！！如果不加 lock 和 synchronized，怎么样保证原子性？</u></strong></p>
<img src="file://D:/博客源文件/post-images/image-20210403011352414.png" alt="image-20210403011352414" style="zoom: 67%;" />
<p><strong><mark>答案：使用原子类，解决原子性问题</mark></strong>（**这些类的底层都直接和操作系统挂钩，在内存中修改值！**Unsafe类是一个很特殊的存在）</p>
<pre><code class="language-java">public class VolatileDemo {
    //原子类的Integer
    private volatile static AtomicInteger num = new AtomicInteger();

    public static void add() {
//        num++; //不是一个原子性操作！
        num.getAndIncrement(); // AtomicInteger的 +1 方法，用的是CAS
    }

    public static void main(String[] args) {
        //理论上num结果为20000
        for (int i = 1; i &lt;= 20; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 1000; j++) {
                    add();
                }
            }).start();
        }

        while (Thread.activeCount() &gt; 2) {
            Thread.yield();
        }
        System.out.println(Thread.currentThread().getName() + &quot; &quot; + num);
    }
}
</code></pre>
<h3 id="173-禁止指令重排">17.3 禁止指令重排</h3>
<blockquote>
<p>什么是指令重排？</p>
</blockquote>
<p>写的程序，计算机并不是按照写的那样去执行的。</p>
<p><mark><strong>源代码 --&gt; 编译器优化的重排 --&gt; 指令并行也可能会重排 --&gt; 内存系统也会重排 --&gt; 执行</strong></mark></p>
<p><strong>处理器在进行指令重排的时候，会考虑：数据之间的依赖性！</strong></p>
<pre><code class="language-java">int x = 1; // 1
int y = 2; // 2
x = x + 5; // 3
y = x * x; // 4

我们所期望的是：1234  但是可能执行的时候会变成 2134 1324
问：可不可能是 4123？   不可能！
</code></pre>
<p>指令重排可能造成对结果的影响，举例如下：</p>
<p>a,b,x,y 这四个值默认都是0：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>x  = a</td>
<td>y = b</td>
</tr>
<tr>
<td>b = 1</td>
<td>a = 2</td>
</tr>
</tbody>
</table>
<p>正常的结果： x = 0; y = 0; 但是可能由于指令重排线程运行变成如下：</p>
<table>
<thead>
<tr>
<th>线程A</th>
<th>线程B</th>
</tr>
</thead>
<tbody>
<tr>
<td>x  = a</td>
<td>y = b</td>
</tr>
<tr>
<td>b = 1</td>
<td>a = 2</td>
</tr>
</tbody>
</table>
<p>指令重排导致结果为： x = 2; y = 1</p>
<p><strong>volatile可以避免指令重排：</strong></p>
<p>内存屏障-&gt;CPU指令。作用：</p>
<ol>
<li>保证特定的操作的执行顺序</li>
<li>可以保证某些变量的内存可见性(<strong>利用这些特性volatile实现了可见性</strong>)</li>
</ol>
<img src="file://D:/博客源文件/post-images/image-20210403175846842.png" alt="image-20210403175846842" style="zoom:67%;" />
<p>Volatile是可以保证可见性，不能保证原子性，由于内存屏障，可以保证避免指令重排的现象发生。</p>
<h2 id="18-单例模式">18. 单例模式</h2>
<p>饿汉式  懒汉式（DCL懒汉式，双重检测模式）</p>
<h2 id="19深入理解cas这块没太懂-多看面经">19.深入理解CAS（这块没太懂  多看面经）</h2>
<h3 id="191-什么是cas">19.1 什么是CAS</h3>
<pre><code class="language-java">/**
 * CAS是CPU的并发原语
 */
public class CASDemo {
    //CAS compareAndSwap：比较并交换！
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        //两个参数，前面是expect后面是update
        //public final boolean compareAndSet(int expect, int update)    返回值是个boolean
        //如果我期望的值达到了，那么就更新，否则就不更新。
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        atomicInteger.getAndIncrement();
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
</code></pre>
<h3 id="192-什么是unsafe类">19.2 什么是Unsafe类</h3>
<img src="file://D:/博客源文件/post-images/image-20210403184411704.png" alt="image-20210403184411704" style="zoom: 67%;" />
<img src="file://D:/博客源文件/post-images/image-20210403185330343.png" alt="image-20210403185330343" style="zoom:67%;" />
<figure data-type="image" tabindex="29"><img src="https://chase-don.github.io//post-images/image-20210403185634113.png" alt="image-20210403185634113" loading="lazy"></figure>
<h3 id="193-cas总结">19.3 CAS总结：</h3>
<p>CAS: <strong>比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作</strong>！如果不是就一直循环！（底层是do...while  自旋锁）</p>
<p>缺点：</p>
<ul>
<li>底层是自旋锁，循环会耗时</li>
<li>由于<strong>是底层的CPU操作，一次性只能保证一个共享变量的原子性</strong></li>
<li>会存在ABA问题</li>
</ul>
<h2 id="20-带版本号的原子引用atomicstampedreference解决aba问题">20. 带版本号的原子引用(<mark>AtomicStampedReference</mark>)解决ABA问题</h2>
<h3 id="201-什么是aba问题">20.1 什么是ABA问题？</h3>
<img src="file://D:/博客源文件/post-images/image-20210403191039765.png" alt="image-20210403191039765" style="zoom:67%;" />
<pre><code class="language-java">public class ABADemo {
    //CAS compareAndSwap：比较并交换！
    public static void main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(2020);

        //两个参数，前面是expect后面是update
        //public final boolean compareAndSet(int expect, int update)    返回值是个boolean
        //如果我期望的值达到了，那么就更新，否则就不更新。
        // ================== 捣乱的线程 ===================
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());

        System.out.println(atomicInteger.compareAndSet(2021, 2020));
        System.out.println(atomicInteger.get());

        // ================== 期望的线程 ===================
        System.out.println(atomicInteger.compareAndSet(2020, 2021));
        System.out.println(atomicInteger.get());
    }
}
</code></pre>
<h3 id="202-什么是原子引用带版本号的原子操作">20.2 什么是原子引用？（带版本号的原子操作）</h3>
<img src="file://D:/博客源文件/post-images/image-20210403195955345.png" alt="image-20210403195955345" style="zoom: 67%;" />
<p><strong>Integer使用了对象缓存机制，默认范围是-128-127，推荐使用静态工厂方法valueOf获取对象实例，而不是new，因为valueOf使用缓存，而new一定会创建新的对象分配新的内存空间</strong></p>
<h2 id="21-各种锁的理解">21. 各种锁的理解</h2>
<h3 id="211-公平锁-非公平锁">21.1 公平锁、非公平锁</h3>
<p>公平锁：非常公平，不可以插队，必须先来后到</p>
<p>非公平锁：非常不公平，可以插队</p>
<pre><code class="language-java">public ReentrantLock() {
    sync = new NonfairSync();
}

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre>
<h3 id="212-可重入锁">21.2 可重入锁</h3>
<img src="file://D:/博客源文件/post-images/image-20210403203510847.png" alt="image-20210403203510847" style="zoom:50%;" />
<blockquote>
<p>Synchronized</p>
</blockquote>
<pre><code class="language-java">//synchronized
public class Demo01 {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;A&quot;).start();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;B&quot;).start();
    }
}

class Phone{
    public synchronized void sms() {
        System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);
        call();  // 这里也有锁！！
    }

    public synchronized void call() {
        System.out.println(Thread.currentThread().getName() + &quot;call&quot;);
    }
}
</code></pre>
<blockquote>
<p>Lock</p>
</blockquote>
<pre><code class="language-java">//lock
public class Demo02 {
    public static void main(String[] args) {
        Phone2 phone = new Phone2();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;A&quot;).start();

        new Thread(() -&gt; {
            phone.sms();
        }, &quot;B&quot;).start();
    }
}

class Phone2{
    Lock lock = new ReentrantLock();
    public void sms() {
        lock.lock(); //lock锁必须配对，否则就会死在里面
        try {
            System.out.println(Thread.currentThread().getName() + &quot;sms&quot;);
            call();  // 这里也有锁！！
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void call() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + &quot;call&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<h3 id="213-自旋锁spinlock">21.3 自旋锁(spinlock )</h3>
<figure data-type="image" tabindex="30"><img src="https://chase-don.github.io//post-images/image-20210403185634113.png" alt="image-20210403185634113" loading="lazy"></figure>
<p>自定义一个自旋锁：</p>
<pre><code class="language-java">/**
 * 自旋锁
 */
public class SpinlockDemo {

    //int   0
    //Thread   null
    AtomicReference&lt;Thread&gt; atomicReference = new AtomicReference&lt;Thread&gt;();

    //加锁
    public void myLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + &quot;==&gt; mylock&quot;);

        //自旋锁
        while (!atomicReference.compareAndSet(null, thread)) {

        }
    }

    //解锁
    public void myUnLock(){
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + &quot;==&gt; myUnlock&quot;);
        atomicReference.compareAndSet(thread, null);
    }
}
</code></pre>
<pre><code class="language-java">public class TestSpinLock {
    public static void main(String[] args) throws InterruptedException {
        //底层使用的是自旋锁
        SpinlockDemo lock = new SpinlockDemo();

        new Thread(() -&gt; {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        }, &quot;t1&quot;).start();

        TimeUnit.SECONDS.sleep(1);

        new Thread(() -&gt; {
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        }, &quot;t2&quot;).start();

    }
}
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://chase-don.github.io//post-images/image-20210403221329691.png" alt="image-20210403221329691" loading="lazy"></figure>
<h3 id="214-死锁">21.4 死锁</h3>
<blockquote>
<p>什么是死锁</p>
</blockquote>
<figure data-type="image" tabindex="32"><img src="https://chase-don.github.io//post-images/image-20210403221427819.png" alt="image-20210403221427819" loading="lazy"></figure>
<pre><code class="language-java">public class DeadLockDemo {
    public static void main(String[] args) {
        MyThread myThread1 = new MyThread(&quot;a&quot;, &quot;b&quot;);
        MyThread myThread2 = new MyThread(&quot;b&quot;, &quot;a&quot;);

        new Thread(myThread1).start();
        new Thread(myThread2).start();
    }

}


class MyThread implements Runnable {

    private String lockA;  //对象A
    private String lockB;  //对象B

    public MyThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }

    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockA + &quot;=&gt;get&quot; + lockB);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + &quot;lock:&quot; + lockB + &quot;=&gt;get&quot; + lockA);
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<p><strong>如何解决死锁（排查）？</strong></p>
<ul>
<li>
<p>使用jps定位进程号</p>
<ul>
<li><strong><mark>指令为  jps-l</mark></strong></li>
</ul>
<figure data-type="image" tabindex="33"><img src="https://chase-don.github.io//post-images/image-20210403223955180.png" alt="image-20210403223955180" loading="lazy"></figure>
</li>
<li>
<p>使用**<mark>jstack+进程号</mark>**找到死锁信息（如上图的30140就是进程号）</p>
</li>
</ul>
<figure data-type="image" tabindex="34"><img src="https://chase-don.github.io//post-images/image-20210403224610440.png" alt="image-20210403224610440" loading="lazy"></figure>
<p>排查问题：日志+堆栈信息</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringMVC]]></title>
        <id>https://chase-don.github.io/post/springmvc/</id>
        <link href="https://chase-don.github.io/post/springmvc/">
        </link>
        <updated>2021-02-04T08:40:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-回顾mvc">1. 回顾MVC</h2>
<h3 id="11-什么是mvc">1.1 什么是MVC</h3>
<ul>
<li>模型（dao，service）、视图（jsp）、控制器（servlet）的简写，是一种软件设计规范</li>
<li>是将业务逻辑，数据，现实分离的方法来组织代码</li>
<li>MVC主要作用是<strong>降低了视图和业务逻辑间的双向耦合</strong></li>
<li>MVC不是一种设计模式，<strong>MVC是一种架构模式。</strong></li>
</ul>
<img src="file://D:/博客源文件/post-images/image-20210418182624037.png" alt="image-20210418182624037" style="zoom:80%;" />
<p>过程：</p>
<ol>
<li>用户发请求</li>
<li>Servlet接受请求数据，并调用对应的业务逻辑方法</li>
<li>业务处理完毕，返回更新后的数据给servlet</li>
<li>servlet转向到jsp，由jsp来渲染页面</li>
<li>响应给前端更新后的页面</li>
</ol>
<blockquote>
<p>职责分析：</p>
<p><strong>Controller：控制器</strong></p>
<ol>
<li>取得表单数据</li>
<li>调用业务逻辑</li>
<li>转向指定的页面</li>
</ol>
<p><strong>Model：模型</strong></p>
<ol>
<li>业务逻辑</li>
<li>保存数据的状态</li>
</ol>
<p>View：视图</p>
<ol>
<li>显示页面</li>
</ol>
</blockquote>
<h2 id="2-回顾servlet">2. 回顾Servlet</h2>
<blockquote>
<p>编写一个Servlet类，用来处理用户的请求</p>
</blockquote>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1. 获取前端参数
        String method = req.getParameter(&quot;method&quot;);
        if (method.equals(&quot;add&quot;)){
            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了add方法&quot;);
        }
        if (method.equals(&quot;delete&quot;)){
            req.getSession().setAttribute(&quot;msg&quot;,&quot;执行了delete方法&quot;);
        }
        //2. 调用业务层
        //3. 视图转发或者重定向
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req, resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
</code></pre>
<blockquote>
<p>编写Hello.jsp，在WEB-INF目录下新建一个jsp的文件夹，新建hello.jsp</p>
</blockquote>
<pre><code class="language-xml">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;Kuangshen&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
${msg}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>在web.xml中注册Servlet</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;cn.edu.bupt.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;!--    &lt;session-config&gt;--&gt;
&lt;!--        &lt;session-timeout&gt;15&lt;/session-timeout&gt;--&gt;
&lt;!--    &lt;/session-config&gt;--&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;

&lt;/web-app&gt;
</code></pre>
<blockquote>
<p>配置Tomcat，并启动测试</p>
</blockquote>
<pre><code class="language-url">- localhost:8080/hello?method=add
- localhost:8080/hello?method=delete
</code></pre>
<h2 id="3-什么是springmvc">3. 什么是SpringMVC</h2>
<h3 id="31-相关概述">3.1 相关概述</h3>
<p>Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架。</p>
<p><strong>Spring MVC的特点：</strong></p>
<ol>
<li>轻量级，简单易学</li>
<li>高效 , 基于请求响应的MVC框架</li>
<li>与Spring兼容性好，无缝结合</li>
<li>约定优于配置</li>
<li>功能强大：RESTful、数据验证、格式化、本地化、主题等</li>
<li>简洁灵活</li>
</ol>
<h3 id="32-中心控制器">3.2 中心控制器</h3>
<p><strong>Spring的web框架<mark>围绕DispatcherServlet设计</mark>。DispatcherServlet的作用是<mark>将请求分发到不同的处理器</mark></strong>。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解的controller声明方式。</p>
<p>Spring MVC框架像许多其他MVC框架一样, <strong>以请求为驱动</strong> , <strong>围绕一个中心Servlet分派请求及提供其他功能</strong>，<strong>DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)</strong></p>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210418221316040.png" alt="image-20210418221316040" loading="lazy"></figure>
<p>SpringMVC的原理如下图所示：</p>
<p>​		当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。</p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210418222155124.png" alt="image-20210418222155124" loading="lazy"></figure>
<h2 id="4-第一个mvc程序">4. 第一个MVC程序</h2>
<ol>
<li>
<p>新建一个Moudle ， springmvc-02-hello ， 添加web的支持！</p>
</li>
<li>
<p>确定导入了SpringMVC 的依赖！</p>
</li>
<li>
<p>配置web.xml  ， 注册DispatcherServlet</p>
</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--1.注册DispatcherServlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!--启动级别-1--&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt;
    &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<p>其中：<url-pattern></url-pattern>中</p>
<p><mark><strong>如果是：/         匹配所有的请求；（不包括.jsp）</strong></mark><br>
<mark><em><em>如果是：/</em>       匹配所有的请求；（包括.jsp）</em>*</mark></p>
<ol start="4">
<li>编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml  : [servletname]-servlet.xml（命名要求格式）</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--添加 处理映射器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
    &lt;!--添加 处理器适配器--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;


    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
        &lt;!--前缀--&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;!--后缀--&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--将自己的类交给SpringIOC容器，注册bean--&gt;
    &lt;!--Handler--&gt;
    &lt;bean id=&quot;/hello&quot; class=&quot;cn.edu.bupt.controller.HelloController&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<ol start="5">
<li>编写我们要操作业务Controller ，要么实现Controller接口，<mark><strong>要么增加注解；需要返回一个ModelAndView</strong></mark>，装数据，封视图；</li>
</ol>
<pre><code class="language-java">import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


//注意：这里我们先导入Controller接口
public class HelloController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {
        //ModelAndView 模型和视图
        ModelAndView mv = new ModelAndView();

        //封装对象，放在ModelAndView中。Model
        mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;);
        //封装要跳转的视图，放在ModelAndView中
        mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp
        return mv;
    }
}
</code></pre>
<ol start="6">
<li>写要跳转的jsp页面，显示ModelandView存放的数据，以及我们的正常页面；</li>
</ol>
<pre><code class="language-xml">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

${msg}

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="7">
<li>配置Tomcat启动测试！</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210419004740294.png" alt="image-20210419004740294" loading="lazy"></figure>
<p><strong>测试过程中遇到的问题：访问出现404，排查步骤：</strong></p>
<ol>
<li>查看控制台输出，看一下是不是缺少了什么jar包。</li>
<li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖！</li>
<li>重启Tomcat 即可解决！</li>
</ol>
<h3 id="熟悉掌握下图的执行流程"><strong>熟悉掌握下图的执行流程</strong></h3>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210420002455704.png" alt="image-20210420002455704" loading="lazy"></figure>
<p>图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。</p>
<p><strong>简要分析执行流程</strong></p>
<ol>
<li>
<p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>
<p>我们假设请求的url为 : http://localhost:8080/SpringMVC/hello</p>
<p><strong>如上url拆分成三部分：</strong></p>
<p>http://localhost:8080服务器域名</p>
<p>SpringMVC部署在服务器上的web站点</p>
<p>hello表示控制器</p>
<p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>
</li>
<li>
<p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p>
</li>
<li>
<p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p>
</li>
<li>
<p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p>
</li>
<li>
<p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p>
</li>
<li>
<p>Handler让具体的Controller执行。</p>
</li>
<li>
<p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p>
</li>
<li>
<p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p>
</li>
<li>
<p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p>
</li>
<li>
<p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p>
</li>
<li>
<p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p>
</li>
<li>
<p>最终视图呈现给用户。</p>
</li>
</ol>
<h2 id="5-用注解开发springmvc">5. 用注解开发SpringMVC</h2>
<h3 id="51-大致过程及代码">5.1 大致过程及代码</h3>
<ol>
<li><strong>完善相关的配置和依赖等</strong></li>
<li><strong>配置web.xml</strong></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;

    &lt;!--注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 启动顺序，数字越小，启动越早 --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!--所有请求都会被springmvc拦截--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<ol start="3">
<li><strong>添加springmvc-servlet.xml配置文件</strong></li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;

    &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;
    &lt;context:component-scan base-package=&quot;cn.edu.bupt.controller&quot;/&gt;

    &lt;!-- 让Spring MVC不处理静态资源 比如： .css  .js  .html  .mp3  .mp4--&gt;
    &lt;mvc:default-servlet-handler /&gt;

    &lt;!--
    支持mvc注解驱动 (处理映射器 和 处理适配器)
        在spring中一般采用@RequestMapping注解来完成映射关系
        要想使@RequestMapping注解生效
        必须向上下文中注册DefaultAnnotationHandlerMapping
        和一个AnnotationMethodHandlerAdapter实例
        这两个实例分别在类级别和方法级别处理。
        而annotation-driven配置帮助我们自动完成上述两个实例的注入。
     --&gt;
    &lt;mvc:annotation-driven /&gt;


    &lt;!-- 视图解析器 --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;
          id=&quot;internalResourceViewResolver&quot;&gt;
        &lt;!-- 前缀 --&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
        &lt;!-- 后缀 --&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ol start="4">
<li><strong>创建Controller</strong></li>
</ol>
<pre><code class="language-java">package cn.edu.bupt.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController {

    //真实访问地址 --&gt;  localhost:8080/hello/h1
    @RequestMapping(&quot;/h1&quot;)
    public String hello(Model model) {
        //封装数据（向模型中添加属性msg与值，可以在jsp页面中取出并渲染）
        model.addAttribute(&quot;msg&quot;, &quot;Hello,SpringMVCAnnotation&quot;);

        // 会被视图解析器处理 ---&gt;  /WEB-INF/jsp/hello.jsp
        return &quot;hello&quot;;
    }
}
</code></pre>
<ul>
<li>@Controller是为了让Spring IOC容器初始化时自动扫描到；</li>
<li>@RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/hello/h1；</li>
<li>方法中声明Model类型的参数是为了把Action中的数据带到视图中；</li>
<li>方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/<strong>hello</strong>.jsp。</li>
</ul>
<ol start="5">
<li>
<p><strong>创建视图层</strong></p>
</li>
<li>
<p>在WEB-INF/ jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息；</p>
</li>
<li>
<p>可以通过EL表示取出Model中存放的值，或者对象；</p>
</li>
</ol>
<pre><code class="language-xml">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

${msg}

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ol start="6">
<li>
<p><strong>配置Tomcat运行</strong></p>
<p>配置Tomcat ，  开启服务器 ， 访问 对应的请求路径！</p>
</li>
</ol>
<h3 id="52-实现步骤小结">5.2 实现步骤小结：</h3>
<ol>
<li>新建一个web项目</li>
<li>导入相关jar包</li>
<li>编写web.xml , 注册DispatcherServlet</li>
<li>编写springmvc配置文件</li>
<li>接下来就是去创建对应的控制类 , controller</li>
<li>最后完善前端视图和controller之间的对应</li>
<li>测试运行调试.</li>
</ol>
<p><mark>使用springMVC必须配置的三大件：</mark></p>
<p><mark><strong>处理器映射器、处理器适配器、视图解析器</strong></mark>（切记！！！！在springmvc-servlet.xml中配置！  web.xml就配置servlert【DispatchServlet】）</p>
<p><mark>通常，我们只需要<strong>手动配置视图解析器</strong>，而<strong>处理器映射器</strong>和<strong>处理器适配器</strong>只需要开启<strong>注解驱动</strong>即可，而省去了大段的xml配置</mark></p>
<h2 id="6-controller-配置总结">6. Controller 配置总结</h2>
<h3 id="61-控制器controller">6.1 控制器Controller</h3>
<ul>
<li>控制器复杂提供访问应用程序的行为，通常通过<strong>接口定义或注解定义</strong>两种方法实现。</li>
<li>控制器负责解析用户的请求并将其转换为一个模型。</li>
<li>在Spring MVC中一个控制器类可以包含多个方法</li>
<li>在Spring MVC中，对于Controller的配置方式有很多种</li>
</ul>
<h3 id="62-controller方式">6.2 Controller方式</h3>
<h4 id="621-实现controller接口代码省略看springmvc-03">6.2.1 实现Controller接口（代码省略，看springmvc-03）</h4>
<ul>
<li>
<p>实现接口Controller定义控制器是比较老的方法，基本不用</p>
</li>
<li>
<p>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</p>
</li>
</ul>
<h4 id="622-使用注解controller">6.2.2 使用注解@Controller</h4>
<ul>
<li>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；
<ul>
<li>@Service</li>
<li>@Component</li>
<li>@Repository</li>
</ul>
</li>
<li>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</li>
</ul>
<blockquote>
<p>springmvc-servlet.xml</p>
</blockquote>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;


    &lt;!--映射器，适配器以及解析器是springmvc的核心三要素！--&gt;
    &lt;context:component-scan base-package=&quot;cn.edu.bupt.controller&quot;/&gt;
    &lt;!--过滤静态资源--&gt;
&lt;!--    &lt;mvc:default-servlet-handler/&gt;--&gt;
&lt;!--    &lt;mvc:annotation-driven/&gt;--&gt;


    &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt;
        &lt;!--前缀--&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
        &lt;!--后缀--&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>
<p>增加一个ControllerTest2类，使用注解实现；</p>
<pre><code class="language-java">package cn.edu.bupt.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller  // 用了这个注解代表这个类会被spring接管，
             // 被这个注解所注解的类中的所有方法，如果返回值是String，并且有具体页面可以跳转，那么就会被视图解析器解析
@RequestMapping(&quot;/hello&quot;)
public class ControllerTest2 {

    @RequestMapping(&quot;/test2&quot;)
    public String test1(Model model) {
        model.addAttribute(&quot;msg&quot;, &quot;ControllerTest2&quot;);
        return &quot;test&quot;;   //返回给视图解析器去拼凑 --&gt; /WEB-INF/jsp/test.jsp
    }


    @RequestMapping(&quot;/test3&quot;)
    public String test3(Model model) {
        model.addAttribute(&quot;msg&quot;, &quot;test3&quot;);
        return &quot;test&quot;;   //返回给视图解析器去拼凑 --&gt; /WEB-INF/jsp/test.jsp
    }

}
</code></pre>
</li>
<li>
<p>运行tomcat测试</p>
</li>
</ul>
<p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出<mark>视图是被复用的，而控制器与视图之间是弱偶合关系</mark>。</strong></p>
<p><strong>注解方式是平时使用的最多的方式！</strong></p>
<h3 id="63-requestmapping说明">6.3 @RequestMapping说明</h3>
<p><strong>@RequestMapping</strong></p>
<ul>
<li>
<p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。<strong><mark>可用于类或方法上</mark></strong>。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>
</li>
<li>
<p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p>
</li>
<li>
<p>只注解在方法上面</p>
<pre><code class="language-java">@Controller
public class TestController {
   @RequestMapping(&quot;/h1&quot;)
   public String test(){
       return &quot;test&quot;;
  }
}
</code></pre>
<p>访问路径：http://localhost:8080 / 项目名 / h1</p>
</li>
<li>
<p>同时注解类与方法</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/admin&quot;)
public class TestController {
   @RequestMapping(&quot;/h1&quot;)
   public String test(){
       return &quot;test&quot;;
  }
}
</code></pre>
<p>访问路径：http://localhost:8080 / 项目名/ admin /h1  , 需要先指定类的路径再指定方法的路径；</p>
</li>
</ul>
<h2 id="7-restful-风格">7. RestFul 风格</h2>
<h4 id="概念"><strong>概念</strong></h4>
<p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<h4 id="使用method属性指定请求类型"><strong>使用method属性指定请求类型</strong></h4>
<pre><code class="language-java">@Controller
public class RestFulController {

    //原来的：    http://localhost:8080/add?a=1&amp;b=2
    //RestFul：   http://localhost:8080/add/1/2   ----&gt;   需要在a和b上加注解 @PathVariable

//    @RequestMapping(&quot;/add/{a}/{b}&quot;)
    @RequestMapping(value = &quot;/add/{a}/{b}&quot;, method = RequestMethod.POST)
//    @GetMapping(&quot;/add/{a}/{b}&quot;)
    public String test1(@PathVariable int a, @PathVariable int b, Model model) {
        int res = a + b;
        model.addAttribute(&quot;msg&quot;, &quot;结果1为&quot; + res);
        return &quot;test&quot;;
    }
}
</code></pre>
<p><strong>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</strong></p>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210420202222400.png" alt="image-20210420202222400" loading="lazy"></figure>
<h4 id="学习测试正确代码和演变情况">学习测试（正确代码和演变情况）</h4>
<pre><code class="language-java">@Controller
public class RestFulController {

    //原来的：    http://localhost:8080/add?a=1&amp;b=2
    //RestFul：   http://localhost:8080/add/1/2   ----&gt;   需要在a和b上加注解 @PathVariable

//    @RequestMapping(&quot;/add/{a}/{b}&quot;)
//    @RequestMapping(value = &quot;/add/{a}/{b}&quot;, method = RequestMethod.POST)
    @GetMapping(&quot;/add/{a}/{b}&quot;)
    public String test1(@PathVariable int a, @PathVariable int b, Model model) {
        int res = a + b;
        model.addAttribute(&quot;msg&quot;, &quot;结果1为&quot; + res);
        return &quot;test&quot;;
    }

    @PostMapping(&quot;/add/{a}/{b}&quot;)
    public String test2(@PathVariable int a, @PathVariable int b, Model model) {
        int res = a + b;
        model.addAttribute(&quot;msg&quot;, &quot;结果2为&quot; + res);
        return &quot;test&quot;;
    }
}
</code></pre>
<h4 id="小结"><strong>小结：</strong></h4>
<p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p>
<p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p>
<p>方法级别的注解变体有如下几个：组合注解</p>
<pre><code>@GetMapping
@PostMapping
@PutMapping
@DeleteMapping
@PatchMapping
</code></pre>
<p>@GetMapping 是一个组合注解，平时使用的会比较多！</p>
<p>它所扮演的是 <strong>@RequestMapping(method =RequestMethod.GET)</strong> 的一个快捷方式。</p>
<h2 id="8-mvc中的重定向和转发">8. MVC中的重定向和转发</h2>
<p>https://mp.weixin.qq.com/s?__biz=Mzg2NTAzMTExNg==&amp;mid=2247483998&amp;idx=1&amp;sn=97c417a2c1484d694c761a2ad27f217d&amp;scene=19#wechat_redirect</p>
<p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p>
<p>测试前，需要将视图解析器注释掉</p>
<pre><code class="language-java">@Controller
public class ResultSpringMVC {
   @RequestMapping(&quot;/rsm/t1&quot;)
   public String test1(){
       //转发
       return &quot;/index.jsp&quot;;
  }

   @RequestMapping(&quot;/rsm/t2&quot;)
   public String test2(){
       //转发二
       return &quot;forward:/index.jsp&quot;;
  }

   @RequestMapping(&quot;/rsm/t3&quot;)
   public String test3(){
       //重定向
       return &quot;redirect:/index.jsp&quot;;
  }
}
</code></pre>
<p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p>
<p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p>
<p>可以重定向到另外一个请求实现 .</p>
<pre><code class="language-java">@Controller
public class ResultSpringMVC2 {
   @RequestMapping(&quot;/rsm2/t1&quot;)
   public String test1(){
       //转发
       return &quot;test&quot;;
  }

   @RequestMapping(&quot;/rsm2/t2&quot;)
   public String test2(){
       //重定向
       return &quot;redirect:/index.jsp&quot;;
       //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/
  }

}
</code></pre>
<h2 id="9-乱码问题">9. 乱码问题</h2>
<h3 id="91-测试步骤">9.1 测试步骤：</h3>
<p>1、我们可以在首页编写一个提交的表单</p>
<pre><code class="language-xml">&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt;
 &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
 &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<p>2、后台编写对应的处理类</p>
<pre><code class="language-java">@Controller
public class Encoding {
   @RequestMapping(&quot;/e/t&quot;)
   public String test(Model model,String name){
       model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值
       return &quot;test&quot;; //跳转到test页面显示输入的值
  }
}
</code></pre>
<p>3、输入中文测试，发现乱码</p>
<figure data-type="image" tabindex="6"><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7IY4LDnTZkk5dLWKMlUlx0gqJOSOA4PQnmhg0rYQYexQXAvUWXvBRf8kN3hk6dDzHxC3w97QicX9XQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" loading="lazy"></figure>
<p>以前乱码问题通过过滤器解决 , 而<strong>SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置</strong> .</p>
<p>修改了xml文件需要重启服务器！</p>
<pre><code class="language-xml">&lt;filter&gt;
   &lt;filter-name&gt;encoding&lt;/filter-name&gt;
   &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
   &lt;init-param&gt;
       &lt;param-name&gt;encoding&lt;/param-name&gt;
       &lt;param-value&gt;utf-8&lt;/param-value&gt;
   &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
   &lt;filter-name&gt;encoding&lt;/filter-name&gt;
   &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p>
<h3 id="92-还解决不了乱码的话的处理方法">9.2 还解决不了乱码的话的处理方法</h3>
<p>1、修改tomcat配置文件 ：设置编码！</p>
<pre><code class="language-xml">&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
          connectionTimeout=&quot;20000&quot;
          redirectPort=&quot;8443&quot; /&gt;
</code></pre>
<p>2、自定义过滤器</p>
<pre><code class="language-java">package com.kuang.filter;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Map;

/**
* 解决get和post请求 全部乱码的过滤器
*/
public class GenericEncodingFilter implements Filter {

   @Override
   public void destroy() {
  }

   @Override
   public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
       //处理response的字符编码
       HttpServletResponse myResponse=(HttpServletResponse) response;
       myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

       // 转型为与协议相关对象
       HttpServletRequest httpServletRequest = (HttpServletRequest) request;
       // 对request包装增强
       HttpServletRequest myrequest = new MyRequest(httpServletRequest);
       chain.doFilter(myrequest, response);
  }

   @Override
   public void init(FilterConfig filterConfig) throws ServletException {
  }

}

//自定义request对象，HttpServletRequest的包装类
class MyRequest extends HttpServletRequestWrapper {

   private HttpServletRequest request;
   //是否编码的标记
   private boolean hasEncode;
   //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰
   public MyRequest(HttpServletRequest request) {
       super(request);// super必须写
       this.request = request;
  }

   // 对需要增强方法 进行覆盖
   @Override
   public Map getParameterMap() {
       // 先获得请求方式
       String method = request.getMethod();
       if (method.equalsIgnoreCase(&quot;post&quot;)) {
           // post请求
           try {
               // 处理post乱码
               request.setCharacterEncoding(&quot;utf-8&quot;);
               return request.getParameterMap();
          } catch (UnsupportedEncodingException e) {
               e.printStackTrace();
          }
      } else if (method.equalsIgnoreCase(&quot;get&quot;)) {
           // get请求
           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();
           if (!hasEncode) { // 确保get手动编码逻辑只运行一次
               for (String parameterName : parameterMap.keySet()) {
                   String[] values = parameterMap.get(parameterName);
                   if (values != null) {
                       for (int i = 0; i &lt; values.length; i++) {
                           try {
                               // 处理get乱码
                               values[i] = new String(values[i]
                                      .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;);
                          } catch (UnsupportedEncodingException e) {
                               e.printStackTrace();
                          }
                      }
                  }
              }
               hasEncode = true;
          }
           return parameterMap;
      }
       return super.getParameterMap();
  }

   //取一个值
   @Override
   public String getParameter(String name) {
       Map&lt;String, String[]&gt; parameterMap = getParameterMap();
       String[] values = parameterMap.get(name);
       if (values == null) {
           return null;
      }
       return values[0]; // 取回参数的第一个值
  }

   //取所有值
   @Override
   public String[] getParameterValues(String name) {
       Map&lt;String, String[]&gt; parameterMap = getParameterMap();
       String[] values = parameterMap.get(name);
       return values;
  }
}
</code></pre>
<p>这个是网上大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p>
<p><strong>然后在web.xml中配置这个过滤器即可！</strong></p>
<p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p>
<h2 id="10-json">10. JSON</h2>
<h3 id="101-什么是json">10.1 什么是JSON？</h3>
<ul>
<li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的<strong>数据交换格式</strong>，目前使用特别广泛。</li>
<li>采用完全独立于编程语言的==<strong>文本格式</strong>==来存储和表示数据。</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li>
<li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li>
</ul>
<p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p>
<ul>
<li>对象表示为键值对，数据由逗号分隔</li>
<li>花括号保存对象</li>
<li>方括号保存数组</li>
</ul>
<p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 &quot;&quot; 包裹，使用冒号 : 分隔，然后紧接着值：</p>
<pre><code class="language-html">{&quot;name&quot;: &quot;QinJiang&quot;}
{&quot;age&quot;: &quot;3&quot;}
{&quot;sex&quot;: &quot;男&quot;}
</code></pre>
<p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p>
<p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p>
<pre><code class="language-js">var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的
var json = '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'; //这是一个 JSON 字符串，本质是一个字符串
</code></pre>
<h3 id="102-json和js互转">10.2 JSON和JS互转</h3>
<p><strong>JSON 和 JavaScript 对象互转</strong></p>
<p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p>
<pre><code class="language-js">var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}');
//结果是 {a: 'Hello', b: 'World'}
</code></pre>
<p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p>
<pre><code class="language-js">var json = JSON.stringify({a: 'Hello', b: 'World'});
//结果是 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'
</code></pre>
<h2 id="11-拦截器">11. 拦截器</h2>
<h3 id="111-概述">11.1 概述</h3>
<p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p>
<p><strong>过滤器与拦截器的区别：</strong><mark>拦截器是AOP思想的具体应用</mark>。</p>
<p><strong>过滤器</strong></p>
<ul>
<li>servlet规范中的一部分，任何java web工程都可以使用</li>
<li>*<em>在url-pattern中配置了/<em>之后，可以对所有要访问的资源进行拦截</em></em></li>
</ul>
<p><strong>拦截器</strong></p>
<ul>
<li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li>
<li>拦截器<strong>只会拦截访问的控制器方法</strong>， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li>
</ul>
<h3 id="112-自定义拦截器">11.2 自定义拦截器</h3>
<p>想要自定义拦截器，<strong><mark>必须实现 HandlerInterceptor 接口</mark></strong>。</p>
<p>1、新建一个Moudule ， springmvc-09-Interceptor  ， 添加web支持</p>
<p>2、配置web.xml 和 applicationContext.xml 文件</p>
<p>3、编写一个拦截器</p>
<pre><code class="language-java">package cn.edu.bupt.config;

import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class MyInterceptor implements HandlerInterceptor {
    @Override
    //return true; 执行下一个拦截器，放行
    //return false;  不执行下一个拦截器
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;============处理前=============&quot;);
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;============处理后=============&quot;);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;============清理=============&quot;);
    }
}
</code></pre>
<p>4、在springmvc的配置文件中配置拦截器</p>
<blockquote>
<p><mark>/** :包括路径及其子路径</mark></p>
<p><mark><strong>/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截</strong></mark></p>
<p><mark><strong>/admin/</strong> 拦截的是/admin/下的所有**</mark></p>
</blockquote>
<pre><code class="language-xml">&lt;!--拦截器配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;!--/** 包括路径及其子路径--&gt;
    &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
    &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;bean class=&quot;cn.edu.bupt.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>5、编写一个Controller，接收请求</p>
<pre><code class="language-java">package cn.edu.bupt.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    @RequestMapping(&quot;/t1&quot;)
    public String test() {
        System.out.println(&quot;TestController==&gt; test()执行了&quot;);
        return &quot;OK&quot;;
    }
}
</code></pre>
<p>6、启动tomcat 测试一下！</p>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210507233934892.png" alt="image-20210507233934892" loading="lazy"></figure>
<p>补充：</p>
<p>当把拦截器的方法<code>preHandle</code>返回值改为false，则出现：  <strong><mark>test方法没有执行！</mark></strong></p>
<pre><code class="language-java">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    System.out.println(&quot;============处理前=============&quot;);
    return false;
}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210507234653894.png" alt="image-20210507234653894" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210507234707183.png" alt="image-20210507234707183" loading="lazy"></figure>
<h3 id="113-登录判断验证">11.3 登录判断验证</h3>
<p><strong>实现思路</strong></p>
<p>1、有一个登陆页面，需要写一个controller访问页面。</p>
<p>2、登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></p>
<p>3、拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</p>
<p><strong>测试：</strong></p>
<p>1、编写一个登陆页面  login.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%--在Web-inf下面的所有页面或者资源,只能通过controller,或者servlet进行访问--%&gt;

&lt;h1&gt;登录页面&lt;/h1&gt;

&lt;form action=&quot;${pageContext.request.contextPath}/user/login&quot; method=&quot;post&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;
    密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2、编写一个Controller处理请求</p>
<pre><code class="language-java">package cn.edu.bupt.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpSession;

@Controller
@RequestMapping(&quot;/user&quot;)
public class LoginController {

    @RequestMapping(&quot;/main&quot;)
    public String main() {
        return &quot;main&quot;;
    }

    @RequestMapping(&quot;/goLogin&quot;)
    public String login() {
        return &quot;login&quot;;
    }


    @RequestMapping(&quot;/login&quot;)
    public String login(HttpSession session, String username, String password, Model model) {

        //把用户信息存在session中
        session.setAttribute(&quot;userLoginInfo&quot;, username);
        model.addAttribute(&quot;username&quot;, username);
        return &quot;main&quot;;
    }

    @RequestMapping(&quot;/goOut&quot;)
    public String goOut(HttpSession session) {
        session.removeAttribute(&quot;userLoginInfo&quot;);
        return &quot;main&quot;;
    }

}
</code></pre>
<p>3、编写一个登陆成功的页面 main.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;首页&lt;/h1&gt;

&lt;span&gt;${username}&lt;/span&gt;

&lt;p&gt;
    &lt;a href=&quot;${pageContext.request.contextPath}/user/goOut&quot;&gt;注销&lt;/a&gt;
&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>4、在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;$Title$&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;


  &lt;h1&gt;&lt;a href=&quot;${pageContext.request.contextPath}/user/goLogin&quot;&gt;登录页面&lt;/a&gt;&lt;/h1&gt;

  &lt;h1&gt;&lt;a href=&quot;${pageContext.request.contextPath}/user/main&quot;&gt;首页&lt;/a&gt;&lt;/h1&gt;


  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>5、编写用户登录拦截器</p>
<pre><code class="language-java">package cn.edu.bupt.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        HttpSession session = request.getSession();
        //放行：判断什么情况下登录了
        if (session.getAttribute(&quot;userLoginInfo&quot;) != null) {
            return true;
        }

        //登录页面也会放行
        if (request.getRequestURI().contains(&quot;goLogin&quot;)) {
            return true;
        }

        //说明我在提交登录
        if (request.getRequestURI().contains(&quot;login&quot;)) {
            return true;
        }

        //判断什么情况下没有登录
        request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request, response);
        return false;
    }
}
</code></pre>
<p>6、在Springmvc的配置文件中注册拦截器</p>
<pre><code class="language-xml">&lt;!--拦截器配置--&gt;
&lt;mvc:interceptors&gt;
    &lt;!--/** 包括路径及其子路径--&gt;
    &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;
    &lt;!--/admin/** 拦截的是/admin/下的所有--&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;bean class=&quot;cn.edu.bupt.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
    &lt;mvc:interceptor&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;cn.edu.bupt.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>7、再次重启Tomcat测试！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring 2021.1.25]]></title>
        <id>https://chase-don.github.io/post/spring-2021125/</id>
        <link href="https://chase-don.github.io/post/spring-2021125/">
        </link>
        <updated>2021-01-26T01:05:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="spring-2021125">Spring 2021.1.25</h1>
<h2 id="1spring">1.Spring</h2>
<h3 id="11简介略">1.1简介（略）</h3>
<h3 id="12-优点">1.2 优点</h3>
<ul>
<li>Spring是一个开源的免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC），面向切面编程（AOP）</li>
<li>支持事务的处理，对框架整合的支持</li>
</ul>
<p><strong>总结：Spring就是一个轻量级的控制反转(IOC)和面向切面编程(AOP)的框架</strong></p>
<h3 id="13-组成">1.3 组成</h3>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/1615489824192.png" alt="" loading="lazy"></figure>
<h2 id="2-ioc理论推导">2. IOC理论推导</h2>
<ol>
<li>UserDao接口</li>
<li>UserDaoImpl实现类</li>
<li>UserService业务接口</li>
<li>UserServiceImpl业务实现类</li>
</ol>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！</p>
<p>我们使用一个set接口实现</p>
<pre><code class="language-java">    private UserDao userDao;

    //利用set进行动态实现值的注入！
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

</code></pre>
<p>Test中：</p>
<pre><code class="language-java">public static void main(String[] args) {

    //用户实际调用的是业务层，DAO层不需要接触！
    UserServiceImpl userService = new UserServiceImpl();
    userService.setUserDao(new UserDaoOracleImpl());
    userService.getUser();
}
}
</code></pre>
<ul>
<li>之前，程序是主动创建对象，控制权在程序员手中</li>
<li>使用set注入后，程序不再具有主动性，而是变成<strong>被动接收对象</strong>，由用户根据需求来创建对象!</li>
</ul>
<p><strong>这种思想从本质上解决了问题，我们程序员不用再去管理对象的创建了！</strong></p>
<h3 id="ioc本质">IOC本质</h3>
<p>**控制反转IoC（Inversion of Control）是一种设计思想，DI（依赖注入）是实现IoC的一种方法。**也有人认为DI只是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方（用户），个人认为所谓的控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection, DI）</strong></p>
<h2 id="3-hellospring">3. HelloSpring</h2>
<p>pojo：</p>
<pre><code class="language-java">public class Hello {
    private String str;
    public String getStr() {
        return str;
    }
    public void setStr(String str) {
        this.str = str;
    }
    @Override
    public String toString() {
        return &quot;Hello{&quot; +
                &quot;str='&quot; + str + '\'' +
                '}';
    }
}
</code></pre>
<p>Spring配置文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--使用Spring来创建对象，在Spring中这些都称为Bean

    类型  变量名 = new 类型();
    Hello hello = new Hello();

    id = 变量名
    class = new 的对象
    property  相当于给对象中的属性设置一个值！
    ref: 引用Spring容器中创建好的对象
    value： 具体的值，简单类型
    --&gt;
    &lt;bean id=&quot;hello&quot; class=&quot;cn.edu.bupt.pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre>
<p>测试类：</p>
<pre><code class="language-java">public class MyTest {
    public static void main(String[] args) {
        //获取Spring的上下文对象(解析beans.xml文件，生成管理相应的Bean对象)
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        //我们的对象现在都在Spring中管理了，我们要使用，直接去里面取出来就可以！
        //getBean： 参数即为spring配置文件中bean的id
        Hello hello = (Hello) context.getBean(&quot;hello&quot;);
        System.out.println(hello.toString());

    }
}
</code></pre>
<h3 id="思考问题">思考问题</h3>
<ul>
<li>
<p>Hello对象是谁创建的？</p>
<p>hello对象是由Spring创建的</p>
</li>
<li>
<p>Hello对象的属性是怎么设置的？</p>
<p>hello对象的属性是由Spring容器设置的</p>
</li>
</ul>
<p>这个过程就叫控制反转：</p>
<p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用Spring后，对象是由Spring来创建的</p>
<p>反转：程序本身不创建对象，而被动的接受对象</p>
<p>依赖注入（DI）：就是利用set方法来进行注入的</p>
<p>IOC是一种编程思想，由主动的编程编程被动的接收。即：对象由Spring来创建，管理，装配！</p>
<h2 id="4-ioc创建对象的方式">4. IoC创建对象的方式</h2>
<ol>
<li>
<p>使用无参构造创建对象，默认！</p>
</li>
<li>
<p>假设我们要使用有参构造创建对象</p>
<ol>
<li>
<p>下标赋值(index后面的数字是有参构造的第几个参数)</p>
<pre><code class="language-xml">&lt;!--第一种方式： 下标赋值--&gt;
&lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;chase&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>根据类型赋值</p>
<pre><code class="language-xml">&lt;!--第二种方式： 通过类型创建，不建议使用！！！  有两个类型相同的没有办法操作--&gt;
&lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;loro&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>参数名</p>
<pre><code class="language-xml">&lt;!--第三种方式： 直接通过参数名来设置--&gt;
&lt;!--如果有参构造传入的是自定义的类，则用ref引入自定义类，否则可以直接通过参数名来设置--&gt;
&lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;ds&quot;/&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<p><strong>总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！</strong></p>
<h2 id="5-spring配置">5. Spring配置</h2>
<h3 id="51-别名">5.1 别名</h3>
<pre><code class="language-xml">&lt;!--别名，如果添加了别名，我们也可以使用别名获取到这个对象--&gt;
&lt;alias name=&quot;user&quot; alias=&quot;userNew&quot;/&gt;
</code></pre>
<h3 id="52-bean的配置">5.2 Bean的配置</h3>
<pre><code class="language-xml">&lt;!--
	id: bean的唯一标识符，也就是相当于我们学的变量名
    class：bean对象所对应的全限定名（包名 + 类型）
    name：也是别名，而且name可以同时取多个别名
--&gt;
&lt;bean id=&quot;userT&quot; class=&quot;cn.edu.bupt.pojo.UserT&quot; name=&quot;u2,uuu,user2&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;xm&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="53-import">5.3 import</h3>
<p>一般用于团队开发使用，它可以将多个配置文件，导入合并成一个</p>
<p>假设项目有多个人开发，多人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以用import将所有人的beans.xml合并为一个总的，使用的时候，直接使用总的就可以了</p>
<h2 id="6-依赖注入">6. 依赖注入</h2>
<h3 id="61-构造器注入">6.1 构造器注入</h3>
<p>前面已经讲过了</p>
<h3 id="62-set方式注入重点">6.2 Set方式注入【重点】</h3>
<ul>
<li>依赖注入：Set注入
<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p>【环境搭建】（spring-04-di）</p>
<ol>
<li>
<p>复杂类型</p>
<pre><code class="language-java">public class Address {
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;Address{&quot; +
                &quot;address='&quot; + address + '\'' +
                '}';
    }
}
</code></pre>
</li>
<li>
<p>真实测试对象</p>
<pre><code class="language-java">略
</code></pre>
</li>
<li>
<p>beans.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;address&quot; class=&quot;cn.edu.bupt.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;yancheng&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;student&quot; class=&quot;cn.edu.bupt.pojo.Student&quot;&gt;
        &lt;!--第一种，普通值注入，value--&gt;
        &lt;property name=&quot;name&quot; value=&quot;ds&quot;/&gt;
        &lt;!--第二种， Bean注入， ref--&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;

        &lt;!--数组注入--&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;西游记&lt;/value&gt;
                &lt;value&gt;三国演义&lt;/value&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;

        &lt;!--List--&gt;
        &lt;property name=&quot;hobbys&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;睡觉&lt;/value&gt;
                &lt;value&gt;写代码&lt;/value&gt;
                &lt;value&gt;看书&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;!--Map--&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;111111&quot;/&gt;
                &lt;entry key=&quot;联系方式&quot; value=&quot;123123&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;

        &lt;!--Set--&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;BOB&lt;/value&gt;
                &lt;value&gt;COC&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;

&lt;!--        &amp;lt;!&amp;ndash;如果为空字符串&amp;ndash;&amp;gt;--&gt;
&lt;!--        &lt;property name=&quot;wife&quot; value=&quot;&quot;/&gt;--&gt;

        &lt;!--属性值设为null--&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;

        &lt;!--Properties--&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;driver&quot;&gt;jdbcmysql&lt;/prop&gt;
                &lt;prop key=&quot;url&quot;&gt;mysql&lt;/prop&gt;
                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;
                &lt;prop key=&quot;password&quot;&gt;111111&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;

    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>测试类</p>
<pre><code class="language-java">public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    Student student = (Student) context.getBean(&quot;student&quot;);
    System.out.println(student);


    /**
         * Student{name='ds',
         * address=Address{address='yancheng'},
         * books=[西游记, 三国演义, 红楼梦, 水浒传],
         * hobbys=[睡觉, 写代码, 看书],
         * card={身份证=111111, 联系方式=123123},
         * games=[LOL, BOB, COC], wife='null',
         * info={password=111111, url=mysql, driver=jdbcmysql, username=root}}
         */
}
</code></pre>
</li>
</ol>
<h3 id="63-拓展方式注入">6.3 拓展方式注入</h3>
<p><strong>我们可以使用p-namespace和c-namespace进行注入</strong></p>
<p>官方解释：https://docs.spring.io/spring-framework/docs/5.2.12.RELEASE/spring-framework-reference/core.html#beans-collection-elements</p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/1615489902287.png" alt="" loading="lazy"></figure>
<pre><code class="language-xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
</code></pre>
<p><strong>p-namespace:(property) ： 可以直接注入属性的值</strong></p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean name=&quot;classic&quot; class=&quot;com.example.ExampleBean&quot;&gt;
        &lt;property name=&quot;email&quot; value=&quot;someone@somewhere.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean name=&quot;p-namespace&quot; class=&quot;com.example.ExampleBean&quot;
        p:email=&quot;someone@somewhere.com&quot;/&gt;
&lt;/beans&gt;
</code></pre>
<p><strong>c-namespace:(constructor) : 可以注入构造方法的值，更加容易方便</strong></p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;
    &lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt;

    &lt;!-- traditional declaration with optional argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt;
        &lt;constructor-arg name=&quot;thingTwo&quot; ref=&quot;beanTwo&quot;/&gt;
        &lt;constructor-arg name=&quot;thingThree&quot; ref=&quot;beanThree&quot;/&gt;
        &lt;constructor-arg name=&quot;email&quot; value=&quot;something@somewhere.com&quot;/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration with argument names --&gt;
    &lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot; c:thingTwo-ref=&quot;beanTwo&quot;
        c:thingThree-ref=&quot;beanThree&quot; c:email=&quot;something@somewhere.com&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p><em><strong>注意点：p-namespace和c-namespace不能直接使用，需要导入xml约束！</strong></em></p>
<h3 id="64-bean的作用域">6.4 Bean的作用域</h3>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/1615489929298.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>单例模式（Spring默认机制）</p>
<pre><code class="language-xml">scope = &quot;singleton&quot;
</code></pre>
</li>
<li>
<p>原型模式：每次从容器中get的时候，都会产生一个新对象！</p>
<pre><code class="language-xml">scope = &quot;prototype&quot;
</code></pre>
</li>
<li>
<p>其余的几个作用域只能在web开发中使用到！</p>
</li>
</ol>
<h2 id="7-bean的自动装配">7. Bean的自动装配</h2>
<ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种自动装配的方式：</p>
<ol>
<li>在xml中显示的配置</li>
<li>在java中显示配置</li>
<li><strong>隐式的自动装配bean【重要】</strong></li>
</ol>
<h3 id="71-测试">7.1 测试</h3>
<p>环境搭建：<strong>一个人有两个不同的宠物!(三个对象)</strong></p>
<h3 id="72-byname自动装配">7.2 ByName自动装配</h3>
<pre><code class="language-xml">&lt;!--
    byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid（这里区分大小写，例如setDog对应即dog，若是大写Dog，则查找不到）
    --&gt;
&lt;bean id=&quot;person&quot; class=&quot;cn.edu.bupt.pojo.Person&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;ds&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="73-bytype自动装配">7.3 ByType自动装配</h3>
<pre><code class="language-xml">&lt;bean class=&quot;cn.edu.bupt.pojo.Cat&quot;/&gt;
&lt;bean class=&quot;cn.edu.bupt.pojo.Dog&quot;/&gt; //id都可以省略

&lt;!--
    byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid（这里区分大小写，例如setDog对应即dog，若是大写Dog，则查找不到）
    byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean
    --&gt;
&lt;bean id=&quot;person&quot; class=&quot;cn.edu.bupt.pojo.Person&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;ds&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>小结：</p>
<ul>
<li>byName的时候，需要保证<strong>所有bean的<em>id</em>唯一</strong>，并且这个bean需要和自动注入的属性的set方法后面的值一致</li>
<li>byType的时候，需要保证<strong>所有bean的<em>class</em>唯一</strong>，并且这个bean需要和自动注入的属性的类型一致！</li>
</ul>
<h3 id="74-使用注解实现自动装配"><em>7.4 使用注解实现自动装配</em></h3>
<p>要使用注解须知：</p>
<ol>
<li>
<p>导入约束： context约束</p>
</li>
<li>
<p>配置注解的支持：<a href="context:annotation-config/">context:annotation-config/</a></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;
</code></pre>
</li>
</ol>
<h4 id="autowired"><strong>@Autowired</strong></h4>
<p>直接在属性上使用即可，也可以在set方法上使用！</p>
<p>使用Autowired 我们可以不用编写Set方法了，前提是这个自动装配的属性在IOC(Spring)容器中存在，<strong>默认按照bean的类型进行装配(byType),当找到多个相同类型时，会自动byName，如果byName也不行(byName的话首先依旧是先根据类名对应的小写寻找)，才会报错</strong></p>
<p>科普：</p>
<pre><code class="language-java">@Nullable       字段标记了这个注解，说明这个字段可以为null
</code></pre>
<pre><code class="language-java">//下面是@Autowired的源代码，注意他的默认是true
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Autowired {
    boolean required() default true;
}
</code></pre>
<p><strong>如果显示定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空</strong></p>
<pre><code class="language-java">@Autowired(required = false)
private Dog dog;
</code></pre>
<p><strong>又如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候，我们可以使用注解【@Qualifier(value=&quot;xxx&quot;)】去 配置@Autowired的使用，指定一个唯一的bean对象注入！</strong></p>
<pre><code class="language-java">public class Person {
    @Autowired
    @Qualifier(value = &quot;dog111&quot;)
    private Dog dog;
    @Autowired
    @Qualifier(value = &quot;cat11&quot;)
    private Cat cat;
    private String name;	
}
</code></pre>
<h4 id="resource注解"><strong>@Resource注解</strong></h4>
<pre><code class="language-java">public class Person {
    @Resource
    private Dog dog;
    @Resource(name = &quot;cat1&quot;)
    private Cat cat;
    private String name;
}
</code></pre>
<p>@Resource情况比较特殊，经过测试得知：</p>
<ul>
<li>如果都只有一个类型只有一个，则无论beanid是什么都可以自动装配；(下图)</li>
<li>如果同一个类型有多个，则有beanid符合byname的条件，即可完成自动装配；(下图)</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/1615489973242.png" alt="" loading="lazy"></figure>
<ul>
<li>如果同一类型有多个，且没有beanid符合byname的要求，那么需要在注解上进行完善，即：@Resource(name = &quot;xxx&quot;)，指定一个唯一的bean对象进行注入(代码如上面那个代码块所示，图如下)</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/1615490011080.png" alt="" loading="lazy"></figure>
<p><strong>@Resource和@Autowired的区别：</strong></p>
<ul>
<li>都是用来自动装配的，都可以放在属性字段上</li>
<li>@Autowired 默认通过byType的方式实现，而且必须要求这个对象存在！如果允许不存在需要在注解后添加(required = false)</li>
<li>@Resource 默认通过byName的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错</li>
<li>执行顺序不同，已经提及到了  @Autowired —&gt;byType; @Resource —&gt;byName</li>
<li>具体可看下文：https://blog.csdn.net/ajax11111/article/details/50057297?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</li>
</ul>
<h2 id="8-使用注解开发">8. 使用注解开发</h2>
<p>在Spring4之后，要使用注解开发，必须要保证aop的包导入了</p>
<p><img src="https://chase-don.github.io//post-images/1615490039316.png" alt="" loading="lazy">🤣</p>
<p>使用注解需要啊导入context约束，增加注解的支持！</p>
<ol>
<li>
<p>bean</p>
</li>
<li>
<p>属性如何注入</p>
<pre><code class="language-java">//等价于 &lt;bean id=&quot;user&quot; class=&quot;cn.edu.bupt.pojo.User&quot;/&gt;
// Component 翻译就是组件
@Component
public class User {
    public String name;

    //相当于在xml配置文件里面写入property
    @Value(&quot;loro&quot;)
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
</li>
<li>
<p>衍生的注解</p>
<p>@Component 有几个衍生注解，我们在web开发中，会按照mvc三层架构分层！</p>
<ul>
<li>
<p>dao   【@Repository】</p>
</li>
<li>
<p>service 【@Service】</p>
</li>
<li>
<p>controller 【@Controller】</p>
<p><strong>这四个注解功能都是一样的，都是代表将某个类注册到Spring中，装配Bean</strong></p>
</li>
</ul>
</li>
<li>
<p>自动装配</p>
<ul>
<li>
<p>@Autowired：自动装配  byType -&gt; byName<br>
如果Autowired不能唯一自动装配上属性，则需要通过 @Qualifier(value = &quot;xxx&quot;)</p>
</li>
<li>
<p>@Nullable   :  字段标记了这个注解则说明这个字段可以为null</p>
</li>
<li>
<p>@Resource：自动装配  byName -&gt; byType</p>
</li>
</ul>
</li>
<li>
<p>作用域</p>
<pre><code class="language-java">@Component
@Scope(&quot;singleton&quot;)
public class User {
    public String name;

    //相当于在xml配置文件里面写入property
    @Value(&quot;loro&quot;)
    public void setName(String name) {
        this.name = name;
    }
}
</code></pre>
</li>
<li>
<p>小结</p>
<p>xml与注解：</p>
<ul>
<li>xml更加万能，适用于任何场合！维护简单方便</li>
<li>注解：不是自己的类使用不了，维护相对复杂</li>
</ul>
<p>xml与注解的最佳实践：</p>
<ul>
<li>
<p>xml用来管理bean；</p>
</li>
<li>
<p>注解只负责属性的注入</p>
</li>
<li>
<p>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要<strong>开启注解的支持</strong></p>
<pre><code class="language-xml">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;
&lt;context:component-scan base-package=&quot;cn.edu.bupt&quot;/&gt;
&lt;context:annotation-config/&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="9-使用java的方式配置spring">9. 使用java的方式配置Spring</h2>
<p>我们现在要完全不适用Spring的xml配置了，全权交给java来做！</p>
<p><strong>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能！</strong></p>
<p>实体类</p>
<pre><code class="language-java">//这里这个注解的意思，就是说明这个类被spring接管了，注册到了容器中
@Component
public class User {
    private String name;

    public String getName() {
        return name;
    }

    @Value(&quot;loro&quot;)  //属性注入值
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;name='&quot; + name + '\'' +
                '}';
    }
}
</code></pre>
<p>配置文件</p>
<pre><code class="language-java">package cn.edu.bupt.config;

import cn.edu.bupt.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

//这个也会被Spring容器接管，注册到容器中，因为他本来就是一个@Component
// @Configuration代表这是一个配置类，就和我们之前看的beans.xml相同
@Configuration
@ComponentScan(&quot;cn.edu.bupt.pojo&quot;)
@Import(MyConfig2.class)
public class MyConfig {

    // 注册一个bean，就相当于我们之前写的一个bean标签
    // id = 这个方法的名字
    // class = 方法的返回值所属类
    @Bean
    public User getUser() {
        return new User();  //就是返回要注入到bean的对象
    }

}
</code></pre>
<p>测试类</p>
<pre><code class="language-java">import cn.edu.bupt.config.MyConfig;
import cn.edu.bupt.pojo.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MyTest {
    public static void main(String[] args) {
        // 如果完全使用了配置类方式取去做，我们只能通过 AnnotationConfig 上下文来获取容器，通过配置类的class对象加载！
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User getUser = (User) context.getBean(&quot;getUser&quot;);
        System.out.println(getUser.getName());
    }
}
</code></pre>
<p><strong>这种纯java的配置方式，在springboot中随处可见！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux快速入门]]></title>
        <id>https://chase-don.github.io/post/linux-kuai-su-ru-men/</id>
        <link href="https://chase-don.github.io/post/linux-kuai-su-ru-men/">
        </link>
        <updated>2021-01-17T17:34:21.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p><strong>以下是对这些目录的解释：</strong></p>
<ul>
<li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li>
<li><mark><strong>/etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</strong></mark></li>
<li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li>
<li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li>
<li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li>
<li><strong>/mnt</strong>：系统 提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li>
<li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li>
<li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li>
<li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li>
<li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li>
<li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li>
<li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li>
<li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li>
<li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li>
<li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li>
<li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li>
</ul>
<h2 id="1-常用基本命令">1. 常用基本命令</h2>
<h3 id="11-目录管理">1.1 目录管理</h3>
<h4 id="111-cdchange-directory-切换目录">1.1.1 <strong>cd：Change Directory</strong> 切换目录</h4>
<p>cd 目录名（绝对路径都是以<code>/</code>开头，相对路径则是相对于当前目录该如何寻找，比如上一层是..）</p>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/1620581990193.png" alt="" loading="lazy"></figure>
<h4 id="112-ls-list-files">1.1.2 <strong>ls:  list files</strong></h4>
<p>在Linux中，ls可能是最常被使用的命令</p>
<p><strong><mark>-a 参数</mark>：all，查看全部的文件，包括隐藏文件</strong></p>
<p><strong><mark>-l 参数</mark>：列出所有的文件，包含文件的属性和权限，没有隐藏文件</strong></p>
<p>所有linux命令可以组合使用！</p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210429121628056.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210429121647440.png" alt="image-20210429121647440" loading="lazy"></figure>
<h4 id="113-pwdprint-working-directory-显示当前工作路径">1.1.3 <strong>pwd：Print working directory</strong>  显示当前工作路径</h4>
<pre><code class="language-shell">[root@iZbp15ffn4eeeac2w3lat9Z ~]# pwd
/root
[root@iZbp15ffn4eeeac2w3lat9Z ~]# cd /home
[root@iZbp15ffn4eeeac2w3lat9Z home]# pwd
/home
[root@iZbp15ffn4eeeac2w3lat9Z home]# cd /usr/local
[root@iZbp15ffn4eeeac2w3lat9Z local]# pwd
/usr/local
</code></pre>
<h4 id="114-mkdirmkdirmake-directory-建立目录">1.1.4 <strong>mkdir：mkdir：Make directory</strong> 建立目录</h4>
<p><strong><mark>mkdir -p：创建层级目录</mark></strong></p>
<pre><code class="language-bash">[root@iZbp15ffn4eeeac2w3lat9Z /]# cd home
[root@iZbp15ffn4eeeac2w3lat9Z home]# ls
admin  chase
[root@iZbp15ffn4eeeac2w3lat9Z home]# mkdir test1
[root@iZbp15ffn4eeeac2w3lat9Z home]# ls
admin  chase  test1
[root@iZbp15ffn4eeeac2w3lat9Z home]# mkdir -p test/test1/test2
[root@iZbp15ffn4eeeac2w3lat9Z home]# ls
admin  chase  test  test1
[root@iZbp15ffn4eeeac2w3lat9Z home]# cd test
[root@iZbp15ffn4eeeac2w3lat9Z test]# ls
test1
[root@iZbp15ffn4eeeac2w3lat9Z test]# cd test1
[root@iZbp15ffn4eeeac2w3lat9Z test1]# ls
test2
</code></pre>
<h4 id="115-rmdirremove-directory-删除目录">1.1.5 <strong>rmdir：Remove directory</strong> 删除目录</h4>
<p><strong><mark>rmdir仅能删除空的目录，如果下面存在文件，需要先删除文件；递归删除多个目录用<code>-p</code>参数即可</mark></strong></p>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210429124032285.png" alt="" loading="lazy"></figure>
<h4 id="116-cp-复制文件或者目录">1.1.6 <strong>cp: 复制文件或者目录</strong></h4>
<p><strong>格式为：cp  [源文件]  [目标地方]</strong></p>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210429125030597.png" alt="image-20210429125030597" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/image-20210429125144008.png" alt="image-20210429125144008" loading="lazy"></figure>
<h4 id="117-rm-remove-file-删除文件">1.1.7 <strong>rm: Remove file 删除文件</strong></h4>
<p><strong>-f ：忽略不存在的文件，不会出现警告，强制删除</strong></p>
<p><strong>-r ：递归删除目录</strong></p>
<p><strong>-i ：互动，删除询问是否删除</strong></p>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210429125547136.png" alt="image-20210429125547136" loading="lazy"></figure>
<h4 id="118-mv-move-file-移动文件或目录-或者-可以用来重命名文件">1.1.8 <strong>mv: Move file 移动文件或目录  或者  可以用来重命名文件</strong></h4>
<p>-f ：强制移动，不出现警告</p>
<p>-u ：只替换已经更新过的文件</p>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210429130246295.png" alt="image-20210429130246295" loading="lazy"></figure>
<h3 id="12-文件基本属性十个字母">1.2 文件基本属性（十个字母）</h3>
<h4 id="121-看懂文件属性">1.2.1 看懂文件属性</h4>
<p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p>
<p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210429130956447.png" alt="image-20210429130956447" loading="lazy"></figure>
<p>实例中，boot文件的第一个属性用**&quot;d&quot;**表示。&quot;d&quot;在Linux中代表该文件是一个目录文件。</p>
<p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p>
<ul>
<li><mark>当为[ <strong>d</strong> ]则是目录</mark></li>
<li><mark>当为[ <strong>-</strong> ]则是文件；</mark></li>
<li><mark>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</mark></li>
<li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li>
<li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li>
</ul>
<p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p>
<p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p>
<p>要注意的是，<strong>这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已</strong>。</p>
<p>每个文件的属性由左边第一部分的10个字符来确定（如下图）：</p>
<figure data-type="image" tabindex="10"><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauEybzG2XIdlOMLyO13lMfPKUWRpGJGgyxCAJ9mics9dTZ1qrWDIvleYQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" loading="lazy"></figure>
<p>从左至右用0-9这些数字来表示。</p>
<p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p>
<p>其中：</p>
<p>第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限；</p>
<p>第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限；</p>
<p>第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。</p>
<p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p>
<p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p>
<p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p>
<p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p>
<p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p>
<h4 id="122-修改文件属性三个指令chgrpchownchmod">1.2.2 修改文件属性（三个指令，chgrp，chown，chmod）</h4>
<p><strong>1、chgrp：更改文件属组</strong></p>
<pre><code>chgrp [-R] 属组名 文件名
</code></pre>
<p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p>
<p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p>
<pre><code>chown [–R] 属主名 文件名
chown [-R] 属主名：属组名 文件名
</code></pre>
<p><mark><strong>3、chmod：更改文件9个属性（必须要掌握）</strong></mark></p>
<pre><code>chmod [-R] xyz 文件或目录
</code></pre>
<p>Linux文件属性有两种设置方法，一种是数字（常用），一种是符号。</p>
<p>Linux文件的基本权限就有九个，分别是<strong>owner/group/others三种身份各有自己的read/write/execute权限</strong>。</p>
<p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p>
<pre><code class="language-bash">r:4     w:2         x:1

可读可写不可执行	rw-  6
可读可写可执行		rwx  7

chmod 777   ---&gt;    文件赋予所有用户可读可写可执行！
</code></pre>
<p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx---] 分数则是：</p>
<ul>
<li>owner = rwx = 4+2+1 = 7</li>
<li>group = rwx = 4+2+1 = 7</li>
<li>others= --- = 0+0+0 = 0</li>
</ul>
<pre><code class="language-bash">chmod 770 filename
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://chase-don.github.io//post-images/image-20210429133407420.png" alt="image-20210429133407420" loading="lazy"></figure>
<h3 id="13-文件内容查看">1.3 文件内容查看</h3>
<h4 id="131-概述">1.3.1 概述</h4>
<p><strong>Linux系统中使用以下命令来查看文件的内容：</strong></p>
<ul>
<li><strong>cat 由第一行开始显示文件内容（用来读文章或者读取配置文件）</strong></li>
<li><strong>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</strong></li>
<li><strong>nl  显示的时候，顺道输出行号！</strong></li>
<li><strong>more 一页一页的显示文件内容</strong></li>
<li><strong>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</strong></li>
<li><strong>head 只看头几行</strong></li>
<li><strong>tail 只看尾巴几行</strong></li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<p>网络配置目录：<mark><strong>cd /etc/sysconfig/network-scripts</strong></mark></p>
<figure data-type="image" tabindex="12"><img src="https://chase-don.github.io//post-images/image-20210429143613131.png" alt="image-20210429143613131" loading="lazy"></figure>
<p><code>ifconfig</code>命令查看网路配置！</p>
<h4 id="132-cat-由第一行开始显示文件内容">1.3.2 cat 由第一行开始显示文件内容</h4>
<p>语法：</p>
<pre><code>cat [-AbEnTv]
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>测试：</p>
<pre><code># 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/
[root@kuangshen ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0
BOOTPROTO=dhcp
ONBOOT=yes
</code></pre>
<h4 id="133-tac">1.3.3 tac</h4>
<p><strong>tac与cat命令刚好相反</strong>，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<pre><code>[root@kuangshen ~]# tac /etc/sysconfig/network-scripts/ifcfg-eth0
ONBOOT=yes
BOOTPROTO=dhcp
DEVICE=eth0
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://chase-don.github.io//post-images/image-20210429144225047.png" alt="image-20210429144225047" loading="lazy"></figure>
<h4 id="134-nl-显示行号">1.3.4 nl  显示行号</h4>
<p>语法：</p>
<pre><code>nl [-bnw] 文件
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>测试：</p>
<figure data-type="image" tabindex="14"><img src="https://chase-don.github.io//post-images/image-20210429144748179.png" alt="image-20210429144748179" loading="lazy"></figure>
<h4 id="135-more-一页一页翻动">1.3.5 more  一页一页翻动</h4>
<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li><strong>空白键 (space)：代表向下翻一页；</strong></li>
<li><strong>Enter   ：代表向下翻『一行』；</strong></li>
<li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li><strong>:f    ：立刻显示出档名以及目前显示的行数；</strong></li>
<li>q    ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://chase-don.github.io//post-images/image-20210429152632215.png" alt="image-20210429152632215" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://chase-don.github.io//post-images/image-20210429145607624.png" alt="image-20210429145607624" loading="lazy"></figure>
<h4 id="136-less-一页一页翻动可以往前翻页">1.3.6 less  一页一页翻动（可以往前翻页）</h4>
<p>less运行时可以输入的命令有：</p>
<ul>
<li><strong>空白键  ：向下翻动一页；</strong></li>
<li><strong>[pagedown]：向下翻动一页；</strong></li>
<li><strong>[pageup] ：向上翻动一页；</strong></li>
<li><strong>/字串  ：向下搜寻『字串』的功能；</strong></li>
<li><strong>?字串  ：向上搜寻『字串』的功能；</strong></li>
<li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>
<li><strong>q   ：离开 less 这个程序；</strong></li>
</ul>
<h4 id="137-head-取出文件前面几行">1.3.7 head  取出文件前面几行</h4>
<p>语法：</p>
<pre><code>head [-n number] 文件
</code></pre>
<p>选项与参数：<strong>-n</strong> 后面接数字，代表显示几行的意思！</p>
<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<pre><code class="language-bash">[root@iZbp15ffn4eeeac2w3lat9Z etc]# head -n 20 csh.login 
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://chase-don.github.io//post-images/image-20210429150711314.png" alt="image-20210429150711314" loading="lazy"></figure>
<h4 id="138-tail-取出文件后面几行">1.3.8 tail  取出文件后面几行</h4>
<p>语法：</p>
<pre><code>tail [-n number] 文件
</code></pre>
<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p>
<pre><code class="language-bash">[root@iZbp15ffn4eeeac2w3lat9Z etc]# tail -n 20 csh.login 
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://chase-don.github.io//post-images/image-20210429152514695.png" alt="image-20210429152514695" loading="lazy"></figure>
<h3 id="14-拓展linux-链接概念">1.4 拓展：Linux 链接概念</h3>
<p><strong>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</strong></p>
<p>情况下，<strong>ln</strong> 命令产生硬链接。</p>
<h4 id="141-硬连接">1.4.1 <strong>硬连接</strong></h4>
<p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，<strong>多个文件名指向同一索引节点是存在的</strong>。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即<strong>一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</strong></p>
<p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<h4 id="142-软连接">1.4.2 <strong>软连接</strong></h4>
<p>另外一种连接称之为<strong>符号连接（Symbolic Link），也叫软连接</strong>。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p>
<p><strong>测试：</strong></p>
<pre><code class="language-bash">[root@kuangshen /]# cd /home
[root@kuangshen home]# touch f1 # 创建一个测试文件f1
[root@kuangshen home]# ls
f1
[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2
[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3
[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息
397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1
397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2
397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1
</code></pre>
<p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p>
<pre><code class="language-bash"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件
[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1
[root@kuangshen home]# cat f1
I am f1 file
[root@kuangshen home]# cat f2
I am f1 file
[root@kuangshen home]# cat f3
I am f1 file
[root@kuangshen home]# rm -f f1
[root@kuangshen home]# cat f2
I am f1 file
[root@kuangshen home]# cat f3
cat: f3: No such file or directory
</code></pre>
<p>通过上面的测试可以看出：<strong><mark>当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</mark></strong></p>
<p>可以得到以下全部结论：</p>
<ul>
<li>删除符号连接f3,对f1,f2无影响；</li>
<li>删除硬连接f2，对f1,f3也无影响；</li>
<li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li>
<li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li>
</ul>
<h2 id="2-vim编辑器">2. Vim编辑器</h2>
<h3 id="21-三种使用模式">2.1 三种使用模式</h3>
<p>基本上 vi/vim 共分为三种模式，分别是==<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。==</p>
<h4 id="211-命令模式command-mode">2.1.1 命令模式（Command Mode）</h4>
<p>用户刚刚启动 vi/vim，便进入了命令模式。</p>
<p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>以下是常用的几个命令：</p>
<ul>
<li>
<p><strong>i</strong> 切换到==<strong>输入模式</strong>==，以输入字符。</p>
<figure data-type="image" tabindex="19"><img src="https://chase-don.github.io//post-images/image-20210430165540964.png" alt="image-20210430165540964" loading="lazy"></figure>
</li>
<li>
<p><strong>x</strong> 删除当前光标所在处的字符。</p>
</li>
<li>
<p><strong>:</strong> 切换到**<mark>底线命令模式</mark>**，以在最底一行输入命令。</p>
<figure data-type="image" tabindex="20"><img src="https://chase-don.github.io//post-images/image-20210430172215011.png" alt="image-20210430172215011" loading="lazy"></figure>
</li>
</ul>
<p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p>
<p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p>
<figure data-type="image" tabindex="21"><img src="https://chase-don.github.io//post-images/image-20210430173710963.png" alt="image-20210430173710963" loading="lazy"></figure>
<h4 id="212-输入模式">2.1.2 <strong>输入模式：</strong></h4>
<p>在命令模式下按下i就进入了输入模式。</p>
<p>在输入模式中，可以使用以下按键：</p>
<ul>
<li><strong>字符按键以及Shift组合</strong>，输入字符</li>
<li><strong>ENTER</strong>，回车键，换行</li>
<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li>
<li><strong>DEL</strong>，删除键，删除光标后一个字符</li>
<li><strong>方向键</strong>，在文本中移动光标</li>
<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li>
<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li>
<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li><strong>ESC</strong>，退出输入模式，切换到命令模式</li>
</ul>
<h4 id="213-底线命令模式">2.1.3 <strong>底线命令模式</strong></h4>
<p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p>
<p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出底线命令模式。</p>
<p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p>
<figure data-type="image" tabindex="22"><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMIxVoDyQ4LWxSbHDjAYfHuId7xfHHichtqZK2ehsXvcC9KiaibPf68s9dg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" loading="lazy"></figure>
<h3 id="22-vim按键说明">2.2 Vim按键说明</h3>
<p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p>
<p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">移动光标的方法</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">h 或 向左箭头键(←)</td>
<td>光标向左移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">j 或 向下箭头键(↓)</td>
<td>光标向下移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">k 或 向上箭头键(↑)</td>
<td>光标向上移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">l 或 向右箭头键(→)</td>
<td>光标向右移动一个字符</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [f]</td>
<td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [b]</td>
<td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [d]</td>
<td>屏幕『向下』移动半页</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl] + [u]</td>
<td>屏幕『向上』移动半页</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td>光标移动到非空格符的下一行</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td>光标移动到非空格符的上一行</td>
</tr>
<tr>
<td style="text-align:left"><strong>n&lt; space&gt;</strong></td>
<td><strong>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动 n 个字符。</strong></td>
</tr>
<tr>
<td style="text-align:left">0 或功能键[Home]</td>
<td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td>
</tr>
<tr>
<td style="text-align:left">$ 或功能键[End]</td>
<td>移动到这一行的最后面字符处(常用)</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td>光标移动到这个屏幕的最上方那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">M</td>
<td>光标移动到这个屏幕的中央那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td>光标移动到这个屏幕的最下方那一行的第一个字符</td>
</tr>
<tr>
<td style="text-align:left">G</td>
<td>移动到这个档案的最后一行(常用)</td>
</tr>
<tr>
<td style="text-align:left">nG</td>
<td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td>
</tr>
<tr>
<td style="text-align:left">gg</td>
<td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td>
</tr>
<tr>
<td style="text-align:left"><strong>n&lt; Enter&gt;</strong></td>
<td><strong>n 为数字。光标向下移动 n 行(常用)</strong></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">搜索替换</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>/word</strong></td>
<td><strong>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</strong></td>
</tr>
<tr>
<td style="text-align:left">?word</td>
<td>向光标之上寻找一个字符串名称为 word 的字符串。</td>
</tr>
<tr>
<td style="text-align:left">n</td>
<td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td>
</tr>
<tr>
<td style="text-align:left">N</td>
<td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">删除、复制与粘贴</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">x, X</td>
<td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td>
</tr>
<tr>
<td style="text-align:left">nx</td>
<td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td>
</tr>
<tr>
<td style="text-align:left">dd</td>
<td><strong>删除游标所在的那一整行(常用)</strong></td>
</tr>
<tr>
<td style="text-align:left">ndd</td>
<td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td>
</tr>
<tr>
<td style="text-align:left">d1G</td>
<td>删除光标所在到第一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">dG</td>
<td>删除光标所在到最后一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">d$</td>
<td>删除游标所在处，到该行的最后一个字符</td>
</tr>
<tr>
<td style="text-align:left">d0</td>
<td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td><strong>复制游标所在的那一行(常用)</strong></td>
</tr>
<tr>
<td style="text-align:left">nyy</td>
<td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td>
</tr>
<tr>
<td style="text-align:left">y1G</td>
<td>复制游标所在行到第一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">yG</td>
<td>复制游标所在行到最后一行的所有数据</td>
</tr>
<tr>
<td style="text-align:left">y0</td>
<td>复制光标所在的那个字符到该行行首的所有数据</td>
</tr>
<tr>
<td style="text-align:left">y$</td>
<td>复制光标所在的那个字符到该行行尾的所有数据</td>
</tr>
<tr>
<td style="text-align:left">p, P</td>
<td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td>将光标所在行与下一行的数据结合成同一行</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td>
</tr>
<tr>
<td style="text-align:left">u</td>
<td>复原前一个动作。(常用)</td>
</tr>
<tr>
<td style="text-align:left">[Ctrl]+r</td>
<td>重做上一个动作。(常用)</td>
</tr>
</tbody>
</table>
<p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">进入输入或取代的编辑模式</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i, I</td>
<td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td>
</tr>
<tr>
<td style="text-align:left">a, A</td>
<td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td>
</tr>
<tr>
<td style="text-align:left">o, O</td>
<td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td>
</tr>
<tr>
<td style="text-align:left">r, R</td>
<td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td>
</tr>
<tr>
<td style="text-align:left">[Esc]</td>
<td>退出编辑模式，回到一般模式中(常用)</td>
</tr>
</tbody>
</table>
<p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>指令行的储存、离开等指令</strong></th>
<th>****</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>:w</strong></td>
<td><strong>将编辑的数据写入硬盘档案中(常用)</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>:w!</strong></td>
<td><strong>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>:q</strong></td>
<td><strong>离开 vi (常用)</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>:q!</strong></td>
<td><strong>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</strong></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"><strong>:wq</strong></td>
<td><strong>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</strong></td>
</tr>
<tr>
<td style="text-align:left"><strong>ZZ</strong></td>
<td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td>
</tr>
<tr>
<td style="text-align:left">:w [filename]</td>
<td>将编辑的数据储存成另一个档案（类似另存新档）</td>
</tr>
<tr>
<td style="text-align:left">:r [filename]</td>
<td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td>
</tr>
<tr>
<td style="text-align:left">:n1,n2 w [filename]</td>
<td>将 n1 到 n2 的内容储存成 filename 这个档案。</td>
</tr>
<tr>
<td style="text-align:left">:! command</td>
<td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！</td>
</tr>
<tr>
<td style="text-align:left"><mark>:set nu</mark></td>
<td><mark>显示行号，设定之后，会在每一行的前缀显示该行的行号</mark></td>
</tr>
<tr>
<td style="text-align:left"><mark>:set nonu</mark></td>
<td><mark>与 set nu 相反，为取消行号！</mark></td>
</tr>
</tbody>
</table>
<h2 id="3-账号管理">3. 账号管理</h2>
<h3 id="31-简介">3.1 简介</h3>
<p>Linux系统是一个<strong>多用户多任务的分时操作系统</strong>，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p>
<p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p>
<ul>
<li>用户账号的添加、删除与修改。</li>
<li>用户口令的管理。</li>
<li>用户组的管理。</li>
</ul>
<h3 id="32-用户账号的管理">3.2 用户账号的管理</h3>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p>
<p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p>
<h4 id="321-添加账号-useradd">3.2.1 添加账号 useradd</h4>
<pre><code class="language-bash">useradd 选项 用户名
</code></pre>
<p>参数说明：</p>
<ul>
<li>
<p>选项包括 :</p>
<ul>
<li>
<p>-c comment 指定一段注释性描述。</p>
</li>
<li>
<p>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</p>
</li>
<li>
<p>-g 用户组 指定用户所属的用户组。</p>
</li>
<li>
<p><strong>-G 用户组，用户组 指定用户所属的附加组。</strong></p>
</li>
<li>
<p><mark><strong>-m　使用者目录如不存在则自动建立（自动创建这个用户的主目录）。</strong></mark></p>
</li>
<li>
<p>-s Shell文件 指定用户的登录Shell。</p>
</li>
<li>
<p>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p>
</li>
</ul>
</li>
<li>
<p>用户名 :</p>
<ul>
<li>指定新账号的登录名。</li>
</ul>
</li>
</ul>
<p>测试：</p>
<figure data-type="image" tabindex="23"><img src="https://chase-don.github.io//post-images/image-20210430215209525.png" alt="image-20210430215209525" loading="lazy"></figure>
<p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p>
<figure data-type="image" tabindex="24"><img src="https://chase-don.github.io//post-images/image-20210430215707949.png" alt="image-20210430215707949" loading="lazy"></figure>
<h4 id="322-删除帐号userdel">3.2.2 删除帐号（userdel）</h4>
<p>如果一个用户的账号不再使用，可以从系统中删除。</p>
<p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p>
<p>删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<pre><code class="language-bash">userdel 选项 用户名
</code></pre>
<p><mark><strong>常用的选项是 -r，它的作用是把用户的主目录一起删除。</strong></mark></p>
<figure data-type="image" tabindex="25"><img src="https://chase-don.github.io//post-images/image-20210430220443995.png" alt="image-20210430220443995" loading="lazy"></figure>
<p>此命令删除用户chasertung在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<h4 id="323-linux下如何切换用户su-usernamesuswitch-user">3.2.3 Linux下如何切换用户（su username）su：switch user</h4>
<figure data-type="image" tabindex="26"><img src="https://chase-don.github.io//post-images/image-20210501002712407.png" alt="image-20210501002712407" loading="lazy"></figure>
<p>1.切换用户的命令为：<strong><mark>su username</mark></strong> 【username是你的用户名哦】</p>
<img src="file://D:/博客源文件/post-images/image-20210501003014660.png" alt="image-20210501003014660" style="zoom: 50%;" />
<p>2.从普通用户切换到root用户，还可以使用命令：<strong><mark>sudo su</mark></strong></p>
<p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p>
<img src="file://D:/博客源文件/post-images/image-20210501003143023.png" alt="image-20210501003143023" style="zoom: 67%;" />
<p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p>
<p>$  表示普通用户</p>
<p><mark><strong>#  表示超级用户，也就是root用户</strong></mark></p>
<p>补充：<strong>（关于修改主机名，修改完后重新连接即可）</strong></p>
<figure data-type="image" tabindex="27"><img src="https://chase-don.github.io//post-images/image-20210501003619853.png" alt="image-20210501003619853" loading="lazy"></figure>
<h4 id="324-修改帐号usermod">3.2.4 修改帐号（usermod）</h4>
<p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<p>修改已有用户的信息使用usermod命令，其格式如下：</p>
<pre><code class="language-bash">usermod 选项 用户名
</code></pre>
<p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p>
<p>例如：</p>
<pre><code class="language-bash"># usermod -s /bin/ksh -d /home/z –g developer chasertung
</code></pre>
<p>此命令将用户chasertung的登录Shell修改为ksh，<strong>主目录改为/home/z</strong>，用户组改为developer。</p>
<h4 id="325-用户口令的管理passwd">3.2.5 用户口令的管理（passwd）</h4>
<p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p>
<p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p>
<p>命令的格式为：</p>
<pre><code class="language-bash">passwd 选项 用户名
</code></pre>
<p>可使用的选项：（-l 和 -d 都可以使用户连接不上服务器）</p>
<ul>
<li>-l 锁定口令，即禁用账号。（lock）</li>
<li>-u 口令解锁。</li>
<li>-d 使账号无口令。</li>
<li>-f 强迫用户下次登录时修改口令。</li>
</ul>
<p>如果默认用户名，则修改当前用户的口令。</p>
<p>例如，假设当前用户是loro，则下面的命令修改该用户自己的口令：</p>
<pre><code class="language-bash">$ passwd
Old password:******
New password:*******
Re-enter new password:*******
</code></pre>
<p>如果是超级用户，可以用下列形式指定任何用户的口令：<strong>（passwd 用户名）</strong></p>
<pre><code class="language-bash"># passwd loro
New password:*******
Re-enter new password:*******
</code></pre>
<p><strong>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</strong>（<mark>普通用户和超级用户修改口令的区别</mark>）</p>
<p>root为用户指定空口令时，执行下列形式的命令：</p>
<pre><code class="language-bash"># passwd -d loro
</code></pre>
<p>此命令将用户 loro的口令删除，这样用户 loro下一次登录时，系统就不再允许该用户登录了。</p>
<p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p>
<pre><code class="language-bash"># passwd -l loro
</code></pre>
<h2 id="4-用户组管理etcgroup">4. 用户组管理(/etc/group)</h2>
<p><strong>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理</strong>。不同Linux 系统对用户组的规定有所不同，如Linux下的<strong>用户属于与它同名的用户组（如上一节中创建的chasertung用户）</strong>，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。<strong><mark>组的增加、删除和修改实际上就是对/etc/group文件的更新。</mark></strong></p>
<h3 id="41-增加一个新的用户组使用groupadd命令">4.1 增加一个新的用户组使用groupadd命令</h3>
<figure data-type="image" tabindex="28"><img src="https://chase-don.github.io//post-images/image-20210501011322958.png" alt="image-20210501011322958" loading="lazy"></figure>
<blockquote>
<h4 id="groupadd-选项-用户组"><strong>groupadd 选项 用户组</strong></h4>
</blockquote>
<p>可以使用的选项有：</p>
<ul>
<li>-g ：GID 自定义新用户组的<strong>组标识号（GID）</strong>。</li>
<li>-o ： 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li>
</ul>
<p>实例1：</p>
<pre><code class="language-bash"># groupadd dongshuai
</code></pre>
<p>此命令向系统中增加了一个新组group1，<strong>新组的组标识号是在当前已有的最大组标识号的基础上加1</strong>。</p>
<p>实例2：</p>
<pre><code class="language-bash"># groupadd -g 520 shuaidong
</code></pre>
<p>此命令向系统中增加了一个新组shuaidong，同时指定新组的组标识号是520。</p>
<figure data-type="image" tabindex="29"><img src="https://chase-don.github.io//post-images/image-20210501011726074.png" alt="image-20210501011726074" loading="lazy"></figure>
<h3 id="42-删除一个已有的用户组使用groupdel命令">4.2 删除一个已有的用户组使用groupdel命令</h3>
<blockquote>
<h4 id="groupdel-用户组"><strong>groupdel 用户组</strong></h4>
</blockquote>
<p>例如：</p>
<figure data-type="image" tabindex="30"><img src="https://chase-don.github.io//post-images/image-20210501012207285.png" alt="image-20210501012207285" loading="lazy"></figure>
<p>此命令从系统中删除组shuaidong。</p>
<h3 id="43-修改用户组的属性使用groupmod命令">4.3 修改用户组的属性使用groupmod命令</h3>
<blockquote>
<h4 id="groupmod-选项-用户组">groupmod 选项 用户组</h4>
</blockquote>
<p>常用的选项有：</p>
<ul>
<li>-g ：GID 为用户组指定新的组标识号。</li>
<li>-o ：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li>
<li>-n ：新用户组名， 将用户组的名字改为新名字</li>
</ul>
<pre><code class="language-bash"># 此命令将组dongshuai的组标识号修改为666
[root@loro ~]# groupmod -g 666 dongshuai


# 将组dongshuai的标识号改为666，组名修改为kurt。
[root@loro ~]# groupmod -g 666 -n kurt dongshuai
</code></pre>
<h3 id="44-切换组">4.4 切换组</h3>
<p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p>
<p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如<strong>在chasertung用户下</strong>：</p>
<pre><code class="language-bash">$ newgrp root
</code></pre>
<p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p>
<h3 id="45-扩展">4.5 扩展：</h3>
<h4 id="451-关于etcpasswd">4.5.1 关于/etc/passwd</h4>
<p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p>
<p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p>
<p>下面分别介绍这些文件的内容。</p>
<p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p>
<p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p>
<p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p>
<figure data-type="image" tabindex="31"><img src="https://chase-don.github.io//post-images/image-20210501180408887.png" alt="image-20210501180408887" loading="lazy"></figure>
<p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p>
<blockquote>
<p><mark><strong>用户名:口令(登录密码，在这里不可见):用户标识号:组标识号:注释性描述:主目录:登录Shell</strong></mark></p>
</blockquote>
<p>1）&quot;用户名&quot;是代表用户账号的字符串。</p>
<p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(😃，因为冒号在这里是分隔符。</p>
<p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p>
<p>2）“口令”一些系统中，存放着加密后的用户口令字。</p>
<p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。</p>
<p>因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把**<mark>真正的加密后的用户口令字存放到/etc/shadow文件中</mark>**，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p>
<p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p>
<p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p>
<p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p>
<p>4）“组标识号”字段记录的是用户所属的用户组。</p>
<p>它对应着/etc/group文件中的一条记录。</p>
<p>5)“注释性描述”字段记录着用户的一些个人情况。</p>
<p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p>
<p>6)“主目录”，也就是用户的起始工作目录。</p>
<p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p>
<p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p>
<p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p>
<p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p>
<p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p>
<p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p>
<p>8)系统中有一类用户称为伪用户（pseudo users）。</p>
<p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p>
<p>常见的伪用户如下所示：</p>
<pre><code>伪 用 户 含 义
bin 拥有可执行的用户命令文件
sys 拥有系统文件
adm 拥有帐户文件
uucp UUCP使用
lp lp或lpd子系统使用
nobody NFS使用
</code></pre>
<h4 id="452-关于etcshadow">4.5.2 关于/etc/shadow</h4>
<p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p>
<p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p>
<p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p>
<p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用&quot;:&quot;隔开。这些字段是：</p>
<pre><code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
</code></pre>
<ol>
<li>&quot;登录名&quot;是与/etc/passwd文件中的登录名相一致的用户账号</li>
<li>&quot;口令&quot;字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li>
<li>&quot;最后一次修改时间&quot;表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li>
<li>&quot;最小时间间隔&quot;指的是两次修改口令之间所需的最小天数。</li>
<li>&quot;最大时间间隔&quot;指的是口令保持有效的最大天数。</li>
<li>&quot;警告时间&quot;字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li>
<li>&quot;不活动时间&quot;表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li>
<li>&quot;失效时间&quot;字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li>
</ol>
<h4 id="453-关于etcgroup">4.5.3 关于/etc/group</h4>
<p>用户组的所有信息都存放在/etc/group文件中。</p>
<p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p>
<p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p>
<p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p>
<p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p>
<p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p>
<pre><code>组名:口令:组标识号:组内用户列表
</code></pre>
<ol>
<li>&quot;组名&quot;是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</li>
<li>&quot;口令&quot;字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li>
<li>&quot;组标识号&quot;与用户标识号类似，也是一个整数，被系统内部用来标识组。</li>
<li>&quot;组内用户列表&quot;是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li>
</ol>
<h2 id="5-磁盘管理">5. 磁盘管理</h2>
<h3 id="51-概述">5.1 概述</h3>
<p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p>
<p>Linux磁盘管理常用命令为 df、du。</p>
<ul>
<li>df ：Disk free，列出文件系统的整体磁盘使用量</li>
<li>du：Disk usage，检查磁盘空间使用量</li>
</ul>
<h3 id="52-df">5.2 df</h3>
<p>df命令参数功能：<strong>检查文件系统的磁盘空间占用情况</strong>。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p>
<p>语法：</p>
<blockquote>
<h3 id="df-ahikhtm-目录或文件名"><mark>df [-ahikHTm] [目录或文件名]</mark></h3>
</blockquote>
<p>选项与参数：(选项可联合使用)</p>
<ul>
<li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>
<li>-k ：以 KBytes 的容量显示各文件系统；</li>
<li>-m ：以 MBytes 的容量显示各文件系统；</li>
<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>
<li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li>
<li>-T ：<strong>显示文件系统类型,</strong> 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>
<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>
</ul>
<p>测试：</p>
<figure data-type="image" tabindex="32"><img src="https://chase-don.github.io//post-images/image-20210501182854678.png" alt="image-20210501182854678" loading="lazy"></figure>
<p>测试2：# 将 /etc 底下的可用的磁盘容量以易读的容量格式显示</p>
<figure data-type="image" tabindex="33"><img src="https://chase-don.github.io//post-images/image-20210501195509373.png" alt="image-20210501195509373" loading="lazy"></figure>
<h3 id="53-du">5.3 du</h3>
<p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux <strong>du命令是对文件和目录磁盘使用的空间的查看</strong>，还是和df命令有一些区别的，这里介绍Linux du命令。</p>
<p>语法：</p>
<blockquote>
<h3 id="du-ahskm-文件或目录名称"><mark>du [-ahskm] 文件或目录名称</mark></h3>
</blockquote>
<p>选项与参数：</p>
<ul>
<li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li>
<li>-h ：以人们较易读的容量格式 (G/M) 显示；</li>
<li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li>
<li>-S ：不包括子目录下的总计，与 -s 有点差别。</li>
<li>-k ：以 KBytes 列出容量显示；</li>
<li>-m ：以 MBytes 列出容量显示；</li>
</ul>
<p>测试：</p>
<figure data-type="image" tabindex="34"><img src="https://chase-don.github.io//post-images/image-20210501204259069.png" alt="image-20210501204259069" loading="lazy"></figure>
<figure data-type="image" tabindex="35"><img src="https://chase-don.github.io//post-images/image-20210501204745636.png" alt="image-20210501204745636" loading="lazy"></figure>
<p>其中：</p>
<ul>
<li>
<p>-s：列出总量，-m：以Mb列出展示，选项可以合并使用；</p>
</li>
<li>
<p><strong>通配符 * 来代表每个目录</strong>。</p>
</li>
</ul>
<p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p>
<h2 id="6-进程管理">6. 进程管理</h2>
<h3 id="61-概述">6.1 概述</h3>
<blockquote>
<p>进程相关概念</p>
</blockquote>
<ol>
<li>在Linux中，每一个程序都是有自己的一个进程，每一个进程都有一个id号</li>
<li>每一个进程都会有一个父进程！</li>
<li>进程有两种存在方式：前台及后台运行</li>
<li>一般服务都是后台运行的，基本的程序都是前台运行的！</li>
</ol>
<h3 id="62-线程命令">6.2 线程命令</h3>
<blockquote>
<h3 id="ps-options"><mark>ps [options]</mark></h3>
<h3 id="ps-options-grep-progressname-查看具体进程信息">ps [options] | grep progressname  -&gt; 查看具体进程信息</h3>
</blockquote>
<p>选项包含：</p>
<ul>
<li>-a：显示当前终端进行的进程信息</li>
<li>-u：以用户为单位显示开启的进程</li>
<li>-x：显示后台运行进程的参数</li>
</ul>
<pre><code class="language-bash"># ps -aux 或者 ps -ef 都是查看所有的进程但略有不同，后面介绍
ps -aux | grep nginx
ps -ef | grep redis

# 常常会用到 `|`  这个在Linux中叫做管道符   比如： A|B  即A完成的结果作为输出来操作B命令
# grep  查找文件中符合条件的字符串
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://chase-don.github.io//post-images/image-20210501212040893.png" alt="image-20210501212040893" loading="lazy"></figure>
<blockquote>
<h3 id="ps-ef可以查看到父进程的信息">ps -ef：可以查看到父进程的信息</h3>
<h3 id="但是看父进程可以用目录树结构查看">但是看父进程可以用目录树结构查看</h3>
<h3 id="pstree-pu"><mark>pstree -pu</mark></h3>
<h3 id="-p显示父id">-p：显示父id</h3>
<h3 id="-u显示用户组">-u：显示用户组</h3>
</blockquote>
<figure data-type="image" tabindex="37"><img src="https://chase-don.github.io//post-images/image-20210501215101212.png" alt="image-20210501215101212" loading="lazy"></figure>
<blockquote>
<h3 id="结束进程用kill">结束进程用kill</h3>
<h3 id="kill-9-uid"><mark><strong>kill [-9] uid</strong></mark></h3>
<h3 id="-9表示强制杀掉进程-uid表示进程的id号">-9：表示强制杀掉进程， uid表示进程的id号</h3>
</blockquote>
<h3 id="63-补">6.3 补：</h3>
<ol>
<li>
<p>如果想對進程時間監控/动态的显示进程信息（查看CPU load），應該用 <mark><strong>top</strong></mark> 工具。</p>
</li>
<li>
<p>java程序后台执行，用 <strong><mark>nohup</mark></strong> ，代表后台执行程序</p>
</li>
</ol>
<h2 id="7-环境安装">7. 环境安装</h2>
<h3 id="71-关于linux防火墙端口设置">7.1 关于Linux防火墙端口设置</h3>
<pre><code class="language-bash"># 查看firewall服务状态
systemctl status firewalld

# 开启、重启、关闭、firewalld.service服务
# 开启
service firewalld start
# 重启
service firewalld restart
# 关闭
service firewalld stop

# 查看防火墙规则
firewall-cmd --list-all    # 查看全部信息
firewall-cmd --list-ports  # 只看端口信息

# 开启端口
开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent
重启防火墙：systemctl restart firewalld.service

命令含义：
--zone #作用域
--add-port=80/tcp  #添加端口，格式为：端口/通讯协议
--permanent   #永久生效，没有此参数重启后失效
</code></pre>
<h3 id="72-安装dockeryum">7.2 安装Docker（yum）</h3>
<p>可以根据官网https://docs.docker.com/install/linux/docker-ce/centos/进行安装。</p>
<ol>
<li>
<p>检测CentOS是否为7</p>
<pre><code class="language-bash">[root@loro ~]# cat /etc/redhat-release 
CentOS Linux release 7.6.1810 (Core)
</code></pre>
</li>
<li>
<p>安装我们的准备环境</p>
<pre><code class="language-bash"># yum install  --&gt;  安装命令
# -y 表示所有的提示都为y（省略了安装过程中需要自己收到点y的步骤）
yum -y install 包名
</code></pre>
</li>
<li>
<p>yum安装gcc相关（需要确保 虚拟机可以上外网 ）</p>
<pre><code class="language-bash">yum -y install gcc
yum -y install gcc-c++
</code></pre>
</li>
<li>
<p>卸载旧版本</p>
<pre><code class="language-bash">yum -y remove docker docker-common docker-selinux docker-engine
# 官网版本
yum remove docker \
          docker-client \
          docker-client-latest \
          docker-common \
          docker-latest \
          docker-latest-logrotate \
          docker-logrotate \
          docker-engine
</code></pre>
</li>
<li>
<p>安装需要的软件包</p>
<pre><code class="language-bash">yum install -y yum-utils
</code></pre>
</li>
<li>
<p>设置stable镜像仓库</p>
<pre><code class="language-bash"># 错误
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
## 报错
[Errno 14] curl#35 - TCP connection reset by peer
[Errno 12] curl#35 - Timeout

# 正确推荐使用国内的
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
</li>
<li>
<p>安装Docker CE</p>
<pre><code class="language-bash">yum -y install docker-ce docker-ce-cli containerd.io
</code></pre>
</li>
<li>
<p>启动docker</p>
<pre><code class="language-bash">systemctl start docker
</code></pre>
</li>
<li>
<p>测试</p>
<pre><code class="language-bash">docker version

docker run hello-world

docker images
</code></pre>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JVM 20.12.25]]></title>
        <id>https://chase-don.github.io/post/jvm-21225/</id>
        <link href="https://chase-don.github.io/post/jvm-21225/">
        </link>
        <updated>2020-12-26T09:19:39.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>关于lambda表达式的标准格式：</p>
<ul>
<li>
<p>由三部分组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
</li>
<li>
<p>格式：</p>
<ul>
<li>（参数列表） -&gt; {一些重写方法的代码}</li>
</ul>
</li>
<li>
<p>解释说明格式：</p>
<ul>
<li>（）：接口中抽象方法的参数列表，没有参数就空着；有参数就写出参数，多个参数使用逗号分割</li>
<li>-&gt; ：传递的意思，把参数传递给方法体{}</li>
<li>{}：重写接口的抽象方法的方法体</li>
</ul>
</li>
<li>
<p>Lambda表达式：是可推导，可省略的</p>
<ul>
<li>
<p>凡是根据上下文推导出来的内容，都可以省略书写</p>
</li>
<li>
<p>可以省略的内容:</p>
<ol>
<li>
<p>(参数列表)：括号中参数列表的数据类型，可以省略不写</p>
</li>
<li>
<p>(参数列表)：括号中的参数如果只有一个，那么类型和()都可以省略</p>
</li>
<li>
<p>{一些代码}：如果{}中的代码只有一行，无论是否有返回值，都可以({}，return，分号)</p>
<p>注意：要省略{}，return，分号必须一起省略</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Lambda的使用前提：</p>
<ul>
<li>
<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>
<p><strong>使用Lambda必须使用接口，且要求接口中有且仅有一个抽象方法。</strong></p>
</li>
<li>
<p>使用Lambda必须具有上下文推断。</p>
<p>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</p>
</li>
</ol>
<p>备注：有且仅有一个抽象方法的接口，成为**&quot;函数式接口&quot;**。</p>
</li>
</ul>
</li>
<li>
<p>请你谈谈对JVM的理解   java-&gt; .class -&gt; jvm</p>
</li>
<li>
<p>java8虚拟机和之前的变化更新？</p>
</li>
<li>
<p>JVM常用调优参数有哪些</p>
</li>
<li>
<p>内存快照如何抓取，怎么分析Dump文件？</p>
</li>
<li>
<p>关于类加载器的认识？</p>
</li>
</ul>
<h2 id="1-jvm的位置">1. JVM的位置</h2>
<figure data-type="image" tabindex="1"><img src="https://chase-don.github.io//post-images/image-20210316143808784.png" alt="image-20210316143808784" loading="lazy"></figure>
<h2 id="2-jvm的体系结构">2. JVM的体系结构</h2>
<p>整体框架图：</p>
<figure data-type="image" tabindex="2"><img src="https://chase-don.github.io//post-images/image-20210316154703858.png" alt="image-20210316154703858" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://chase-don.github.io//post-images/image-20210316153145818.png" alt="image-20210316153145818" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://chase-don.github.io//post-images/image-20210316154216866.png" alt="image-20210316154216866" loading="lazy"></figure>
<h2 id="3-类加载器">3. 类加载器</h2>
<p>​	作用： 加载class文件</p>
<figure data-type="image" tabindex="5"><img src="https://chase-don.github.io//post-images/image-20210317014948778.png" alt="image-20210317014948778" loading="lazy"></figure>
<ol>
<li>
<p>虚拟机自带的加载器</p>
</li>
<li>
<p>启动类(根)加载器</p>
</li>
<li>
<p>扩展类加载器</p>
</li>
<li>
<p>应用程序(系统类)加载器</p>
</li>
<li>
<p><strong>百度双亲委派机制</strong></p>
</li>
</ol>
<h2 id="4-native重点">4. Native（重点）</h2>
<pre><code class="language-java">public static void main(String[] args) {
    new Thread(() -&gt; {}, &quot;my thread name&quot;).start();
}

// native：凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库！
//会进入本地方法栈，本地方法栈调用本地方法接口(JNI, java native interface)
//JNI的作用：扩展java的使用，融合不同的编程语言为Java所用  最初：C,C++
//Java诞生的时候，C/C++横行，要立足就必须要有调用C/C++的程序
//它在内存区域中专门开辟了一块标记区域： Native Method Stack，登记Native方法
//在最终执行的时候，通过JNI加载本地方法库中的方法
private native void start0();
</code></pre>
<h2 id="5-方法区method-area">5. 方法区（Method Area）</h2>
<p>​	方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，<strong>所有定义的方法的信息都保存在该区域，此区域属于共享区间</strong></p>
<p>​	<mark><strong>静态变量、常量、类信息（构造方法、接口定义）、运行时的常量池存在方法区中，但是，实例变量存在堆内存中，和方法区无关</strong></mark>  （static、final、Class、常量池）</p>
<p>​		注意：jdk1.7以后，常量池逻辑上属于方法区，实际存放在堆中</p>
<h2 id="6-栈">6. 栈</h2>
<p>栈：栈内存，主管程序的运行，生命周期和线程同步；</p>
<p>线程结束，栈内存就释放，对于栈来说，<strong>不会存在垃圾回收问题</strong></p>
<p>一旦线程结束，栈就over！</p>
<p><mark><strong>栈：8种基本类型 + 对象引用 + 实例方法</strong></mark></p>
<p>栈运行原理：<strong>栈帧</strong></p>
<figure data-type="image" tabindex="6"><img src="https://chase-don.github.io//post-images/image-20210319204322429.png" alt="image-20210319204322429" loading="lazy"></figure>
<ul>
<li>栈 +堆+方法区：交互关系</li>
</ul>
<p>画出一个对象在内存中实例化的过程</p>
<h2 id="7-堆">7. 堆</h2>
<h3 id="71heap一个jvm只有一个堆内存堆内存的大小是可以调节的">7.1Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</h3>
<h3 id="72类加载器读取了类文件后一般会把什么东西放到堆中">7.2类加载器读取了类文件后，一般会把什么东西放到堆中？</h3>
<p><strong>类，方法，常量，变量等，保存我们所有引用类型的真实对象（实例）</strong></p>
<h3 id="73-堆内存中还要细分为三个区域">7.3 堆内存中还要细分为三个区域：</h3>
<ul>
<li>新生区（伊甸园区） Young/New</li>
<li>养老区  Old</li>
<li>永久区  Perm  (现在被元空间取代，自己查证一下)</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://chase-don.github.io//post-images/image-20210320003015815.png" alt="image-20210320003015815" loading="lazy"></figure>
<p>GC垃圾回收：<strong><mark>主要是在伊甸园区和养老区</mark></strong></p>
<p>假设内存满了，<strong>OOM(OutOfMemory)</strong>，堆内存不够！</p>
<p>在jdk1.8以后，永久存储区改了个名字 ---&gt;  <mark><strong>元空间</strong></mark></p>
<h4 id="731-新生区">7.3.1 新生区</h4>
<ul>
<li>一个类诞生和成长的地方，甚至死亡；能在新生区活下来就能进入养老区（老年区）</li>
<li>新生区分为两个区：伊甸园区和幸存者区（0,1）
<ul>
<li>所有的对象都是在 伊甸园区 new出来的</li>
<li>经过研究，99%的对象都是临时对象！</li>
<li><strong>过程：伊甸园区满了进行一次轻gc，没被回收的进入幸存者区；经过n次循环后，幸存区满了，整个新生区都爆满进行一次重gc，幸存下来的可以进入养老区，养老区满后会出现OOM</strong></li>
</ul>
</li>
</ul>
<h4 id="732-老年区略">7.3.2 老年区（略）</h4>
<h4 id="733-永久区">7.3.3 永久区</h4>
<p>这个区域常驻于内存中。用于存放JDK自身携带的Class对象，Interface元数据，存储的是Java运行时的一些环境或类信息，**这个区域不存在垃圾回收！**关闭虚拟机就会释放这个区域的内存。</p>
<p>一个启动类，加载了大量的第三方jar包；Tomcat部署了太多的应用；大量动态生成的反射类，不断地被加载，直到内存满，就会出现OOM。</p>
<ul>
<li>jdk1.6之前： 永久代，常量池是在方法区；</li>
<li>jdk1.7：永久代，但是慢慢退化了，提出<strong>去永久代</strong>，常量池在堆中</li>
<li>jdk1.8后： 无永久代，<strong>常量池在元空间</strong></li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://chase-don.github.io//post-images/image-20210320164829034.png" alt="image-20210320164829034" loading="lazy"></figure>
<p>元空间：逻辑上存在，物理上不存在（具体可见Demo02）</p>
<p><mark><strong>出现OOM故障时的方法:</strong></mark></p>
<ol>
<li>
<p>尝试扩大堆内存看结果</p>
</li>
<li>
<p>分析内存，看一下哪个地方出了问题（专业工具）</p>
<p>​	a. 能够看到代码第几行出错：内存快照分析工具，<strong>eclipse（MAT）,现常用（Jprofiler）</strong><br>
​    b. Debug，一行行分析代码</p>
</li>
</ol>
<p><strong>MAT,Jprofiler作用：</strong></p>
<ul>
<li>分析Dump文件，快速定位内存泄漏；</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
<li>.....(百度)</li>
</ul>
<h2 id="8-gc-垃圾回收">8. GC: 垃圾回收</h2>
<ol>
<li>
<p><strong>垃圾回收的主要区域是：堆和方法区</strong></p>
</li>
<li>
<p>JVM在进行GC时，并不是对堆中（伊甸园区，幸存区[from,to]，老年区）这三个区域统一回收。大部分时 候，回收都是新生代！</p>
</li>
<li>
<p>GC两种类：轻GC（普通GC）和重GC（全局GC）</p>
</li>
</ol>
<p>GC相关题目：</p>
<ul>
<li>JVM的内存模型和分区？详细到每个区放什么？</li>
<li>堆里面的分区有哪些？ Eden，from，to，老年区。 说说他们的特点？</li>
<li>常用的GC算法有哪些？<mark><strong>标记清除法/标记整理(压缩)法/复制算法/引用计数法</strong></mark>      怎么用的？</li>
<li>轻GC 和 重GC 分别在什么时候发生？</li>
</ul>
<h3 id="81-引用计数法">8.1 引用计数法</h3>
<p>原理：此对象有一个引用，则+1；删除一个引用，则-1。只用收集计数为0的对象。<br>
缺点：无法处理循环引用的问题。如：对象A和B分别有字段b、a，令A.b=B和B.a=A，除此之外这2个对象再无任何引用，那实际上这2个对象已经不可能再被访问，但是引用计数算法却无法回收他们。</p>
<figure data-type="image" tabindex="9"><img src="https://chase-don.github.io//post-images/image-20210322030346166.png" alt="image-20210322030346166" loading="lazy"></figure>
<h3 id="82-复制算法">8.2 复制算法</h3>
<figure data-type="image" tabindex="10"><img src="https://chase-don.github.io//post-images/image-20210322163449084.png" alt="image-20210322163449084" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://chase-don.github.io//post-images/image-20210322173010915.png" alt="image-20210322173010915" loading="lazy"></figure>
<ul>
<li>好处：没有内存的碎片</li>
<li>坏处：浪费了内存空间，幸存区有一般空间永远是空（To）</li>
</ul>
<p><mark><strong>复制算法最佳使用场景：对象存活度较低的 ---&gt; 新生区</strong></mark></p>
<h3 id="83-标记清除算法">8.3 标记清除算法</h3>
<figure data-type="image" tabindex="12"><img src="https://chase-don.github.io//post-images/image-20210322173644454.png" alt="image-20210322173644454" loading="lazy"></figure>
<ul>
<li>优点：不需要额外的空间！</li>
<li>缺点：两次扫描严重浪费时间；会产生内存碎片</li>
</ul>
<h3 id="84-标记压缩法">8.4 标记压缩法</h3>
<figure data-type="image" tabindex="13"><img src="https://chase-don.github.io//post-images/image-20210322174106135.png" alt="image-20210322174106135" loading="lazy"></figure>
<p><strong>优化方式： 先标记清除几次，再进行压缩</strong></p>
<h3 id="85-总结">8.5 总结</h3>
<p>内存效率： 复制算法 &gt; 标记清除算法 &gt; 标记压缩算法（时间复杂度）</p>
<p>内存整齐度：复制算法 = 标记压缩算法 &gt; 标记清除算法</p>
<p>内存利用率：标记压缩算法 = 标记清除算法 &gt; 复制算法</p>
<p>思考：有没有最优算法？</p>
<p>答案：没有，没有最好的算法，只有最合适的   ---&gt;   <mark><strong>GC：分代收集算法</strong></mark></p>
<p><strong>分代收集算法：</strong></p>
<p><strong>年轻代：存活率低 ---&gt; 复制算法</strong></p>
<p><strong>老年代：区域大；存活率高 ---&gt; 标记清除 + 标记压缩混合实现（即清楚几次压缩一次）</strong></p>
<h2 id="9-jmmjava-memory-modeljava内存模型">9. JMM：Java Memory Model（Java内存模型）</h2>
<ol>
<li>
<p>什么是JMM?</p>
</li>
<li>
<p>它是用来干嘛的？</p>
<p>作用：缓存一致性协议，用于定义数据读写的规则</p>
</li>
<li>
<p>它该如何学习？</p>
</li>
</ol>
]]></content>
    </entry>
</feed>